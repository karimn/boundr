// Generated by rstantools.  Do not edit by hand.

/*
    boundrtemp is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    boundrtemp is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with boundrtemp.  If not, see <http://www.gnu.org/licenses/>.
*/
#ifndef MODELS_HPP
#define MODELS_HPP
#define STAN__SERVICES__COMMAND_HPP
#include <rstan/rstaninc.hpp>
// Code generated by Stan version 2.19.1
#include <stan/model/model_header.hpp>
namespace model_bounded_namespace {
using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;
static int current_statement_begin__;
stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_bounded");
    reader.add_event(1, 1, "include", "include/util.stan");
    reader.add_event(1, 0, "start", "include/util.stan");
    reader.add_event(139, 138, "end", "include/util.stan");
    reader.add_event(139, 2, "restart", "model_bounded");
    reader.add_event(139, 2, "include", "include/csr_util.stan");
    reader.add_event(139, 0, "start", "include/csr_util.stan");
    reader.add_event(238, 99, "end", "include/csr_util.stan");
    reader.add_event(238, 3, "restart", "model_bounded");
    reader.add_event(238, 3, "include", "include/r_type_prob.stan");
    reader.add_event(238, 0, "start", "include/r_type_prob.stan");
    reader.add_event(314, 76, "end", "include/r_type_prob.stan");
    reader.add_event(314, 4, "restart", "model_bounded");
    reader.add_event(1432, 1120, "end", "model_bounded");
    return reader;
}
int
num_test(const std::vector<int>& to_test,
             const std::vector<int>& target_val,
             const int& test_equality, std::ostream* pstream__) {
    typedef double local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 5;
        int num_to_test(0);
        (void) num_to_test;  // dummy to suppress unused var warning
        stan::math::fill(num_to_test, std::numeric_limits<int>::min());
        stan::math::assign(num_to_test,num_elements(to_test));
        current_statement_begin__ = 6;
        int num_targets(0);
        (void) num_targets;  // dummy to suppress unused var warning
        stan::math::fill(num_targets, std::numeric_limits<int>::min());
        stan::math::assign(num_targets,num_elements(target_val));
        current_statement_begin__ = 7;
        int result(0);
        (void) result;  // dummy to suppress unused var warning
        stan::math::fill(result, std::numeric_limits<int>::min());
        stan::math::assign(result,0);
        current_statement_begin__ = 9;
        validate_non_negative_index("sorted_to_test", "num_to_test", num_to_test);
        std::vector<int  > sorted_to_test(num_to_test, int(0));
        stan::math::fill(sorted_to_test, std::numeric_limits<int>::min());
        stan::math::assign(sorted_to_test,sort_asc(to_test));
        current_statement_begin__ = 11;
        for (int to_test_index = 1; to_test_index <= num_to_test; ++to_test_index) {
            {
            current_statement_begin__ = 12;
            int found(0);
            (void) found;  // dummy to suppress unused var warning
            stan::math::fill(found, std::numeric_limits<int>::min());
            stan::math::assign(found,0);
            current_statement_begin__ = 14;
            for (int target_index = 1; target_index <= num_targets; ++target_index) {
                current_statement_begin__ = 15;
                if (as_bool(logical_eq(get_base1(sorted_to_test, to_test_index, "sorted_to_test", 1), get_base1(target_val, target_index, "target_val", 1)))) {
                    current_statement_begin__ = 16;
                    if (as_bool(test_equality)) {
                        current_statement_begin__ = 17;
                        stan::math::assign(result, (result + 1));
                    }
                    current_statement_begin__ = 20;
                    stan::math::assign(found, 1);
                    current_statement_begin__ = 21;
                    break;
                }
            }
            current_statement_begin__ = 25;
            if (as_bool((primitive_value(logical_negation(found)) && primitive_value((1 - test_equality))))) {
                current_statement_begin__ = 26;
                stan::math::assign(result, (result + 1));
            }
            }
        }
        current_statement_begin__ = 30;
        return stan::math::promote_scalar<fun_return_scalar_t__>(result);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct num_test_functor__ {
            int
    operator()(const std::vector<int>& to_test,
             const std::vector<int>& target_val,
             const int& test_equality, std::ostream* pstream__) const {
        return num_test(to_test, target_val, test_equality, pstream__);
    }
};
int
num_equals(const std::vector<int>& to_test,
               const std::vector<int>& target_val, std::ostream* pstream__) {
    typedef double local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        current_statement_begin__ = 34;
        return stan::math::promote_scalar<fun_return_scalar_t__>(num_test(to_test, target_val, 1, pstream__));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct num_equals_functor__ {
            int
    operator()(const std::vector<int>& to_test,
               const std::vector<int>& target_val, std::ostream* pstream__) const {
        return num_equals(to_test, target_val, pstream__);
    }
};
std::vector<int>
unique(const std::vector<int>& find_in, std::ostream* pstream__) {
    typedef double local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 38;
        int num_to_tally(0);
        (void) num_to_tally;  // dummy to suppress unused var warning
        stan::math::fill(num_to_tally, std::numeric_limits<int>::min());
        stan::math::assign(num_to_tally,num_elements(find_in));
        current_statement_begin__ = 39;
        validate_non_negative_index("sorted_find_in", "num_to_tally", num_to_tally);
        std::vector<int  > sorted_find_in(num_to_tally, int(0));
        stan::math::fill(sorted_find_in, std::numeric_limits<int>::min());
        stan::math::assign(sorted_find_in,sort_asc(find_in));
        current_statement_begin__ = 40;
        int unique_count(0);
        (void) unique_count;  // dummy to suppress unused var warning
        stan::math::fill(unique_count, std::numeric_limits<int>::min());
        stan::math::assign(unique_count,1);
        current_statement_begin__ = 41;
        validate_non_negative_index("unique_found", "num_to_tally", num_to_tally);
        std::vector<int  > unique_found(num_to_tally, int(0));
        stan::math::fill(unique_found, std::numeric_limits<int>::min());
        current_statement_begin__ = 43;
        stan::model::assign(unique_found, 
                    stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list()), 
                    get_base1(sorted_find_in, 1, "sorted_find_in", 1), 
                    "assigning variable unique_found");
        current_statement_begin__ = 45;
        for (int tally_index = 2; tally_index <= num_to_tally; ++tally_index) {
            current_statement_begin__ = 46;
            if (as_bool(logical_neq(get_base1(sorted_find_in, tally_index, "sorted_find_in", 1), get_base1(unique_found, unique_count, "unique_found", 1)))) {
                current_statement_begin__ = 47;
                stan::math::assign(unique_count, (unique_count + 1));
                current_statement_begin__ = 48;
                stan::model::assign(unique_found, 
                            stan::model::cons_list(stan::model::index_uni(unique_count), stan::model::nil_index_list()), 
                            get_base1(sorted_find_in, tally_index, "sorted_find_in", 1), 
                            "assigning variable unique_found");
            }
        }
        current_statement_begin__ = 52;
        return stan::math::promote_scalar<fun_return_scalar_t__>(stan::model::rvalue(unique_found, stan::model::cons_list(stan::model::index_min_max(1, unique_count), stan::model::nil_index_list()), "unique_found"));
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct unique_functor__ {
            std::vector<int>
    operator()(const std::vector<int>& find_in, std::ostream* pstream__) const {
        return unique(find_in, pstream__);
    }
};
int
num_unique(const std::vector<int>& find_in, std::ostream* pstream__) {
    typedef double local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        current_statement_begin__ = 56;
        return stan::math::promote_scalar<fun_return_scalar_t__>(num_elements(unique(find_in, pstream__)));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct num_unique_functor__ {
            int
    operator()(const std::vector<int>& find_in, std::ostream* pstream__) const {
        return num_unique(find_in, pstream__);
    }
};
std::vector<int>
count(const int& count_size,
          const std::vector<int>& find_in, std::ostream* pstream__) {
    typedef double local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 60;
        validate_non_negative_index("count_array", "count_size", count_size);
        std::vector<int  > count_array(count_size, int(0));
        stan::math::fill(count_array, std::numeric_limits<int>::min());
        stan::math::assign(count_array,rep_array(0, count_size));
        current_statement_begin__ = 62;
        for (int count_index = 1; count_index <= count_size; ++count_index) {
            current_statement_begin__ = 63;
            stan::model::assign(count_array, 
                        stan::model::cons_list(stan::model::index_uni(count_index), stan::model::nil_index_list()), 
                        num_equals(find_in, static_cast<std::vector<int> >(stan::math::array_builder<int >().add(count_index).array()), pstream__), 
                        "assigning variable count_array");
        }
        current_statement_begin__ = 66;
        return stan::math::promote_scalar<fun_return_scalar_t__>(count_array);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct count_functor__ {
            std::vector<int>
    operator()(const int& count_size,
          const std::vector<int>& find_in, std::ostream* pstream__) const {
        return count(count_size, find_in, pstream__);
    }
};
std::vector<int>
array_add(const std::vector<int>& left,
              const std::vector<int>& right, std::ostream* pstream__) {
    typedef double local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 70;
        int array_size(0);
        (void) array_size;  // dummy to suppress unused var warning
        stan::math::fill(array_size, std::numeric_limits<int>::min());
        stan::math::assign(array_size,num_elements(left));
        current_statement_begin__ = 71;
        validate_non_negative_index("array_sum", "array_size", array_size);
        std::vector<int  > array_sum(array_size, int(0));
        stan::math::fill(array_sum, std::numeric_limits<int>::min());
        current_statement_begin__ = 72;
        int right_array_size(0);
        (void) right_array_size;  // dummy to suppress unused var warning
        stan::math::fill(right_array_size, std::numeric_limits<int>::min());
        stan::math::assign(right_array_size,num_elements(right));
        current_statement_begin__ = 74;
        if (as_bool((primitive_value(logical_neq(right_array_size, array_size)) && primitive_value(logical_neq(right_array_size, 1))))) {
            current_statement_begin__ = 75;
            std::stringstream errmsg_stream__;
            errmsg_stream__ << "Incompatible array sizes.";
            throw std::domain_error(errmsg_stream__.str());
        }
        current_statement_begin__ = 78;
        for (int array_index = 1; array_index <= array_size; ++array_index) {
            current_statement_begin__ = 79;
            stan::model::assign(array_sum, 
                        stan::model::cons_list(stan::model::index_uni(array_index), stan::model::nil_index_list()), 
                        (get_base1(left, array_index, "left", 1) + get_base1(right, (logical_gt(right_array_size, 1) ? array_index : 1 ), "right", 1)), 
                        "assigning variable array_sum");
        }
        current_statement_begin__ = 82;
        return stan::math::promote_scalar<fun_return_scalar_t__>(array_sum);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct array_add_functor__ {
            std::vector<int>
    operator()(const std::vector<int>& left,
              const std::vector<int>& right, std::ostream* pstream__) const {
        return array_add(left, right, pstream__);
    }
};
std::vector<int>
extract_group_pos_end(const std::vector<int>& group_sizes,
                          const int& group_to_extract, std::ostream* pstream__) {
    typedef double local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 86;
        int group_pos(0);
        (void) group_pos;  // dummy to suppress unused var warning
        stan::math::fill(group_pos, std::numeric_limits<int>::min());
        stan::math::assign(group_pos,(logical_gt(group_to_extract, 1) ? (sum(stan::model::rvalue(group_sizes, stan::model::cons_list(stan::model::index_min_max(1, (group_to_extract - 1)), stan::model::nil_index_list()), "group_sizes")) + 1) : 1 ));
        current_statement_begin__ = 87;
        int group_end(0);
        (void) group_end;  // dummy to suppress unused var warning
        stan::math::fill(group_end, std::numeric_limits<int>::min());
        stan::math::assign(group_end,((group_pos + get_base1(group_sizes, group_to_extract, "group_sizes", 1)) - 1));
        current_statement_begin__ = 89;
        return stan::math::promote_scalar<fun_return_scalar_t__>(static_cast<std::vector<int> >(stan::math::array_builder<int >().add(group_pos).add(group_end).array()));
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct extract_group_pos_end_functor__ {
            std::vector<int>
    operator()(const std::vector<int>& group_sizes,
                          const int& group_to_extract, std::ostream* pstream__) const {
        return extract_group_pos_end(group_sizes, group_to_extract, pstream__);
    }
};
std::vector<int>
array_extract_group_values(const std::vector<int>& all_values,
                               const std::vector<int>& group_sizes,
                               const std::vector<int>& groups_to_extract, std::ostream* pstream__) {
    typedef double local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 93;
        int num_groups_to_extract(0);
        (void) num_groups_to_extract;  // dummy to suppress unused var warning
        stan::math::fill(num_groups_to_extract, std::numeric_limits<int>::min());
        stan::math::assign(num_groups_to_extract,num_elements(groups_to_extract));
        current_statement_begin__ = 94;
        validate_non_negative_index("num_values", "num_groups_to_extract", num_groups_to_extract);
        std::vector<int  > num_values(num_groups_to_extract, int(0));
        stan::math::fill(num_values, std::numeric_limits<int>::min());
        stan::math::assign(num_values,stan::model::rvalue(group_sizes, stan::model::cons_list(stan::model::index_multi(groups_to_extract), stan::model::nil_index_list()), "group_sizes"));
        current_statement_begin__ = 95;
        validate_non_negative_index("extracted", "sum(num_values)", sum(num_values));
        std::vector<int  > extracted(sum(num_values), int(0));
        stan::math::fill(extracted, std::numeric_limits<int>::min());
        current_statement_begin__ = 97;
        int extracted_pos(0);
        (void) extracted_pos;  // dummy to suppress unused var warning
        stan::math::fill(extracted_pos, std::numeric_limits<int>::min());
        stan::math::assign(extracted_pos,1);
        current_statement_begin__ = 99;
        for (int group_index = 1; group_index <= num_groups_to_extract; ++group_index) {
            {
            current_statement_begin__ = 100;
            int extracted_end(0);
            (void) extracted_end;  // dummy to suppress unused var warning
            stan::math::fill(extracted_end, std::numeric_limits<int>::min());
            stan::math::assign(extracted_end,((extracted_pos + get_base1(num_values, group_index, "num_values", 1)) - 1));
            current_statement_begin__ = 101;
            int actual_curr_group_index(0);
            (void) actual_curr_group_index;  // dummy to suppress unused var warning
            stan::math::fill(actual_curr_group_index, std::numeric_limits<int>::min());
            stan::math::assign(actual_curr_group_index,get_base1(groups_to_extract, group_index, "groups_to_extract", 1));
            current_statement_begin__ = 103;
            validate_non_negative_index("group_pos_end", "2", 2);
            std::vector<int  > group_pos_end(2, int(0));
            stan::math::fill(group_pos_end, std::numeric_limits<int>::min());
            stan::math::assign(group_pos_end,extract_group_pos_end(group_sizes, actual_curr_group_index, pstream__));
            current_statement_begin__ = 105;
            stan::model::assign(extracted, 
                        stan::model::cons_list(stan::model::index_min_max(extracted_pos, extracted_end), stan::model::nil_index_list()), 
                        stan::model::rvalue(all_values, stan::model::cons_list(stan::model::index_min_max(get_base1(group_pos_end, 1, "group_pos_end", 1), get_base1(group_pos_end, 2, "group_pos_end", 1)), stan::model::nil_index_list()), "all_values"), 
                        "assigning variable extracted");
            current_statement_begin__ = 107;
            stan::math::assign(extracted_pos, (extracted_end + 1));
            }
        }
        current_statement_begin__ = 110;
        return stan::math::promote_scalar<fun_return_scalar_t__>(extracted);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct array_extract_group_values_functor__ {
            std::vector<int>
    operator()(const std::vector<int>& all_values,
                               const std::vector<int>& group_sizes,
                               const std::vector<int>& groups_to_extract, std::ostream* pstream__) const {
        return array_extract_group_values(all_values, group_sizes, groups_to_extract, pstream__);
    }
};
std::vector<int>
array_product(const std::vector<int>& left,
                  const std::vector<int>& right, std::ostream* pstream__) {
    typedef double local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 114;
        int array_size(0);
        (void) array_size;  // dummy to suppress unused var warning
        stan::math::fill(array_size, std::numeric_limits<int>::min());
        stan::math::assign(array_size,num_elements(left));
        current_statement_begin__ = 115;
        validate_non_negative_index("array_prod", "array_size", array_size);
        std::vector<int  > array_prod(array_size, int(0));
        stan::math::fill(array_prod, std::numeric_limits<int>::min());
        current_statement_begin__ = 116;
        int right_array_size(0);
        (void) right_array_size;  // dummy to suppress unused var warning
        stan::math::fill(right_array_size, std::numeric_limits<int>::min());
        stan::math::assign(right_array_size,num_elements(right));
        current_statement_begin__ = 118;
        if (as_bool((primitive_value(logical_neq(right_array_size, array_size)) && primitive_value(logical_neq(right_array_size, 1))))) {
            current_statement_begin__ = 119;
            std::stringstream errmsg_stream__;
            errmsg_stream__ << "Incompatible array sizes.";
            throw std::domain_error(errmsg_stream__.str());
        }
        current_statement_begin__ = 122;
        for (int array_index = 1; array_index <= array_size; ++array_index) {
            current_statement_begin__ = 123;
            stan::model::assign(array_prod, 
                        stan::model::cons_list(stan::model::index_uni(array_index), stan::model::nil_index_list()), 
                        (get_base1(left, array_index, "left", 1) * get_base1(right, (logical_gt(right_array_size, 1) ? array_index : 1 ), "right", 1)), 
                        "assigning variable array_prod");
        }
        current_statement_begin__ = 126;
        return stan::math::promote_scalar<fun_return_scalar_t__>(array_prod);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct array_product_functor__ {
            std::vector<int>
    operator()(const std::vector<int>& left,
                  const std::vector<int>& right, std::ostream* pstream__) const {
        return array_product(left, right, pstream__);
    }
};
std::vector<int>
seq(const int& from,
        const int& to,
        const int& by, std::ostream* pstream__) {
    typedef double local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 130;
        int reverse(0);
        (void) reverse;  // dummy to suppress unused var warning
        stan::math::fill(reverse, std::numeric_limits<int>::min());
        stan::math::assign(reverse,logical_gt(from, to));
        current_statement_begin__ = 131;
        int seq_len(0);
        (void) seq_len;  // dummy to suppress unused var warning
        stan::math::fill(seq_len, std::numeric_limits<int>::min());
        stan::math::assign(seq_len,(divide(((1 - (2 * reverse)) * (to - from)), by) + 1));
        current_statement_begin__ = 132;
        validate_non_negative_index("result_seq", "seq_len", seq_len);
        std::vector<int  > result_seq(seq_len, int(0));
        stan::math::fill(result_seq, std::numeric_limits<int>::min());
        current_statement_begin__ = 134;
        for (int seq_index = 1; seq_index <= seq_len; ++seq_index) {
            current_statement_begin__ = 135;
            stan::model::assign(result_seq, 
                        stan::model::cons_list(stan::model::index_uni(seq_index), stan::model::nil_index_list()), 
                        (from + ((1 - (2 * reverse)) * ((seq_index - 1) * by))), 
                        "assigning variable result_seq");
        }
        current_statement_begin__ = 138;
        return stan::math::promote_scalar<fun_return_scalar_t__>(result_seq);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct seq_functor__ {
            std::vector<int>
    operator()(const int& from,
        const int& to,
        const int& by, std::ostream* pstream__) const {
        return seq(from, to, by, pstream__);
    }
};
template <typename T4__>
Eigen::Matrix<typename boost::math::tools::promote_args<T4__>::type, Eigen::Dynamic, 1>
csr_log_sum_exp(const int& m,
                    const int& n,
                    const std::vector<int>& v,
                    const std::vector<int>& u,
                    const Eigen::Matrix<T4__, Eigen::Dynamic, 1>& b, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T4__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 144;
        validate_non_negative_index("result", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> result(m);
        stan::math::initialize(result, DUMMY_VAR__);
        stan::math::fill(result, DUMMY_VAR__);
        stan::math::assign(result,rep_vector(0, m));
        current_statement_begin__ = 146;
        for (int row_index = 1; row_index <= m; ++row_index) {
            {
            current_statement_begin__ = 147;
            int row_size(0);
            (void) row_size;  // dummy to suppress unused var warning
            stan::math::fill(row_size, std::numeric_limits<int>::min());
            stan::math::assign(row_size,(get_base1(u, (row_index + 1), "u", 1) - get_base1(u, row_index, "u", 1)));
            current_statement_begin__ = 149;
            if (as_bool(logical_gt(row_size, 0))) {
                {
                current_statement_begin__ = 150;
                int row_pos(0);
                (void) row_pos;  // dummy to suppress unused var warning
                stan::math::fill(row_pos, std::numeric_limits<int>::min());
                stan::math::assign(row_pos,get_base1(u, row_index, "u", 1));
                current_statement_begin__ = 151;
                int row_end(0);
                (void) row_end;  // dummy to suppress unused var warning
                stan::math::fill(row_end, std::numeric_limits<int>::min());
                stan::math::assign(row_end,((row_pos + row_size) - 1));
                current_statement_begin__ = 153;
                validate_non_negative_index("sub_b", "row_size", row_size);
                Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> sub_b(row_size);
                stan::math::initialize(sub_b, DUMMY_VAR__);
                stan::math::fill(sub_b, DUMMY_VAR__);
                stan::math::assign(sub_b,stan::model::rvalue(b, stan::model::cons_list(stan::model::index_multi(stan::model::rvalue(v, stan::model::cons_list(stan::model::index_min_max(row_pos, row_end), stan::model::nil_index_list()), "v")), stan::model::nil_index_list()), "b"));
                current_statement_begin__ = 155;
                stan::model::assign(result, 
                            stan::model::cons_list(stan::model::index_uni(row_index), stan::model::nil_index_list()), 
                            log_sum_exp(sub_b), 
                            "assigning variable result");
                }
            }
            }
        }
        current_statement_begin__ = 159;
        return stan::math::promote_scalar<fun_return_scalar_t__>(result);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct csr_log_sum_exp_functor__ {
    template <typename T4__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T4__>::type, Eigen::Dynamic, 1>
    operator()(const int& m,
                    const int& n,
                    const std::vector<int>& v,
                    const std::vector<int>& u,
                    const Eigen::Matrix<T4__, Eigen::Dynamic, 1>& b, std::ostream* pstream__) const {
        return csr_log_sum_exp(m, n, v, u, b, pstream__);
    }
};
template <typename T2__, typename T5__>
Eigen::Matrix<typename boost::math::tools::promote_args<T2__, T5__>::type, Eigen::Dynamic, 1>
csr_log_sum_exp2(const int& m,
                     const int& n,
                     const Eigen::Matrix<T2__, Eigen::Dynamic, 1>& w,
                     const std::vector<int>& v,
                     const std::vector<int>& u,
                     const Eigen::Matrix<T5__, Eigen::Dynamic, 1>& b, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T2__, T5__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 163;
        validate_non_negative_index("result", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> result(m);
        stan::math::initialize(result, DUMMY_VAR__);
        stan::math::fill(result, DUMMY_VAR__);
        stan::math::assign(result,rep_vector(0, m));
        current_statement_begin__ = 165;
        for (int row_index = 1; row_index <= m; ++row_index) {
            {
            current_statement_begin__ = 166;
            int row_size(0);
            (void) row_size;  // dummy to suppress unused var warning
            stan::math::fill(row_size, std::numeric_limits<int>::min());
            stan::math::assign(row_size,(get_base1(u, (row_index + 1), "u", 1) - get_base1(u, row_index, "u", 1)));
            current_statement_begin__ = 168;
            if (as_bool(logical_gt(row_size, 0))) {
                {
                current_statement_begin__ = 169;
                int row_pos(0);
                (void) row_pos;  // dummy to suppress unused var warning
                stan::math::fill(row_pos, std::numeric_limits<int>::min());
                stan::math::assign(row_pos,get_base1(u, row_index, "u", 1));
                current_statement_begin__ = 170;
                int row_end(0);
                (void) row_end;  // dummy to suppress unused var warning
                stan::math::fill(row_end, std::numeric_limits<int>::min());
                stan::math::assign(row_end,((row_pos + row_size) - 1));
                current_statement_begin__ = 172;
                validate_non_negative_index("sub_w", "row_size", row_size);
                Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> sub_w(row_size);
                stan::math::initialize(sub_w, DUMMY_VAR__);
                stan::math::fill(sub_w, DUMMY_VAR__);
                stan::math::assign(sub_w,stan::model::rvalue(w, stan::model::cons_list(stan::model::index_min_max(row_pos, row_end), stan::model::nil_index_list()), "w"));
                current_statement_begin__ = 173;
                validate_non_negative_index("sub_b", "row_size", row_size);
                Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> sub_b(row_size);
                stan::math::initialize(sub_b, DUMMY_VAR__);
                stan::math::fill(sub_b, DUMMY_VAR__);
                stan::math::assign(sub_b,stan::model::rvalue(b, stan::model::cons_list(stan::model::index_multi(stan::model::rvalue(v, stan::model::cons_list(stan::model::index_min_max(row_pos, row_end), stan::model::nil_index_list()), "v")), stan::model::nil_index_list()), "b"));
                current_statement_begin__ = 175;
                local_scalar_t__ max_sub_b(DUMMY_VAR__);
                (void) max_sub_b;  // dummy to suppress unused var warning
                stan::math::initialize(max_sub_b, DUMMY_VAR__);
                stan::math::fill(max_sub_b, DUMMY_VAR__);
                stan::math::assign(max_sub_b,max(sub_b));
                current_statement_begin__ = 177;
                stan::model::assign(result, 
                            stan::model::cons_list(stan::model::index_uni(row_index), stan::model::nil_index_list()), 
                            (max_sub_b + stan::math::log(dot_product(sub_w, stan::math::exp(subtract(sub_b, max_sub_b))))), 
                            "assigning variable result");
                }
            }
            }
        }
        current_statement_begin__ = 181;
        return stan::math::promote_scalar<fun_return_scalar_t__>(result);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct csr_log_sum_exp2_functor__ {
    template <typename T2__, typename T5__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T2__, T5__>::type, Eigen::Dynamic, 1>
    operator()(const int& m,
                     const int& n,
                     const Eigen::Matrix<T2__, Eigen::Dynamic, 1>& w,
                     const std::vector<int>& v,
                     const std::vector<int>& u,
                     const Eigen::Matrix<T5__, Eigen::Dynamic, 1>& b, std::ostream* pstream__) const {
        return csr_log_sum_exp2(m, n, w, v, u, b, pstream__);
    }
};
template <typename T3__>
Eigen::Matrix<typename boost::math::tools::promote_args<T3__>::type, Eigen::Dynamic, 1>
csr_diff_exp(const int& m,
                 const int& n,
                 const std::vector<int>& v,
                 const Eigen::Matrix<T3__, Eigen::Dynamic, 1>& b, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T3__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 185;
        validate_non_negative_index("result", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> result(m);
        stan::math::initialize(result, DUMMY_VAR__);
        stan::math::fill(result, DUMMY_VAR__);
        stan::math::assign(result,rep_vector(0, m));
        current_statement_begin__ = 186;
        int row_pos(0);
        (void) row_pos;  // dummy to suppress unused var warning
        stan::math::fill(row_pos, std::numeric_limits<int>::min());
        stan::math::assign(row_pos,1);
        current_statement_begin__ = 188;
        for (int row_index = 1; row_index <= m; ++row_index) {
            {
            current_statement_begin__ = 189;
            int row_end(0);
            (void) row_end;  // dummy to suppress unused var warning
            stan::math::fill(row_end, std::numeric_limits<int>::min());
            stan::math::assign(row_end,(row_pos + 1));
            current_statement_begin__ = 192;
            validate_non_negative_index("sub_b", "2", 2);
            Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> sub_b(2);
            stan::math::initialize(sub_b, DUMMY_VAR__);
            stan::math::fill(sub_b, DUMMY_VAR__);
            stan::math::assign(sub_b,stan::model::rvalue(b, stan::model::cons_list(stan::model::index_multi(stan::model::rvalue(v, stan::model::cons_list(stan::model::index_min_max(row_pos, row_end), stan::model::nil_index_list()), "v")), stan::model::nil_index_list()), "b"));
            current_statement_begin__ = 196;
            stan::model::assign(result, 
                        stan::model::cons_list(stan::model::index_uni(row_index), stan::model::nil_index_list()), 
                        (stan::math::exp(get_base1(sub_b, 1, "sub_b", 1)) - stan::math::exp(get_base1(sub_b, 2, "sub_b", 1))), 
                        "assigning variable result");
            }
        }
        current_statement_begin__ = 199;
        return stan::math::promote_scalar<fun_return_scalar_t__>(result);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct csr_diff_exp_functor__ {
    template <typename T3__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T3__>::type, Eigen::Dynamic, 1>
    operator()(const int& m,
                 const int& n,
                 const std::vector<int>& v,
                 const Eigen::Matrix<T3__, Eigen::Dynamic, 1>& b, std::ostream* pstream__) const {
        return csr_diff_exp(m, n, v, b, pstream__);
    }
};
std::vector<int>
csr_shift_expand_v(const std::vector<int>& indices,
                       const int& shift_size,
                       const int& num_shifts, std::ostream* pstream__) {
    typedef double local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 203;
        int num_indices(0);
        (void) num_indices;  // dummy to suppress unused var warning
        stan::math::fill(num_indices, std::numeric_limits<int>::min());
        stan::math::assign(num_indices,num_elements(indices));
        current_statement_begin__ = 204;
        validate_non_negative_index("new_csr_v", "(num_indices * num_shifts)", (num_indices * num_shifts));
        std::vector<int  > new_csr_v((num_indices * num_shifts), int(0));
        stan::math::fill(new_csr_v, std::numeric_limits<int>::min());
        current_statement_begin__ = 206;
        int id_pos(0);
        (void) id_pos;  // dummy to suppress unused var warning
        stan::math::fill(id_pos, std::numeric_limits<int>::min());
        stan::math::assign(id_pos,1);
        current_statement_begin__ = 208;
        for (int shift_index = 1; shift_index <= num_shifts; ++shift_index) {
            {
            current_statement_begin__ = 209;
            int id_end(0);
            (void) id_end;  // dummy to suppress unused var warning
            stan::math::fill(id_end, std::numeric_limits<int>::min());
            stan::math::assign(id_end,((id_pos + num_indices) - 1));
            current_statement_begin__ = 211;
            stan::model::assign(new_csr_v, 
                        stan::model::cons_list(stan::model::index_min_max(id_pos, id_end), stan::model::nil_index_list()), 
                        array_add(indices, static_cast<std::vector<int> >(stan::math::array_builder<int >().add(((shift_index - 1) * shift_size)).array()), pstream__), 
                        "assigning variable new_csr_v");
            current_statement_begin__ = 213;
            stan::math::assign(id_pos, (id_end + 1));
            }
        }
        current_statement_begin__ = 216;
        return stan::math::promote_scalar<fun_return_scalar_t__>(new_csr_v);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct csr_shift_expand_v_functor__ {
            std::vector<int>
    operator()(const std::vector<int>& indices,
                       const int& shift_size,
                       const int& num_shifts, std::ostream* pstream__) const {
        return csr_shift_expand_v(indices, shift_size, num_shifts, pstream__);
    }
};
std::vector<int>
csr_shift_expand_u(const std::vector<int>& row_sizes,
                       const int& num_shifts, std::ostream* pstream__) {
    typedef double local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 220;
        int num_rows(0);
        (void) num_rows;  // dummy to suppress unused var warning
        stan::math::fill(num_rows, std::numeric_limits<int>::min());
        stan::math::assign(num_rows,num_elements(row_sizes));
        current_statement_begin__ = 221;
        validate_non_negative_index("new_csr_u", "((num_rows * num_shifts) + 1)", ((num_rows * num_shifts) + 1));
        std::vector<int  > new_csr_u(((num_rows * num_shifts) + 1), int(0));
        stan::math::fill(new_csr_u, std::numeric_limits<int>::min());
        current_statement_begin__ = 223;
        int row_pos_pos(0);
        (void) row_pos_pos;  // dummy to suppress unused var warning
        stan::math::fill(row_pos_pos, std::numeric_limits<int>::min());
        stan::math::assign(row_pos_pos,1);
        current_statement_begin__ = 224;
        int last_size(0);
        (void) last_size;  // dummy to suppress unused var warning
        stan::math::fill(last_size, std::numeric_limits<int>::min());
        current_statement_begin__ = 226;
        for (int shift_index = 1; shift_index <= num_shifts; ++shift_index) {
            current_statement_begin__ = 227;
            for (int row_index = 1; row_index <= num_rows; ++row_index) {
                current_statement_begin__ = 228;
                stan::model::assign(new_csr_u, 
                            stan::model::cons_list(stan::model::index_uni(row_pos_pos), stan::model::nil_index_list()), 
                            (logical_gt(row_pos_pos, 1) ? (get_base1(new_csr_u, (row_pos_pos - 1), "new_csr_u", 1) + last_size) : 1 ), 
                            "assigning variable new_csr_u");
                current_statement_begin__ = 229;
                stan::math::assign(last_size, get_base1(row_sizes, row_index, "row_sizes", 1));
                current_statement_begin__ = 231;
                stan::math::assign(row_pos_pos, (row_pos_pos + 1));
            }
        }
        current_statement_begin__ = 235;
        stan::model::assign(new_csr_u, 
                    stan::model::cons_list(stan::model::index_uni(row_pos_pos), stan::model::nil_index_list()), 
                    (get_base1(new_csr_u, (row_pos_pos - 1), "new_csr_u", 1) + last_size), 
                    "assigning variable new_csr_u");
        current_statement_begin__ = 237;
        return stan::math::promote_scalar<fun_return_scalar_t__>(new_csr_u);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct csr_shift_expand_u_functor__ {
            std::vector<int>
    operator()(const std::vector<int>& row_sizes,
                       const int& num_shifts, std::ostream* pstream__) const {
        return csr_shift_expand_u(row_sizes, num_shifts, pstream__);
    }
};
template <typename T7__, typename T8__>
Eigen::Matrix<typename boost::math::tools::promote_args<T7__, T8__>::type, Eigen::Dynamic, 1>
calculate_r_type_joint_prob(const int& num_r_types,
                                const int& num_discrete_r_types,
                                const int& num_discretized_r_types,
                                const int& discrete_group_size,
                                const std::vector<int>& num_compatible_discretized_r_types,
                                const std::vector<int>& compatible_discretized_r_types,
                                const std::vector<std::vector<int> >& compatible_discretized_pair_ids,
                                const Eigen::Matrix<T7__, Eigen::Dynamic, 1>& discrete_prob,
                                const std::vector<Eigen::Matrix<T8__, Eigen::Dynamic, Eigen::Dynamic> >& beta,
                                const int& entity_index, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T7__, T8__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 242;
        int num_discretized_variables(0);
        (void) num_discretized_variables;  // dummy to suppress unused var warning
        stan::math::fill(num_discretized_variables, std::numeric_limits<int>::min());
        stan::math::assign(num_discretized_variables,size(beta));
        current_statement_begin__ = 243;
        validate_non_negative_index("joint_prob", "num_r_types", num_r_types);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> joint_prob(num_r_types);
        stan::math::initialize(joint_prob, DUMMY_VAR__);
        stan::math::fill(joint_prob, DUMMY_VAR__);
        current_statement_begin__ = 245;
        for (int discrete_index = 1; discrete_index <= num_discrete_r_types; ++discrete_index) {
            {
            current_statement_begin__ = 246;
            int discretized_pos(0);
            (void) discretized_pos;  // dummy to suppress unused var warning
            stan::math::fill(discretized_pos, std::numeric_limits<int>::min());
            stan::math::assign(discretized_pos,(1 + ((discrete_index - 1) * num_discretized_r_types)));
            current_statement_begin__ = 247;
            int discretized_end(0);
            (void) discretized_end;  // dummy to suppress unused var warning
            stan::math::fill(discretized_end, std::numeric_limits<int>::min());
            stan::math::assign(discretized_end,(discrete_index * num_discretized_r_types));
            current_statement_begin__ = 248;
            int discrete_group_pos(0);
            (void) discrete_group_pos;  // dummy to suppress unused var warning
            stan::math::fill(discrete_group_pos, std::numeric_limits<int>::min());
            stan::math::assign(discrete_group_pos,(1 + ((discrete_index - 1) * discrete_group_size)));
            current_statement_begin__ = 249;
            int discrete_group_end(0);
            (void) discrete_group_end;  // dummy to suppress unused var warning
            stan::math::fill(discrete_group_end, std::numeric_limits<int>::min());
            stan::math::assign(discrete_group_end,(discrete_index * discrete_group_size));
            current_statement_begin__ = 250;
            int r_prob_pos(0);
            (void) r_prob_pos;  // dummy to suppress unused var warning
            stan::math::fill(r_prob_pos, std::numeric_limits<int>::min());
            stan::math::assign(r_prob_pos,discrete_group_pos);
            current_statement_begin__ = 251;
            int r_prob_end(0);
            (void) r_prob_end;  // dummy to suppress unused var warning
            stan::math::fill(r_prob_end, std::numeric_limits<int>::min());
            stan::math::assign(r_prob_end,discrete_group_end);
            current_statement_begin__ = 253;
            validate_non_negative_index("first_discretized_prob", "num_discretized_r_types", num_discretized_r_types);
            Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> first_discretized_prob(num_discretized_r_types);
            stan::math::initialize(first_discretized_prob, DUMMY_VAR__);
            stan::math::fill(first_discretized_prob, DUMMY_VAR__);
            stan::math::assign(first_discretized_prob,softmax(stan::model::rvalue(beta, stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_min_max(discretized_pos, discretized_end), stan::model::cons_list(stan::model::index_uni(entity_index), stan::model::nil_index_list()))), "beta")));
            current_statement_begin__ = 255;
            stan::model::assign(joint_prob, 
                        stan::model::cons_list(stan::model::index_min_max(r_prob_pos, r_prob_end), stan::model::nil_index_list()), 
                        multiply(get_base1(discrete_prob, discrete_index, "discrete_prob", 1), stan::model::rvalue(first_discretized_prob, stan::model::cons_list(stan::model::index_multi(stan::model::rvalue(compatible_discretized_pair_ids, stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_min_max(discrete_group_pos, discrete_group_end), stan::model::nil_index_list())), "compatible_discretized_pair_ids")), stan::model::nil_index_list()), "first_discretized_prob")), 
                        "assigning variable joint_prob");
            current_statement_begin__ = 257;
            for (int discretized_var_index = 2; discretized_var_index <= num_discretized_variables; ++discretized_var_index) {
                {
                current_statement_begin__ = 258;
                validate_non_negative_index("curr_cond_discretized_prob", "sum(num_compatible_discretized_r_types)", sum(num_compatible_discretized_r_types));
                Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> curr_cond_discretized_prob(sum(num_compatible_discretized_r_types));
                stan::math::initialize(curr_cond_discretized_prob, DUMMY_VAR__);
                stan::math::fill(curr_cond_discretized_prob, DUMMY_VAR__);
                current_statement_begin__ = 259;
                int cond_prob_pos(0);
                (void) cond_prob_pos;  // dummy to suppress unused var warning
                stan::math::fill(cond_prob_pos, std::numeric_limits<int>::min());
                stan::math::assign(cond_prob_pos,1);
                current_statement_begin__ = 261;
                for (int discretized_type_index = 1; discretized_type_index <= num_discretized_r_types; ++discretized_type_index) {
                    {
                    current_statement_begin__ = 262;
                    int cond_prob_end(0);
                    (void) cond_prob_end;  // dummy to suppress unused var warning
                    stan::math::fill(cond_prob_end, std::numeric_limits<int>::min());
                    stan::math::assign(cond_prob_end,((cond_prob_pos + get_base1(num_compatible_discretized_r_types, discretized_type_index, "num_compatible_discretized_r_types", 1)) - 1));
                    current_statement_begin__ = 263;
                    validate_non_negative_index("compatible_ids", "get_base1(num_compatible_discretized_r_types, discretized_type_index, \"num_compatible_discretized_r_types\", 1)", get_base1(num_compatible_discretized_r_types, discretized_type_index, "num_compatible_discretized_r_types", 1));
                    std::vector<int  > compatible_ids(get_base1(num_compatible_discretized_r_types, discretized_type_index, "num_compatible_discretized_r_types", 1), int(0));
                    stan::math::fill(compatible_ids, std::numeric_limits<int>::min());
                    stan::math::assign(compatible_ids,stan::model::rvalue(compatible_discretized_r_types, stan::model::cons_list(stan::model::index_min_max(cond_prob_pos, cond_prob_end), stan::model::nil_index_list()), "compatible_discretized_r_types"));
                    current_statement_begin__ = 265;
                    stan::model::assign(curr_cond_discretized_prob, 
                                stan::model::cons_list(stan::model::index_min_max(cond_prob_pos, cond_prob_end), stan::model::nil_index_list()), 
                                softmax(stan::model::rvalue(stan::model::rvalue(beta, stan::model::cons_list(stan::model::index_uni(discretized_var_index), stan::model::cons_list(stan::model::index_min_max(discretized_pos, discretized_end), stan::model::cons_list(stan::model::index_uni(entity_index), stan::model::nil_index_list()))), "beta"), stan::model::cons_list(stan::model::index_multi(compatible_ids), stan::model::nil_index_list()), "beta[discretized_var_index, discretized_pos:discretized_end, entity_index]")), 
                                "assigning variable curr_cond_discretized_prob");
                    current_statement_begin__ = 267;
                    stan::math::assign(cond_prob_pos, (cond_prob_end + 1));
                    }
                }
                current_statement_begin__ = 270;
                stan::model::assign(joint_prob, 
                            stan::model::cons_list(stan::model::index_min_max(r_prob_pos, r_prob_end), stan::model::nil_index_list()), 
                            stan::model::deep_copy(elt_multiply(stan::model::rvalue(joint_prob, stan::model::cons_list(stan::model::index_min_max(r_prob_pos, r_prob_end), stan::model::nil_index_list()), "joint_prob"), stan::model::rvalue(curr_cond_discretized_prob, stan::model::cons_list(stan::model::index_multi(stan::model::rvalue(compatible_discretized_pair_ids, stan::model::cons_list(stan::model::index_uni(discretized_var_index), stan::model::cons_list(stan::model::index_min_max(discrete_group_pos, discrete_group_end), stan::model::nil_index_list())), "compatible_discretized_pair_ids")), stan::model::nil_index_list()), "curr_cond_discretized_prob"))), 
                            "assigning variable joint_prob");
                }
            }
            }
        }
        current_statement_begin__ = 275;
        return stan::math::promote_scalar<fun_return_scalar_t__>(joint_prob);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct calculate_r_type_joint_prob_functor__ {
    template <typename T7__, typename T8__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T7__, T8__>::type, Eigen::Dynamic, 1>
    operator()(const int& num_r_types,
                                const int& num_discrete_r_types,
                                const int& num_discretized_r_types,
                                const int& discrete_group_size,
                                const std::vector<int>& num_compatible_discretized_r_types,
                                const std::vector<int>& compatible_discretized_r_types,
                                const std::vector<std::vector<int> >& compatible_discretized_pair_ids,
                                const Eigen::Matrix<T7__, Eigen::Dynamic, 1>& discrete_prob,
                                const std::vector<Eigen::Matrix<T8__, Eigen::Dynamic, Eigen::Dynamic> >& beta,
                                const int& entity_index, std::ostream* pstream__) const {
        return calculate_r_type_joint_prob(num_r_types, num_discrete_r_types, num_discretized_r_types, discrete_group_size, num_compatible_discretized_r_types, compatible_discretized_r_types, compatible_discretized_pair_ids, discrete_prob, beta, entity_index, pstream__);
    }
};
template <typename T7__, typename T8__>
Eigen::Matrix<typename boost::math::tools::promote_args<T7__, T8__>::type, Eigen::Dynamic, 1>
calculate_r_type_joint_log_prob(const int& num_r_types,
                                    const int& num_discrete_r_types,
                                    const int& num_discretized_r_types,
                                    const int& discrete_group_size,
                                    const std::vector<int>& num_compatible_discretized_r_types,
                                    const std::vector<int>& compatible_discretized_r_types,
                                    const std::vector<std::vector<int> >& compatible_discretized_pair_ids,
                                    const Eigen::Matrix<T7__, Eigen::Dynamic, 1>& discrete_log_prob,
                                    const std::vector<Eigen::Matrix<T8__, Eigen::Dynamic, Eigen::Dynamic> >& beta,
                                    const int& entity_index, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T7__, T8__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 281;
        int num_discretized_variables(0);
        (void) num_discretized_variables;  // dummy to suppress unused var warning
        stan::math::fill(num_discretized_variables, std::numeric_limits<int>::min());
        stan::math::assign(num_discretized_variables,size(beta));
        current_statement_begin__ = 282;
        validate_non_negative_index("joint_log_prob", "num_r_types", num_r_types);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> joint_log_prob(num_r_types);
        stan::math::initialize(joint_log_prob, DUMMY_VAR__);
        stan::math::fill(joint_log_prob, DUMMY_VAR__);
        current_statement_begin__ = 284;
        for (int discrete_index = 1; discrete_index <= num_discrete_r_types; ++discrete_index) {
            {
            current_statement_begin__ = 285;
            int discretized_pos(0);
            (void) discretized_pos;  // dummy to suppress unused var warning
            stan::math::fill(discretized_pos, std::numeric_limits<int>::min());
            stan::math::assign(discretized_pos,(1 + ((discrete_index - 1) * num_discretized_r_types)));
            current_statement_begin__ = 286;
            int discretized_end(0);
            (void) discretized_end;  // dummy to suppress unused var warning
            stan::math::fill(discretized_end, std::numeric_limits<int>::min());
            stan::math::assign(discretized_end,(discrete_index * num_discretized_r_types));
            current_statement_begin__ = 287;
            int discrete_group_pos(0);
            (void) discrete_group_pos;  // dummy to suppress unused var warning
            stan::math::fill(discrete_group_pos, std::numeric_limits<int>::min());
            stan::math::assign(discrete_group_pos,(1 + ((discrete_index - 1) * discrete_group_size)));
            current_statement_begin__ = 288;
            int discrete_group_end(0);
            (void) discrete_group_end;  // dummy to suppress unused var warning
            stan::math::fill(discrete_group_end, std::numeric_limits<int>::min());
            stan::math::assign(discrete_group_end,(discrete_index * discrete_group_size));
            current_statement_begin__ = 289;
            int r_prob_pos(0);
            (void) r_prob_pos;  // dummy to suppress unused var warning
            stan::math::fill(r_prob_pos, std::numeric_limits<int>::min());
            stan::math::assign(r_prob_pos,discrete_group_pos);
            current_statement_begin__ = 290;
            int r_prob_end(0);
            (void) r_prob_end;  // dummy to suppress unused var warning
            stan::math::fill(r_prob_end, std::numeric_limits<int>::min());
            stan::math::assign(r_prob_end,discrete_group_end);
            current_statement_begin__ = 292;
            validate_non_negative_index("first_discretized_log_prob", "num_discretized_r_types", num_discretized_r_types);
            Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> first_discretized_log_prob(num_discretized_r_types);
            stan::math::initialize(first_discretized_log_prob, DUMMY_VAR__);
            stan::math::fill(first_discretized_log_prob, DUMMY_VAR__);
            stan::math::assign(first_discretized_log_prob,log_softmax(stan::model::rvalue(beta, stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_min_max(discretized_pos, discretized_end), stan::model::cons_list(stan::model::index_uni(entity_index), stan::model::nil_index_list()))), "beta")));
            current_statement_begin__ = 294;
            stan::model::assign(joint_log_prob, 
                        stan::model::cons_list(stan::model::index_min_max(r_prob_pos, r_prob_end), stan::model::nil_index_list()), 
                        add(get_base1(discrete_log_prob, discrete_index, "discrete_log_prob", 1), stan::model::rvalue(first_discretized_log_prob, stan::model::cons_list(stan::model::index_multi(stan::model::rvalue(compatible_discretized_pair_ids, stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_min_max(discrete_group_pos, discrete_group_end), stan::model::nil_index_list())), "compatible_discretized_pair_ids")), stan::model::nil_index_list()), "first_discretized_log_prob")), 
                        "assigning variable joint_log_prob");
            current_statement_begin__ = 296;
            for (int discretized_var_index = 2; discretized_var_index <= num_discretized_variables; ++discretized_var_index) {
                {
                current_statement_begin__ = 297;
                validate_non_negative_index("curr_cond_discretized_log_prob", "sum(num_compatible_discretized_r_types)", sum(num_compatible_discretized_r_types));
                Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> curr_cond_discretized_log_prob(sum(num_compatible_discretized_r_types));
                stan::math::initialize(curr_cond_discretized_log_prob, DUMMY_VAR__);
                stan::math::fill(curr_cond_discretized_log_prob, DUMMY_VAR__);
                current_statement_begin__ = 298;
                int cond_prob_pos(0);
                (void) cond_prob_pos;  // dummy to suppress unused var warning
                stan::math::fill(cond_prob_pos, std::numeric_limits<int>::min());
                stan::math::assign(cond_prob_pos,1);
                current_statement_begin__ = 300;
                for (int discretized_type_index = 1; discretized_type_index <= num_discretized_r_types; ++discretized_type_index) {
                    {
                    current_statement_begin__ = 301;
                    int cond_prob_end(0);
                    (void) cond_prob_end;  // dummy to suppress unused var warning
                    stan::math::fill(cond_prob_end, std::numeric_limits<int>::min());
                    stan::math::assign(cond_prob_end,((cond_prob_pos + get_base1(num_compatible_discretized_r_types, discretized_type_index, "num_compatible_discretized_r_types", 1)) - 1));
                    current_statement_begin__ = 302;
                    validate_non_negative_index("compatible_ids", "get_base1(num_compatible_discretized_r_types, discretized_type_index, \"num_compatible_discretized_r_types\", 1)", get_base1(num_compatible_discretized_r_types, discretized_type_index, "num_compatible_discretized_r_types", 1));
                    std::vector<int  > compatible_ids(get_base1(num_compatible_discretized_r_types, discretized_type_index, "num_compatible_discretized_r_types", 1), int(0));
                    stan::math::fill(compatible_ids, std::numeric_limits<int>::min());
                    stan::math::assign(compatible_ids,stan::model::rvalue(compatible_discretized_r_types, stan::model::cons_list(stan::model::index_min_max(cond_prob_pos, cond_prob_end), stan::model::nil_index_list()), "compatible_discretized_r_types"));
                    current_statement_begin__ = 304;
                    stan::model::assign(curr_cond_discretized_log_prob, 
                                stan::model::cons_list(stan::model::index_min_max(cond_prob_pos, cond_prob_end), stan::model::nil_index_list()), 
                                log_softmax(stan::model::rvalue(stan::model::rvalue(beta, stan::model::cons_list(stan::model::index_uni(discretized_var_index), stan::model::cons_list(stan::model::index_min_max(discretized_pos, discretized_end), stan::model::cons_list(stan::model::index_uni(entity_index), stan::model::nil_index_list()))), "beta"), stan::model::cons_list(stan::model::index_multi(compatible_ids), stan::model::nil_index_list()), "beta[discretized_var_index, discretized_pos:discretized_end, entity_index]")), 
                                "assigning variable curr_cond_discretized_log_prob");
                    current_statement_begin__ = 306;
                    stan::math::assign(cond_prob_pos, (cond_prob_end + 1));
                    }
                }
                current_statement_begin__ = 309;
                stan::model::assign(joint_log_prob, 
                            stan::model::cons_list(stan::model::index_min_max(r_prob_pos, r_prob_end), stan::model::nil_index_list()), 
                            add(stan::model::rvalue(joint_log_prob, stan::model::cons_list(stan::model::index_min_max(r_prob_pos, r_prob_end), stan::model::nil_index_list()), "joint_log_prob"), stan::model::rvalue(curr_cond_discretized_log_prob, stan::model::cons_list(stan::model::index_multi(stan::model::rvalue(compatible_discretized_pair_ids, stan::model::cons_list(stan::model::index_uni(discretized_var_index), stan::model::cons_list(stan::model::index_min_max(discrete_group_pos, discrete_group_end), stan::model::nil_index_list())), "compatible_discretized_pair_ids")), stan::model::nil_index_list()), "curr_cond_discretized_log_prob")), 
                            "assigning variable joint_log_prob");
                }
            }
            }
        }
        current_statement_begin__ = 313;
        return stan::math::promote_scalar<fun_return_scalar_t__>(joint_log_prob);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct calculate_r_type_joint_log_prob_functor__ {
    template <typename T7__, typename T8__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T7__, T8__>::type, Eigen::Dynamic, 1>
    operator()(const int& num_r_types,
                                    const int& num_discrete_r_types,
                                    const int& num_discretized_r_types,
                                    const int& discrete_group_size,
                                    const std::vector<int>& num_compatible_discretized_r_types,
                                    const std::vector<int>& compatible_discretized_r_types,
                                    const std::vector<std::vector<int> >& compatible_discretized_pair_ids,
                                    const Eigen::Matrix<T7__, Eigen::Dynamic, 1>& discrete_log_prob,
                                    const std::vector<Eigen::Matrix<T8__, Eigen::Dynamic, Eigen::Dynamic> >& beta,
                                    const int& entity_index, std::ostream* pstream__) const {
        return calculate_r_type_joint_log_prob(num_r_types, num_discrete_r_types, num_discretized_r_types, discrete_group_size, num_compatible_discretized_r_types, compatible_discretized_r_types, compatible_discretized_pair_ids, discrete_log_prob, beta, entity_index, pstream__);
    }
};
template <typename T0__>
int
num_gt_zero(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& v, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 319;
        int num_found(0);
        (void) num_found;  // dummy to suppress unused var warning
        stan::math::fill(num_found, std::numeric_limits<int>::min());
        stan::math::assign(num_found,0);
        current_statement_begin__ = 321;
        for (int i = 1; i <= num_elements(v); ++i) {
            current_statement_begin__ = 322;
            if (as_bool(logical_gt(get_base1(v, i, "v", 1), 0))) {
                current_statement_begin__ = 323;
                stan::math::assign(num_found, (num_found + 1));
            }
        }
        current_statement_begin__ = 327;
        return stan::math::promote_scalar<fun_return_scalar_t__>(num_found);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct num_gt_zero_functor__ {
    template <typename T0__>
        int
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& v, std::ostream* pstream__) const {
        return num_gt_zero(v, pstream__);
    }
};
template <typename T0__>
std::vector<int>
which_compare_zero(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& v,
                       const int& num_found,
                       const int& gt, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 331;
        validate_non_negative_index("found_indices", "num_found", num_found);
        std::vector<int  > found_indices(num_found, int(0));
        stan::math::fill(found_indices, std::numeric_limits<int>::min());
        current_statement_begin__ = 332;
        int found_pos(0);
        (void) found_pos;  // dummy to suppress unused var warning
        stan::math::fill(found_pos, std::numeric_limits<int>::min());
        stan::math::assign(found_pos,1);
        current_statement_begin__ = 334;
        for (int i = 1; i <= num_elements(v); ++i) {
            current_statement_begin__ = 335;
            if (as_bool(((gt * logical_gt(get_base1(v, i, "v", 1), 0)) + ((1 - gt) * logical_lte(get_base1(v, i, "v", 1), 0))))) {
                current_statement_begin__ = 336;
                stan::model::assign(found_indices, 
                            stan::model::cons_list(stan::model::index_uni(found_pos), stan::model::nil_index_list()), 
                            i, 
                            "assigning variable found_indices");
                current_statement_begin__ = 337;
                stan::math::assign(found_pos, (found_pos + 1));
            }
        }
        current_statement_begin__ = 341;
        return stan::math::promote_scalar<fun_return_scalar_t__>(found_indices);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct which_compare_zero_functor__ {
    template <typename T0__>
        std::vector<int>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& v,
                       const int& num_found,
                       const int& gt, std::ostream* pstream__) const {
        return which_compare_zero(v, num_found, gt, pstream__);
    }
};
std::vector<int>
calculate_level_size(const int& num_levels,
                         const std::vector<std::vector<int> >& unique_entity_ids, std::ostream* pstream__) {
    typedef double local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 346;
        validate_non_negative_index("level_size", "num_levels", num_levels);
        std::vector<int  > level_size(num_levels, int(0));
        stan::math::fill(level_size, std::numeric_limits<int>::min());
        current_statement_begin__ = 348;
        for (int level_index = 1; level_index <= num_levels; ++level_index) {
            current_statement_begin__ = 349;
            stan::model::assign(level_size, 
                        stan::model::cons_list(stan::model::index_uni(level_index), stan::model::nil_index_list()), 
                        num_unique(stan::model::rvalue(unique_entity_ids, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(level_index), stan::model::nil_index_list())), "unique_entity_ids"), pstream__), 
                        "assigning variable level_size");
        }
        current_statement_begin__ = 352;
        return stan::math::promote_scalar<fun_return_scalar_t__>(level_size);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct calculate_level_size_functor__ {
            std::vector<int>
    operator()(const int& num_levels,
                         const std::vector<std::vector<int> >& unique_entity_ids, std::ostream* pstream__) const {
        return calculate_level_size(num_levels, unique_entity_ids, pstream__);
    }
};
std::vector<int>
calculate_num_in_level_entities(const std::vector<std::vector<int> >& unique_entity_ids,
                                    const std::vector<int>& level_size, std::ostream* pstream__) {
    typedef double local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 356;
        int num_levels(0);
        (void) num_levels;  // dummy to suppress unused var warning
        stan::math::fill(num_levels, std::numeric_limits<int>::min());
        stan::math::assign(num_levels,num_elements(level_size));
        current_statement_begin__ = 357;
        validate_non_negative_index("num_unique_entities_in_level_entities", "sum(level_size)", sum(level_size));
        std::vector<int  > num_unique_entities_in_level_entities(sum(level_size), int(0));
        stan::math::fill(num_unique_entities_in_level_entities, std::numeric_limits<int>::min());
        current_statement_begin__ = 359;
        int level_entity_pos(0);
        (void) level_entity_pos;  // dummy to suppress unused var warning
        stan::math::fill(level_entity_pos, std::numeric_limits<int>::min());
        stan::math::assign(level_entity_pos,1);
        current_statement_begin__ = 361;
        for (int level_index = 1; level_index <= num_levels; ++level_index) {
            {
            current_statement_begin__ = 362;
            int level_entity_end(0);
            (void) level_entity_end;  // dummy to suppress unused var warning
            stan::math::fill(level_entity_end, std::numeric_limits<int>::min());
            stan::math::assign(level_entity_end,((level_entity_pos + get_base1(level_size, level_index, "level_size", 1)) - 1));
            current_statement_begin__ = 364;
            stan::model::assign(num_unique_entities_in_level_entities, 
                        stan::model::cons_list(stan::model::index_min_max(level_entity_pos, level_entity_end), stan::model::nil_index_list()), 
                        count(get_base1(level_size, level_index, "level_size", 1), stan::model::rvalue(unique_entity_ids, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(level_index), stan::model::nil_index_list())), "unique_entity_ids"), pstream__), 
                        "assigning variable num_unique_entities_in_level_entities");
            current_statement_begin__ = 366;
            stan::math::assign(level_entity_pos, (level_entity_end + 1));
            }
        }
        current_statement_begin__ = 369;
        return stan::math::promote_scalar<fun_return_scalar_t__>(num_unique_entities_in_level_entities);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct calculate_num_in_level_entities_functor__ {
            std::vector<int>
    operator()(const std::vector<std::vector<int> >& unique_entity_ids,
                                    const std::vector<int>& level_size, std::ostream* pstream__) const {
        return calculate_num_in_level_entities(unique_entity_ids, level_size, pstream__);
    }
};
std::vector<int>
calculate_entity_total_num_candidates(const std::vector<int>& num_unique_entity_candidate_groups,
                                          const std::vector<int>& unique_entity_candidate_groups,
                                          const std::vector<int>& candidate_group_size, std::ostream* pstream__) {
    typedef double local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 373;
        int num_unique_entities(0);
        (void) num_unique_entities;  // dummy to suppress unused var warning
        stan::math::fill(num_unique_entities, std::numeric_limits<int>::min());
        stan::math::assign(num_unique_entities,num_elements(num_unique_entity_candidate_groups));
        current_statement_begin__ = 374;
        validate_non_negative_index("entity_total_num_candidates", "num_unique_entities", num_unique_entities);
        std::vector<int  > entity_total_num_candidates(num_unique_entities, int(0));
        stan::math::fill(entity_total_num_candidates, std::numeric_limits<int>::min());
        current_statement_begin__ = 376;
        int entity_candidate_group_pos(0);
        (void) entity_candidate_group_pos;  // dummy to suppress unused var warning
        stan::math::fill(entity_candidate_group_pos, std::numeric_limits<int>::min());
        stan::math::assign(entity_candidate_group_pos,1);
        current_statement_begin__ = 378;
        for (int entity_index = 1; entity_index <= num_unique_entities; ++entity_index) {
            {
            current_statement_begin__ = 379;
            int num_entity_candidate_groups(0);
            (void) num_entity_candidate_groups;  // dummy to suppress unused var warning
            stan::math::fill(num_entity_candidate_groups, std::numeric_limits<int>::min());
            stan::math::assign(num_entity_candidate_groups,get_base1(num_unique_entity_candidate_groups, entity_index, "num_unique_entity_candidate_groups", 1));
            current_statement_begin__ = 380;
            int entity_candidate_group_end(0);
            (void) entity_candidate_group_end;  // dummy to suppress unused var warning
            stan::math::fill(entity_candidate_group_end, std::numeric_limits<int>::min());
            stan::math::assign(entity_candidate_group_end,((entity_candidate_group_pos + num_entity_candidate_groups) - 1));
            current_statement_begin__ = 382;
            validate_non_negative_index("curr_candidate_groups", "num_entity_candidate_groups", num_entity_candidate_groups);
            std::vector<int  > curr_candidate_groups(num_entity_candidate_groups, int(0));
            stan::math::fill(curr_candidate_groups, std::numeric_limits<int>::min());
            stan::math::assign(curr_candidate_groups,stan::model::rvalue(unique_entity_candidate_groups, stan::model::cons_list(stan::model::index_min_max(entity_candidate_group_pos, entity_candidate_group_end), stan::model::nil_index_list()), "unique_entity_candidate_groups"));
            current_statement_begin__ = 384;
            stan::model::assign(entity_total_num_candidates, 
                        stan::model::cons_list(stan::model::index_uni(entity_index), stan::model::nil_index_list()), 
                        sum(stan::model::rvalue(candidate_group_size, stan::model::cons_list(stan::model::index_multi(curr_candidate_groups), stan::model::nil_index_list()), "candidate_group_size")), 
                        "assigning variable entity_total_num_candidates");
            current_statement_begin__ = 386;
            stan::math::assign(entity_candidate_group_pos, (entity_candidate_group_end + 1));
            }
        }
        current_statement_begin__ = 389;
        return stan::math::promote_scalar<fun_return_scalar_t__>(entity_total_num_candidates);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct calculate_entity_total_num_candidates_functor__ {
            std::vector<int>
    operator()(const std::vector<int>& num_unique_entity_candidate_groups,
                                          const std::vector<int>& unique_entity_candidate_groups,
                                          const std::vector<int>& candidate_group_size, std::ostream* pstream__) const {
        return calculate_entity_total_num_candidates(num_unique_entity_candidate_groups, unique_entity_candidate_groups, candidate_group_size, pstream__);
    }
};
template <typename T0__, typename T4__, class RNG>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T4__>::type, Eigen::Dynamic, Eigen::Dynamic>
rep_corr_estimand_rng(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& r_prob_mat,
                          const std::vector<int>& rep_corr_outcomes,
                          const std::vector<int>& rep_corr_cond,
                          const std::vector<std::vector<int> >& experiment_assign_entity,
                          const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic, Eigen::Dynamic> >& type_response_value, RNG& base_rng__, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T4__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 393;
        int num_r_types(0);
        (void) num_r_types;  // dummy to suppress unused var warning
        stan::math::fill(num_r_types, std::numeric_limits<int>::min());
        stan::math::assign(num_r_types,rows(r_prob_mat));
        current_statement_begin__ = 394;
        int num_rep_corr_estimands(0);
        (void) num_rep_corr_estimands;  // dummy to suppress unused var warning
        stan::math::fill(num_rep_corr_estimands, std::numeric_limits<int>::min());
        stan::math::assign(num_rep_corr_estimands,divide(num_elements(rep_corr_outcomes), 2));
        current_statement_begin__ = 395;
        int num_experiment_entities(0);
        (void) num_experiment_entities;  // dummy to suppress unused var warning
        stan::math::fill(num_experiment_entities, std::numeric_limits<int>::min());
        stan::math::assign(num_experiment_entities,size(experiment_assign_entity));
        current_statement_begin__ = 397;
        validate_non_negative_index("rep_corr_estimand", "num_rep_corr_estimands", num_rep_corr_estimands);
        validate_non_negative_index("rep_corr_estimand", "2", 2);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> rep_corr_estimand(num_rep_corr_estimands, 2);
        stan::math::initialize(rep_corr_estimand, DUMMY_VAR__);
        stan::math::fill(rep_corr_estimand, DUMMY_VAR__);
        current_statement_begin__ = 401;
        validate_non_negative_index("rep_outcome_n", "num_rep_corr_estimands", num_rep_corr_estimands);
        validate_non_negative_index("rep_outcome_n", "2", 2);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> rep_outcome_n(num_rep_corr_estimands, 2);
        stan::math::initialize(rep_outcome_n, DUMMY_VAR__);
        stan::math::fill(rep_outcome_n, DUMMY_VAR__);
        stan::math::assign(rep_outcome_n,rep_matrix(0, num_rep_corr_estimands, 2));
        current_statement_begin__ = 402;
        validate_non_negative_index("rep_outcome_product_sum", "num_rep_corr_estimands", num_rep_corr_estimands);
        validate_non_negative_index("rep_outcome_product_sum", "2", 2);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> rep_outcome_product_sum(num_rep_corr_estimands, 2);
        stan::math::initialize(rep_outcome_product_sum, DUMMY_VAR__);
        stan::math::fill(rep_outcome_product_sum, DUMMY_VAR__);
        stan::math::assign(rep_outcome_product_sum,rep_matrix(0, num_rep_corr_estimands, 2));
        current_statement_begin__ = 403;
        validate_non_negative_index("rep_outcome1_sum", "num_rep_corr_estimands", num_rep_corr_estimands);
        validate_non_negative_index("rep_outcome1_sum", "2", 2);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> rep_outcome1_sum(num_rep_corr_estimands, 2);
        stan::math::initialize(rep_outcome1_sum, DUMMY_VAR__);
        stan::math::fill(rep_outcome1_sum, DUMMY_VAR__);
        stan::math::assign(rep_outcome1_sum,rep_matrix(0, num_rep_corr_estimands, 2));
        current_statement_begin__ = 404;
        validate_non_negative_index("rep_outcome2_sum", "num_rep_corr_estimands", num_rep_corr_estimands);
        validate_non_negative_index("rep_outcome2_sum", "2", 2);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> rep_outcome2_sum(num_rep_corr_estimands, 2);
        stan::math::initialize(rep_outcome2_sum, DUMMY_VAR__);
        stan::math::fill(rep_outcome2_sum, DUMMY_VAR__);
        stan::math::assign(rep_outcome2_sum,rep_matrix(0, num_rep_corr_estimands, 2));
        current_statement_begin__ = 405;
        validate_non_negative_index("rep_outcome1_squared_sum", "num_rep_corr_estimands", num_rep_corr_estimands);
        validate_non_negative_index("rep_outcome1_squared_sum", "2", 2);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> rep_outcome1_squared_sum(num_rep_corr_estimands, 2);
        stan::math::initialize(rep_outcome1_squared_sum, DUMMY_VAR__);
        stan::math::fill(rep_outcome1_squared_sum, DUMMY_VAR__);
        stan::math::assign(rep_outcome1_squared_sum,rep_matrix(0, num_rep_corr_estimands, 2));
        current_statement_begin__ = 406;
        validate_non_negative_index("rep_outcome2_squared_sum", "num_rep_corr_estimands", num_rep_corr_estimands);
        validate_non_negative_index("rep_outcome2_squared_sum", "2", 2);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> rep_outcome2_squared_sum(num_rep_corr_estimands, 2);
        stan::math::initialize(rep_outcome2_squared_sum, DUMMY_VAR__);
        stan::math::fill(rep_outcome2_squared_sum, DUMMY_VAR__);
        stan::math::assign(rep_outcome2_squared_sum,rep_matrix(0, num_rep_corr_estimands, 2));
        current_statement_begin__ = 408;
        for (int entity_exp_index = 1; entity_exp_index <= num_experiment_entities; ++entity_exp_index) {
            {
            current_statement_begin__ = 409;
            int entity_exp_id(0);
            (void) entity_exp_id;  // dummy to suppress unused var warning
            stan::math::fill(entity_exp_id, std::numeric_limits<int>::min());
            stan::math::assign(entity_exp_id,get_base1(get_base1(experiment_assign_entity, entity_exp_index, "experiment_assign_entity", 1), 2, "experiment_assign_entity", 2));
            current_statement_begin__ = 410;
            int entity_exp_size(0);
            (void) entity_exp_size;  // dummy to suppress unused var warning
            stan::math::fill(entity_exp_size, std::numeric_limits<int>::min());
            stan::math::assign(entity_exp_size,get_base1(get_base1(experiment_assign_entity, entity_exp_index, "experiment_assign_entity", 1), 3, "experiment_assign_entity", 2));
            current_statement_begin__ = 412;
            validate_non_negative_index("rep_sample_types", "num_r_types", num_r_types);
            Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> rep_sample_types(num_r_types);
            stan::math::initialize(rep_sample_types, DUMMY_VAR__);
            stan::math::fill(rep_sample_types, DUMMY_VAR__);
            stan::math::assign(rep_sample_types,to_vector(multinomial_rng(stan::model::rvalue(r_prob_mat, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(experiment_assign_entity, entity_exp_index, "experiment_assign_entity", 1), 1, "experiment_assign_entity", 2)), stan::model::nil_index_list())), "r_prob_mat"), entity_exp_size, base_rng__)));
            current_statement_begin__ = 414;
            for (int rep_corr_index = 1; rep_corr_index <= num_rep_corr_estimands; ++rep_corr_index) {
                {
                current_statement_begin__ = 415;
                int rep_corr_pos(0);
                (void) rep_corr_pos;  // dummy to suppress unused var warning
                stan::math::fill(rep_corr_pos, std::numeric_limits<int>::min());
                stan::math::assign(rep_corr_pos,((2 * (rep_corr_index - 1)) + 1));
                current_statement_begin__ = 416;
                validate_non_negative_index("outcome_id", "2", 2);
                std::vector<int  > outcome_id(2, int(0));
                stan::math::fill(outcome_id, std::numeric_limits<int>::min());
                stan::math::assign(outcome_id,stan::model::rvalue(rep_corr_outcomes, stan::model::cons_list(stan::model::index_min_max(rep_corr_pos, (rep_corr_pos + 1)), stan::model::nil_index_list()), "rep_corr_outcomes"));
                current_statement_begin__ = 418;
                validate_non_negative_index("outcome1", "num_r_types", num_r_types);
                Eigen::Matrix<local_scalar_t__, 1, Eigen::Dynamic> outcome1(num_r_types);
                stan::math::initialize(outcome1, DUMMY_VAR__);
                stan::math::fill(outcome1, DUMMY_VAR__);
                stan::math::assign(outcome1,get_base1(get_base1(type_response_value, get_base1(outcome_id, 1, "outcome_id", 1), "type_response_value", 1), entity_exp_id, "type_response_value", 2));
                current_statement_begin__ = 419;
                validate_non_negative_index("outcome2", "num_r_types", num_r_types);
                Eigen::Matrix<local_scalar_t__, 1, Eigen::Dynamic> outcome2(num_r_types);
                stan::math::initialize(outcome2, DUMMY_VAR__);
                stan::math::fill(outcome2, DUMMY_VAR__);
                stan::math::assign(outcome2,get_base1(get_base1(type_response_value, get_base1(outcome_id, 2, "outcome_id", 1), "type_response_value", 1), entity_exp_id, "type_response_value", 2));
                current_statement_begin__ = 420;
                validate_non_negative_index("cond", "num_r_types", num_r_types);
                Eigen::Matrix<local_scalar_t__, 1, Eigen::Dynamic> cond(num_r_types);
                stan::math::initialize(cond, DUMMY_VAR__);
                stan::math::fill(cond, DUMMY_VAR__);
                stan::math::assign(cond,get_base1(get_base1(type_response_value, get_base1(rep_corr_cond, rep_corr_index, "rep_corr_cond", 1), "type_response_value", 1), entity_exp_id, "type_response_value", 2));
                current_statement_begin__ = 422;
                stan::model::assign(rep_outcome_n, 
                            stan::model::cons_list(stan::model::index_uni(rep_corr_index), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), 
                            (stan::model::rvalue(rep_outcome_n, stan::model::cons_list(stan::model::index_uni(rep_corr_index), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), "rep_outcome_n") + multiply(subtract(1, cond), rep_sample_types)), 
                            "assigning variable rep_outcome_n");
                current_statement_begin__ = 423;
                stan::model::assign(rep_outcome_n, 
                            stan::model::cons_list(stan::model::index_uni(rep_corr_index), stan::model::cons_list(stan::model::index_uni(2), stan::model::nil_index_list())), 
                            (stan::model::rvalue(rep_outcome_n, stan::model::cons_list(stan::model::index_uni(rep_corr_index), stan::model::cons_list(stan::model::index_uni(2), stan::model::nil_index_list())), "rep_outcome_n") + multiply(cond, rep_sample_types)), 
                            "assigning variable rep_outcome_n");
                current_statement_begin__ = 425;
                stan::model::assign(rep_outcome_product_sum, 
                            stan::model::cons_list(stan::model::index_uni(rep_corr_index), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), 
                            (stan::model::rvalue(rep_outcome_product_sum, stan::model::cons_list(stan::model::index_uni(rep_corr_index), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), "rep_outcome_product_sum") + multiply(elt_multiply(elt_multiply(outcome1, outcome2), subtract(1, cond)), rep_sample_types)), 
                            "assigning variable rep_outcome_product_sum");
                current_statement_begin__ = 426;
                stan::model::assign(rep_outcome_product_sum, 
                            stan::model::cons_list(stan::model::index_uni(rep_corr_index), stan::model::cons_list(stan::model::index_uni(2), stan::model::nil_index_list())), 
                            (stan::model::rvalue(rep_outcome_product_sum, stan::model::cons_list(stan::model::index_uni(rep_corr_index), stan::model::cons_list(stan::model::index_uni(2), stan::model::nil_index_list())), "rep_outcome_product_sum") + multiply(elt_multiply(elt_multiply(outcome1, outcome2), cond), rep_sample_types)), 
                            "assigning variable rep_outcome_product_sum");
                current_statement_begin__ = 428;
                stan::model::assign(rep_outcome1_sum, 
                            stan::model::cons_list(stan::model::index_uni(rep_corr_index), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), 
                            (stan::model::rvalue(rep_outcome1_sum, stan::model::cons_list(stan::model::index_uni(rep_corr_index), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), "rep_outcome1_sum") + multiply(elt_multiply(outcome1, subtract(1, cond)), rep_sample_types)), 
                            "assigning variable rep_outcome1_sum");
                current_statement_begin__ = 429;
                stan::model::assign(rep_outcome1_sum, 
                            stan::model::cons_list(stan::model::index_uni(rep_corr_index), stan::model::cons_list(stan::model::index_uni(2), stan::model::nil_index_list())), 
                            (stan::model::rvalue(rep_outcome1_sum, stan::model::cons_list(stan::model::index_uni(rep_corr_index), stan::model::cons_list(stan::model::index_uni(2), stan::model::nil_index_list())), "rep_outcome1_sum") + multiply(elt_multiply(outcome1, cond), rep_sample_types)), 
                            "assigning variable rep_outcome1_sum");
                current_statement_begin__ = 431;
                stan::model::assign(rep_outcome2_sum, 
                            stan::model::cons_list(stan::model::index_uni(rep_corr_index), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), 
                            (stan::model::rvalue(rep_outcome2_sum, stan::model::cons_list(stan::model::index_uni(rep_corr_index), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), "rep_outcome2_sum") + multiply(elt_multiply(outcome2, subtract(1, cond)), rep_sample_types)), 
                            "assigning variable rep_outcome2_sum");
                current_statement_begin__ = 432;
                stan::model::assign(rep_outcome2_sum, 
                            stan::model::cons_list(stan::model::index_uni(rep_corr_index), stan::model::cons_list(stan::model::index_uni(2), stan::model::nil_index_list())), 
                            (stan::model::rvalue(rep_outcome2_sum, stan::model::cons_list(stan::model::index_uni(rep_corr_index), stan::model::cons_list(stan::model::index_uni(2), stan::model::nil_index_list())), "rep_outcome2_sum") + multiply(elt_multiply(outcome2, cond), rep_sample_types)), 
                            "assigning variable rep_outcome2_sum");
                current_statement_begin__ = 434;
                stan::model::assign(rep_outcome1_squared_sum, 
                            stan::model::cons_list(stan::model::index_uni(rep_corr_index), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), 
                            (stan::model::rvalue(rep_outcome1_squared_sum, stan::model::cons_list(stan::model::index_uni(rep_corr_index), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), "rep_outcome1_squared_sum") + multiply(square(elt_multiply(outcome1, subtract(1, cond))), rep_sample_types)), 
                            "assigning variable rep_outcome1_squared_sum");
                current_statement_begin__ = 435;
                stan::model::assign(rep_outcome1_squared_sum, 
                            stan::model::cons_list(stan::model::index_uni(rep_corr_index), stan::model::cons_list(stan::model::index_uni(2), stan::model::nil_index_list())), 
                            (stan::model::rvalue(rep_outcome1_squared_sum, stan::model::cons_list(stan::model::index_uni(rep_corr_index), stan::model::cons_list(stan::model::index_uni(2), stan::model::nil_index_list())), "rep_outcome1_squared_sum") + multiply(square(elt_multiply(outcome1, cond)), rep_sample_types)), 
                            "assigning variable rep_outcome1_squared_sum");
                current_statement_begin__ = 437;
                stan::model::assign(rep_outcome2_squared_sum, 
                            stan::model::cons_list(stan::model::index_uni(rep_corr_index), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), 
                            (stan::model::rvalue(rep_outcome2_squared_sum, stan::model::cons_list(stan::model::index_uni(rep_corr_index), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), "rep_outcome2_squared_sum") + multiply(square(elt_multiply(outcome2, subtract(1, cond))), rep_sample_types)), 
                            "assigning variable rep_outcome2_squared_sum");
                current_statement_begin__ = 438;
                stan::model::assign(rep_outcome2_squared_sum, 
                            stan::model::cons_list(stan::model::index_uni(rep_corr_index), stan::model::cons_list(stan::model::index_uni(2), stan::model::nil_index_list())), 
                            (stan::model::rvalue(rep_outcome2_squared_sum, stan::model::cons_list(stan::model::index_uni(rep_corr_index), stan::model::cons_list(stan::model::index_uni(2), stan::model::nil_index_list())), "rep_outcome2_squared_sum") + multiply(square(elt_multiply(outcome2, cond)), rep_sample_types)), 
                            "assigning variable rep_outcome2_squared_sum");
                }
            }
            }
        }
        current_statement_begin__ = 442;
        for (int rep_corr_index = 1; rep_corr_index <= num_rep_corr_estimands; ++rep_corr_index) {
            current_statement_begin__ = 443;
            stan::model::assign(rep_corr_estimand, 
                        stan::model::cons_list(stan::model::index_uni(rep_corr_index), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), 
                        (((get_base1(rep_outcome_n, rep_corr_index, 1, "rep_outcome_n", 1) * get_base1(rep_outcome_product_sum, rep_corr_index, 1, "rep_outcome_product_sum", 1)) - (get_base1(rep_outcome1_sum, rep_corr_index, 1, "rep_outcome1_sum", 1) * get_base1(rep_outcome2_sum, rep_corr_index, 1, "rep_outcome2_sum", 1))) / (stan::math::sqrt(((get_base1(rep_outcome_n, rep_corr_index, 1, "rep_outcome_n", 1) * get_base1(rep_outcome1_squared_sum, rep_corr_index, 1, "rep_outcome1_squared_sum", 1)) - square(get_base1(rep_outcome1_sum, rep_corr_index, 1, "rep_outcome1_sum", 1)))) * stan::math::sqrt(((get_base1(rep_outcome_n, rep_corr_index, 1, "rep_outcome_n", 1) * get_base1(rep_outcome2_squared_sum, rep_corr_index, 1, "rep_outcome2_squared_sum", 1)) - square(get_base1(rep_outcome2_sum, rep_corr_index, 1, "rep_outcome2_sum", 1)))))), 
                        "assigning variable rep_corr_estimand");
            current_statement_begin__ = 448;
            if (as_bool(is_nan(get_base1(rep_corr_estimand, rep_corr_index, 1, "rep_corr_estimand", 1)))) {
                current_statement_begin__ = 449;
                stan::model::assign(rep_corr_estimand, 
                            stan::model::cons_list(stan::model::index_uni(rep_corr_index), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), 
                            0, 
                            "assigning variable rep_corr_estimand");
            }
            current_statement_begin__ = 452;
            stan::model::assign(rep_corr_estimand, 
                        stan::model::cons_list(stan::model::index_uni(rep_corr_index), stan::model::cons_list(stan::model::index_uni(2), stan::model::nil_index_list())), 
                        (((get_base1(rep_outcome_n, rep_corr_index, 2, "rep_outcome_n", 1) * get_base1(rep_outcome_product_sum, rep_corr_index, 2, "rep_outcome_product_sum", 1)) - (get_base1(rep_outcome1_sum, rep_corr_index, 2, "rep_outcome1_sum", 1) * get_base1(rep_outcome2_sum, rep_corr_index, 2, "rep_outcome2_sum", 1))) / (stan::math::sqrt(((get_base1(rep_outcome_n, rep_corr_index, 2, "rep_outcome_n", 1) * get_base1(rep_outcome1_squared_sum, rep_corr_index, 2, "rep_outcome1_squared_sum", 1)) - square(get_base1(rep_outcome1_sum, rep_corr_index, 2, "rep_outcome1_sum", 1)))) * stan::math::sqrt(((get_base1(rep_outcome_n, rep_corr_index, 2, "rep_outcome_n", 1) * get_base1(rep_outcome2_squared_sum, rep_corr_index, 2, "rep_outcome2_squared_sum", 1)) - square(get_base1(rep_outcome2_sum, rep_corr_index, 2, "rep_outcome2_sum", 1)))))), 
                        "assigning variable rep_corr_estimand");
            current_statement_begin__ = 457;
            if (as_bool(is_nan(get_base1(rep_corr_estimand, rep_corr_index, 2, "rep_corr_estimand", 1)))) {
                current_statement_begin__ = 458;
                stan::model::assign(rep_corr_estimand, 
                            stan::model::cons_list(stan::model::index_uni(rep_corr_index), stan::model::cons_list(stan::model::index_uni(2), stan::model::nil_index_list())), 
                            0, 
                            "assigning variable rep_corr_estimand");
            }
        }
        current_statement_begin__ = 462;
        return stan::math::promote_scalar<fun_return_scalar_t__>(rep_corr_estimand);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct rep_corr_estimand_rng_functor__ {
    template <typename T0__, typename T4__, class RNG>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T4__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& r_prob_mat,
                          const std::vector<int>& rep_corr_outcomes,
                          const std::vector<int>& rep_corr_cond,
                          const std::vector<std::vector<int> >& experiment_assign_entity,
                          const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic, Eigen::Dynamic> >& type_response_value, RNG& base_rng__, std::ostream* pstream__) const {
        return rep_corr_estimand_rng(r_prob_mat, rep_corr_outcomes, rep_corr_cond, experiment_assign_entity, type_response_value, base_rng__, pstream__);
    }
};
#include <stan_meta_header.hpp>
class model_bounded : public prob_grad {
private:
        int num_obs;
        int num_r_types;
        int num_discrete_r_types;
        std::vector<int> discrete_r_type_id;
        int num_cutpoints;
        vector_d cutpoints;
        int num_discretized_r_types;
        std::vector<int> num_compatible_discretized_r_types;
        std::vector<int> compatible_discretized_r_types;
        std::vector<std::vector<int> > compatible_discretized_pair_ids;
        int num_experiment_types;
        vector_d experiment_types_prob;
        int num_responses;
        int num_bg_variables;
        std::vector<int> num_bg_variable_types;
        std::vector<int> num_bg_variable_type_combo_members;
        std::vector<int> bg_variable_type_combo_members;
        int num_levels;
        int num_unique_entities;
        std::vector<std::vector<int> > unique_entity_ids;
        std::vector<int> obs_unique_entity_id;
        int num_candidate_groups;
        std::vector<int> candidate_group_size;
        std::vector<int> candidate_group_ids;
        std::vector<int> num_unique_entity_candidate_groups;
        std::vector<int> unique_entity_candidate_groups;
        row_vector_d num_unique_entity_in_candidate_groups;
        std::vector<int> obs_candidate_group;
        std::vector<int> obs_in_unique_entity_in_candidate_groups;
        int num_discrete_estimands;
        int num_atom_estimands;
        int num_diff_estimands;
        int num_discretized_groups;
        int num_mean_diff_estimands;
        int num_utility_diff_estimands;
        std::vector<int> diff_estimand_atoms;
        std::vector<int> mean_diff_estimand_atoms;
        std::vector<int> utility_diff_estimand_atoms;
        std::vector<int> discretized_group_ids;
        int num_abducted_estimands;
        std::vector<int> abducted_estimand_ids;
        int num_estimand_levels;
        std::vector<int> estimand_levels;
        int num_between_entity_diff_levels;
        std::vector<int> between_entity_diff_levels;
        std::vector<int> abducted_prob_size;
        std::vector<int> abducted_prob_index;
        std::vector<int> est_prob_size;
        std::vector<int> est_prob_index;
        int num_discrete_utility_values;
        vector_d utility;
        int log_lik_level;
        double discrete_beta_hyper_sd;
        double discretized_beta_hyper_sd;
        vector_d tau_level_sigma;
        int run_type;
        int use_random_binpoint;
        int generate_rep;
        int calculate_marginal_prob;
        int RUN_TYPE_PRIOR_PREDICT;
        int RUN_TYPE_FIT;
        int num_all_estimands;
        int num_discretized_variables;
        int discrete_group_size;
        vector_d cutpoint_midpoints;
        vector_d discretized_binwidth;
        std::vector<double> discretize_bin_alpha;
        std::vector<double> discretize_bin_beta;
        std::vector<double> entity_discretize_bin_alpha;
        std::vector<double> entity_discretize_bin_beta;
        int num_r_types_full;
        std::vector<int> experiment_r_type_index;
        vector_d full_experiment_types_prob;
        std::vector<int> level_size;
        vector_d num_obs_in_unique_entity;
        vector_d unique_entity_prop;
        std::vector<int> num_unique_entities_in_estimand_level_entities;
        std::vector<std::vector<int> > unique_entities_in_level_entities;
        vector_d vec_diff;
        vector_d vec_mean_diff;
        vector_d vec_utility_diff;
        int vec_1_size;
        vector_d vec_1;
        std::vector<int> entity_total_num_candidates;
        std::vector<int> entity_candidate_group_ids;
        std::vector<int> entity_candidate_group_csr_row_pos;
        std::vector<int> obs_candidate_group_ids;
        std::vector<int> obs_candidate_group_csr_row_pos;
        std::vector<int> entity_abducted_prob_ids;
        std::vector<int> entity_abducted_prob_csr_row_pos;
        std::vector<int> long_entity_abducted_index;
        std::vector<int> entity_est_prob_ids;
        std::vector<int> entity_est_prob_csr_row_pos;
        std::vector<int> entity_diff_estimand_ids;
        std::vector<int> entity_diff_estimand_csr_row_pos;
        std::vector<int> entity_mean_diff_estimand_ids;
        std::vector<int> entity_mean_diff_estimand_csr_row_pos;
        std::vector<int> entity_utility_diff_estimand_ids;
        std::vector<int> entity_utility_diff_estimand_csr_row_pos;
        int total_num_bg_variable_types;
        vector_d marginal_prob_csr_vec;
        std::vector<int> entity_marginal_prob_ids;
        std::vector<int> entity_marginal_prob_csr_row_pos;
        vector_d level_estimands_csr_vec;
        std::vector<int> entity_estimand_ids;
        std::vector<int> entity_estimand_csr_row_pos;
        vector_d entity_histogram_vec;
        std::vector<int> entity_histogram_ids;
        std::vector<int> entity_histogram_csr_row_pos;
        vector_d entity_midpoint_vec;
        std::vector<int> entity_midpoint_ids;
        std::vector<int> entity_midpoint_csr_row_pos;
        vector_d entity_utility_vec;
        vector_d between_entity_diff_csr_vec;
        std::vector<int> between_entity_diff_csr_ids;
        std::vector<int> between_entity_diff_csr_row_pos;
        std::vector<int> nonzero_beta_offsets;
public:
    model_bounded(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }
    model_bounded(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }
    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        typedef double local_scalar_t__;
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning
        current_statement_begin__ = -1;
        static const char* function__ = "model_bounded_namespace::model_bounded";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
        try {
            // initialize data block variables from context__
            current_statement_begin__ = 467;
            context__.validate_dims("data initialization", "num_obs", "int", context__.to_vec());
            num_obs = int(0);
            vals_i__ = context__.vals_i("num_obs");
            pos__ = 0;
            num_obs = vals_i__[pos__++];
            check_greater_or_equal(function__, "num_obs", num_obs, 0);
            current_statement_begin__ = 469;
            context__.validate_dims("data initialization", "num_r_types", "int", context__.to_vec());
            num_r_types = int(0);
            vals_i__ = context__.vals_i("num_r_types");
            pos__ = 0;
            num_r_types = vals_i__[pos__++];
            check_greater_or_equal(function__, "num_r_types", num_r_types, 1);
            current_statement_begin__ = 470;
            context__.validate_dims("data initialization", "num_discrete_r_types", "int", context__.to_vec());
            num_discrete_r_types = int(0);
            vals_i__ = context__.vals_i("num_discrete_r_types");
            pos__ = 0;
            num_discrete_r_types = vals_i__[pos__++];
            check_greater_or_equal(function__, "num_discrete_r_types", num_discrete_r_types, 1);
            current_statement_begin__ = 471;
            validate_non_negative_index("discrete_r_type_id", "num_r_types", num_r_types);
            context__.validate_dims("data initialization", "discrete_r_type_id", "int", context__.to_vec(num_r_types));
            discrete_r_type_id = std::vector<int>(num_r_types, int(0));
            vals_i__ = context__.vals_i("discrete_r_type_id");
            pos__ = 0;
            size_t discrete_r_type_id_k_0_max__ = num_r_types;
            for (size_t k_0__ = 0; k_0__ < discrete_r_type_id_k_0_max__; ++k_0__) {
                discrete_r_type_id[k_0__] = vals_i__[pos__++];
            }
            size_t discrete_r_type_id_i_0_max__ = num_r_types;
            for (size_t i_0__ = 0; i_0__ < discrete_r_type_id_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "discrete_r_type_id[i_0__]", discrete_r_type_id[i_0__], 1);
                check_less_or_equal(function__, "discrete_r_type_id[i_0__]", discrete_r_type_id[i_0__], num_discrete_r_types);
            }
            current_statement_begin__ = 475;
            context__.validate_dims("data initialization", "num_cutpoints", "int", context__.to_vec());
            num_cutpoints = int(0);
            vals_i__ = context__.vals_i("num_cutpoints");
            pos__ = 0;
            num_cutpoints = vals_i__[pos__++];
            check_greater_or_equal(function__, "num_cutpoints", num_cutpoints, 0);
            current_statement_begin__ = 476;
            validate_non_negative_index("cutpoints", "num_cutpoints", num_cutpoints);
            context__.validate_dims("data initialization", "cutpoints", "vector_d", context__.to_vec(num_cutpoints));
            cutpoints = Eigen::Matrix<double, Eigen::Dynamic, 1>(num_cutpoints);
            vals_r__ = context__.vals_r("cutpoints");
            pos__ = 0;
            size_t cutpoints_j_1_max__ = num_cutpoints;
            for (size_t j_1__ = 0; j_1__ < cutpoints_j_1_max__; ++j_1__) {
                cutpoints(j_1__) = vals_r__[pos__++];
            }
            current_statement_begin__ = 478;
            context__.validate_dims("data initialization", "num_discretized_r_types", "int", context__.to_vec());
            num_discretized_r_types = int(0);
            vals_i__ = context__.vals_i("num_discretized_r_types");
            pos__ = 0;
            num_discretized_r_types = vals_i__[pos__++];
            check_greater_or_equal(function__, "num_discretized_r_types", num_discretized_r_types, 0);
            current_statement_begin__ = 479;
            validate_non_negative_index("num_compatible_discretized_r_types", "num_discretized_r_types", num_discretized_r_types);
            context__.validate_dims("data initialization", "num_compatible_discretized_r_types", "int", context__.to_vec(num_discretized_r_types));
            num_compatible_discretized_r_types = std::vector<int>(num_discretized_r_types, int(0));
            vals_i__ = context__.vals_i("num_compatible_discretized_r_types");
            pos__ = 0;
            size_t num_compatible_discretized_r_types_k_0_max__ = num_discretized_r_types;
            for (size_t k_0__ = 0; k_0__ < num_compatible_discretized_r_types_k_0_max__; ++k_0__) {
                num_compatible_discretized_r_types[k_0__] = vals_i__[pos__++];
            }
            size_t num_compatible_discretized_r_types_i_0_max__ = num_discretized_r_types;
            for (size_t i_0__ = 0; i_0__ < num_compatible_discretized_r_types_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "num_compatible_discretized_r_types[i_0__]", num_compatible_discretized_r_types[i_0__], 1);
                check_less_or_equal(function__, "num_compatible_discretized_r_types[i_0__]", num_compatible_discretized_r_types[i_0__], num_discretized_r_types);
            }
            current_statement_begin__ = 480;
            validate_non_negative_index("compatible_discretized_r_types", "sum(num_compatible_discretized_r_types)", sum(num_compatible_discretized_r_types));
            context__.validate_dims("data initialization", "compatible_discretized_r_types", "int", context__.to_vec(sum(num_compatible_discretized_r_types)));
            compatible_discretized_r_types = std::vector<int>(sum(num_compatible_discretized_r_types), int(0));
            vals_i__ = context__.vals_i("compatible_discretized_r_types");
            pos__ = 0;
            size_t compatible_discretized_r_types_k_0_max__ = sum(num_compatible_discretized_r_types);
            for (size_t k_0__ = 0; k_0__ < compatible_discretized_r_types_k_0_max__; ++k_0__) {
                compatible_discretized_r_types[k_0__] = vals_i__[pos__++];
            }
            size_t compatible_discretized_r_types_i_0_max__ = sum(num_compatible_discretized_r_types);
            for (size_t i_0__ = 0; i_0__ < compatible_discretized_r_types_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "compatible_discretized_r_types[i_0__]", compatible_discretized_r_types[i_0__], 1);
                check_less_or_equal(function__, "compatible_discretized_r_types[i_0__]", compatible_discretized_r_types[i_0__], num_discretized_r_types);
            }
            current_statement_begin__ = 482;
            validate_non_negative_index("compatible_discretized_pair_ids", "std::max(0, (num_cutpoints - 2))", std::max(0, (num_cutpoints - 2)));
            validate_non_negative_index("compatible_discretized_pair_ids", "num_r_types", num_r_types);
            context__.validate_dims("data initialization", "compatible_discretized_pair_ids", "int", context__.to_vec(std::max(0, (num_cutpoints - 2)),num_r_types));
            compatible_discretized_pair_ids = std::vector<std::vector<int> >(std::max(0, (num_cutpoints - 2)), std::vector<int>(num_r_types, int(0)));
            vals_i__ = context__.vals_i("compatible_discretized_pair_ids");
            pos__ = 0;
            size_t compatible_discretized_pair_ids_k_0_max__ = std::max(0, (num_cutpoints - 2));
            size_t compatible_discretized_pair_ids_k_1_max__ = num_r_types;
            for (size_t k_1__ = 0; k_1__ < compatible_discretized_pair_ids_k_1_max__; ++k_1__) {
                for (size_t k_0__ = 0; k_0__ < compatible_discretized_pair_ids_k_0_max__; ++k_0__) {
                    compatible_discretized_pair_ids[k_0__][k_1__] = vals_i__[pos__++];
                }
            }
            size_t compatible_discretized_pair_ids_i_0_max__ = std::max(0, (num_cutpoints - 2));
            size_t compatible_discretized_pair_ids_i_1_max__ = num_r_types;
            for (size_t i_0__ = 0; i_0__ < compatible_discretized_pair_ids_i_0_max__; ++i_0__) {
                for (size_t i_1__ = 0; i_1__ < compatible_discretized_pair_ids_i_1_max__; ++i_1__) {
                    check_greater_or_equal(function__, "compatible_discretized_pair_ids[i_0__][i_1__]", compatible_discretized_pair_ids[i_0__][i_1__], 1);
                    check_less_or_equal(function__, "compatible_discretized_pair_ids[i_0__][i_1__]", compatible_discretized_pair_ids[i_0__][i_1__], sum(num_compatible_discretized_r_types));
                }
            }
            current_statement_begin__ = 486;
            context__.validate_dims("data initialization", "num_experiment_types", "int", context__.to_vec());
            num_experiment_types = int(0);
            vals_i__ = context__.vals_i("num_experiment_types");
            pos__ = 0;
            num_experiment_types = vals_i__[pos__++];
            check_greater_or_equal(function__, "num_experiment_types", num_experiment_types, 1);
            current_statement_begin__ = 487;
            validate_non_negative_index("experiment_types_prob", "num_experiment_types", num_experiment_types);
            context__.validate_dims("data initialization", "experiment_types_prob", "vector_d", context__.to_vec(num_experiment_types));
            experiment_types_prob = Eigen::Matrix<double, Eigen::Dynamic, 1>(num_experiment_types);
            vals_r__ = context__.vals_r("experiment_types_prob");
            pos__ = 0;
            size_t experiment_types_prob_j_1_max__ = num_experiment_types;
            for (size_t j_1__ = 0; j_1__ < experiment_types_prob_j_1_max__; ++j_1__) {
                experiment_types_prob(j_1__) = vals_r__[pos__++];
            }
            stan::math::check_simplex(function__, "experiment_types_prob", experiment_types_prob);
            current_statement_begin__ = 491;
            context__.validate_dims("data initialization", "num_responses", "int", context__.to_vec());
            num_responses = int(0);
            vals_i__ = context__.vals_i("num_responses");
            pos__ = 0;
            num_responses = vals_i__[pos__++];
            check_greater_or_equal(function__, "num_responses", num_responses, 1);
            current_statement_begin__ = 496;
            context__.validate_dims("data initialization", "num_bg_variables", "int", context__.to_vec());
            num_bg_variables = int(0);
            vals_i__ = context__.vals_i("num_bg_variables");
            pos__ = 0;
            num_bg_variables = vals_i__[pos__++];
            check_greater_or_equal(function__, "num_bg_variables", num_bg_variables, 1);
            current_statement_begin__ = 497;
            validate_non_negative_index("num_bg_variable_types", "num_bg_variables", num_bg_variables);
            context__.validate_dims("data initialization", "num_bg_variable_types", "int", context__.to_vec(num_bg_variables));
            num_bg_variable_types = std::vector<int>(num_bg_variables, int(0));
            vals_i__ = context__.vals_i("num_bg_variable_types");
            pos__ = 0;
            size_t num_bg_variable_types_k_0_max__ = num_bg_variables;
            for (size_t k_0__ = 0; k_0__ < num_bg_variable_types_k_0_max__; ++k_0__) {
                num_bg_variable_types[k_0__] = vals_i__[pos__++];
            }
            size_t num_bg_variable_types_i_0_max__ = num_bg_variables;
            for (size_t i_0__ = 0; i_0__ < num_bg_variable_types_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "num_bg_variable_types[i_0__]", num_bg_variable_types[i_0__], 1);
            }
            current_statement_begin__ = 498;
            validate_non_negative_index("num_bg_variable_type_combo_members", "sum(num_bg_variable_types)", sum(num_bg_variable_types));
            context__.validate_dims("data initialization", "num_bg_variable_type_combo_members", "int", context__.to_vec(sum(num_bg_variable_types)));
            num_bg_variable_type_combo_members = std::vector<int>(sum(num_bg_variable_types), int(0));
            vals_i__ = context__.vals_i("num_bg_variable_type_combo_members");
            pos__ = 0;
            size_t num_bg_variable_type_combo_members_k_0_max__ = sum(num_bg_variable_types);
            for (size_t k_0__ = 0; k_0__ < num_bg_variable_type_combo_members_k_0_max__; ++k_0__) {
                num_bg_variable_type_combo_members[k_0__] = vals_i__[pos__++];
            }
            size_t num_bg_variable_type_combo_members_i_0_max__ = sum(num_bg_variable_types);
            for (size_t i_0__ = 0; i_0__ < num_bg_variable_type_combo_members_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "num_bg_variable_type_combo_members[i_0__]", num_bg_variable_type_combo_members[i_0__], 1);
                check_less_or_equal(function__, "num_bg_variable_type_combo_members[i_0__]", num_bg_variable_type_combo_members[i_0__], num_r_types);
            }
            current_statement_begin__ = 499;
            validate_non_negative_index("bg_variable_type_combo_members", "sum(num_bg_variable_type_combo_members)", sum(num_bg_variable_type_combo_members));
            context__.validate_dims("data initialization", "bg_variable_type_combo_members", "int", context__.to_vec(sum(num_bg_variable_type_combo_members)));
            bg_variable_type_combo_members = std::vector<int>(sum(num_bg_variable_type_combo_members), int(0));
            vals_i__ = context__.vals_i("bg_variable_type_combo_members");
            pos__ = 0;
            size_t bg_variable_type_combo_members_k_0_max__ = sum(num_bg_variable_type_combo_members);
            for (size_t k_0__ = 0; k_0__ < bg_variable_type_combo_members_k_0_max__; ++k_0__) {
                bg_variable_type_combo_members[k_0__] = vals_i__[pos__++];
            }
            size_t bg_variable_type_combo_members_i_0_max__ = sum(num_bg_variable_type_combo_members);
            for (size_t i_0__ = 0; i_0__ < bg_variable_type_combo_members_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "bg_variable_type_combo_members[i_0__]", bg_variable_type_combo_members[i_0__], 1);
                check_less_or_equal(function__, "bg_variable_type_combo_members[i_0__]", bg_variable_type_combo_members[i_0__], num_r_types);
            }
            current_statement_begin__ = 503;
            context__.validate_dims("data initialization", "num_levels", "int", context__.to_vec());
            num_levels = int(0);
            vals_i__ = context__.vals_i("num_levels");
            pos__ = 0;
            num_levels = vals_i__[pos__++];
            check_greater_or_equal(function__, "num_levels", num_levels, 0);
            current_statement_begin__ = 505;
            context__.validate_dims("data initialization", "num_unique_entities", "int", context__.to_vec());
            num_unique_entities = int(0);
            vals_i__ = context__.vals_i("num_unique_entities");
            pos__ = 0;
            num_unique_entities = vals_i__[pos__++];
            check_greater_or_equal(function__, "num_unique_entities", num_unique_entities, 1);
            current_statement_begin__ = 506;
            validate_non_negative_index("unique_entity_ids", "num_unique_entities", num_unique_entities);
            validate_non_negative_index("unique_entity_ids", "num_levels", num_levels);
            context__.validate_dims("data initialization", "unique_entity_ids", "int", context__.to_vec(num_unique_entities,num_levels));
            unique_entity_ids = std::vector<std::vector<int> >(num_unique_entities, std::vector<int>(num_levels, int(0)));
            vals_i__ = context__.vals_i("unique_entity_ids");
            pos__ = 0;
            size_t unique_entity_ids_k_0_max__ = num_unique_entities;
            size_t unique_entity_ids_k_1_max__ = num_levels;
            for (size_t k_1__ = 0; k_1__ < unique_entity_ids_k_1_max__; ++k_1__) {
                for (size_t k_0__ = 0; k_0__ < unique_entity_ids_k_0_max__; ++k_0__) {
                    unique_entity_ids[k_0__][k_1__] = vals_i__[pos__++];
                }
            }
            size_t unique_entity_ids_i_0_max__ = num_unique_entities;
            size_t unique_entity_ids_i_1_max__ = num_levels;
            for (size_t i_0__ = 0; i_0__ < unique_entity_ids_i_0_max__; ++i_0__) {
                for (size_t i_1__ = 0; i_1__ < unique_entity_ids_i_1_max__; ++i_1__) {
                    check_greater_or_equal(function__, "unique_entity_ids[i_0__][i_1__]", unique_entity_ids[i_0__][i_1__], 1);
                }
            }
            current_statement_begin__ = 507;
            validate_non_negative_index("obs_unique_entity_id", "num_obs", num_obs);
            context__.validate_dims("data initialization", "obs_unique_entity_id", "int", context__.to_vec(num_obs));
            obs_unique_entity_id = std::vector<int>(num_obs, int(0));
            vals_i__ = context__.vals_i("obs_unique_entity_id");
            pos__ = 0;
            size_t obs_unique_entity_id_k_0_max__ = num_obs;
            for (size_t k_0__ = 0; k_0__ < obs_unique_entity_id_k_0_max__; ++k_0__) {
                obs_unique_entity_id[k_0__] = vals_i__[pos__++];
            }
            size_t obs_unique_entity_id_i_0_max__ = num_obs;
            for (size_t i_0__ = 0; i_0__ < obs_unique_entity_id_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "obs_unique_entity_id[i_0__]", obs_unique_entity_id[i_0__], 1);
                check_less_or_equal(function__, "obs_unique_entity_id[i_0__]", obs_unique_entity_id[i_0__], num_unique_entities);
            }
            current_statement_begin__ = 515;
            context__.validate_dims("data initialization", "num_candidate_groups", "int", context__.to_vec());
            num_candidate_groups = int(0);
            vals_i__ = context__.vals_i("num_candidate_groups");
            pos__ = 0;
            num_candidate_groups = vals_i__[pos__++];
            check_greater_or_equal(function__, "num_candidate_groups", num_candidate_groups, 1);
            current_statement_begin__ = 516;
            validate_non_negative_index("candidate_group_size", "num_candidate_groups", num_candidate_groups);
            context__.validate_dims("data initialization", "candidate_group_size", "int", context__.to_vec(num_candidate_groups));
            candidate_group_size = std::vector<int>(num_candidate_groups, int(0));
            vals_i__ = context__.vals_i("candidate_group_size");
            pos__ = 0;
            size_t candidate_group_size_k_0_max__ = num_candidate_groups;
            for (size_t k_0__ = 0; k_0__ < candidate_group_size_k_0_max__; ++k_0__) {
                candidate_group_size[k_0__] = vals_i__[pos__++];
            }
            size_t candidate_group_size_i_0_max__ = num_candidate_groups;
            for (size_t i_0__ = 0; i_0__ < candidate_group_size_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "candidate_group_size[i_0__]", candidate_group_size[i_0__], 1);
                check_less_or_equal(function__, "candidate_group_size[i_0__]", candidate_group_size[i_0__], num_r_types);
            }
            current_statement_begin__ = 517;
            validate_non_negative_index("candidate_group_ids", "sum(candidate_group_size)", sum(candidate_group_size));
            context__.validate_dims("data initialization", "candidate_group_ids", "int", context__.to_vec(sum(candidate_group_size)));
            candidate_group_ids = std::vector<int>(sum(candidate_group_size), int(0));
            vals_i__ = context__.vals_i("candidate_group_ids");
            pos__ = 0;
            size_t candidate_group_ids_k_0_max__ = sum(candidate_group_size);
            for (size_t k_0__ = 0; k_0__ < candidate_group_ids_k_0_max__; ++k_0__) {
                candidate_group_ids[k_0__] = vals_i__[pos__++];
            }
            size_t candidate_group_ids_i_0_max__ = sum(candidate_group_size);
            for (size_t i_0__ = 0; i_0__ < candidate_group_ids_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "candidate_group_ids[i_0__]", candidate_group_ids[i_0__], 1);
                check_less_or_equal(function__, "candidate_group_ids[i_0__]", candidate_group_ids[i_0__], num_r_types);
            }
            current_statement_begin__ = 519;
            validate_non_negative_index("num_unique_entity_candidate_groups", "(logical_gt(num_obs, 0) ? num_unique_entities : 0 )", (logical_gt(num_obs, 0) ? num_unique_entities : 0 ));
            context__.validate_dims("data initialization", "num_unique_entity_candidate_groups", "int", context__.to_vec((logical_gt(num_obs, 0) ? num_unique_entities : 0 )));
            num_unique_entity_candidate_groups = std::vector<int>((logical_gt(num_obs, 0) ? num_unique_entities : 0 ), int(0));
            vals_i__ = context__.vals_i("num_unique_entity_candidate_groups");
            pos__ = 0;
            size_t num_unique_entity_candidate_groups_k_0_max__ = (logical_gt(num_obs, 0) ? num_unique_entities : 0 );
            for (size_t k_0__ = 0; k_0__ < num_unique_entity_candidate_groups_k_0_max__; ++k_0__) {
                num_unique_entity_candidate_groups[k_0__] = vals_i__[pos__++];
            }
            size_t num_unique_entity_candidate_groups_i_0_max__ = (logical_gt(num_obs, 0) ? num_unique_entities : 0 );
            for (size_t i_0__ = 0; i_0__ < num_unique_entity_candidate_groups_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "num_unique_entity_candidate_groups[i_0__]", num_unique_entity_candidate_groups[i_0__], 1);
                check_less_or_equal(function__, "num_unique_entity_candidate_groups[i_0__]", num_unique_entity_candidate_groups[i_0__], num_candidate_groups);
            }
            current_statement_begin__ = 520;
            validate_non_negative_index("unique_entity_candidate_groups", "sum(num_unique_entity_candidate_groups)", sum(num_unique_entity_candidate_groups));
            context__.validate_dims("data initialization", "unique_entity_candidate_groups", "int", context__.to_vec(sum(num_unique_entity_candidate_groups)));
            unique_entity_candidate_groups = std::vector<int>(sum(num_unique_entity_candidate_groups), int(0));
            vals_i__ = context__.vals_i("unique_entity_candidate_groups");
            pos__ = 0;
            size_t unique_entity_candidate_groups_k_0_max__ = sum(num_unique_entity_candidate_groups);
            for (size_t k_0__ = 0; k_0__ < unique_entity_candidate_groups_k_0_max__; ++k_0__) {
                unique_entity_candidate_groups[k_0__] = vals_i__[pos__++];
            }
            size_t unique_entity_candidate_groups_i_0_max__ = sum(num_unique_entity_candidate_groups);
            for (size_t i_0__ = 0; i_0__ < unique_entity_candidate_groups_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "unique_entity_candidate_groups[i_0__]", unique_entity_candidate_groups[i_0__], 1);
                check_less_or_equal(function__, "unique_entity_candidate_groups[i_0__]", unique_entity_candidate_groups[i_0__], num_candidate_groups);
            }
            current_statement_begin__ = 521;
            validate_non_negative_index("num_unique_entity_in_candidate_groups", "sum(num_unique_entity_candidate_groups)", sum(num_unique_entity_candidate_groups));
            context__.validate_dims("data initialization", "num_unique_entity_in_candidate_groups", "row_vector_d", context__.to_vec(sum(num_unique_entity_candidate_groups)));
            num_unique_entity_in_candidate_groups = Eigen::Matrix<double, 1, Eigen::Dynamic>(sum(num_unique_entity_candidate_groups));
            vals_r__ = context__.vals_r("num_unique_entity_in_candidate_groups");
            pos__ = 0;
            size_t num_unique_entity_in_candidate_groups_j_1_max__ = sum(num_unique_entity_candidate_groups);
            for (size_t j_1__ = 0; j_1__ < num_unique_entity_in_candidate_groups_j_1_max__; ++j_1__) {
                num_unique_entity_in_candidate_groups(j_1__) = vals_r__[pos__++];
            }
            check_greater_or_equal(function__, "num_unique_entity_in_candidate_groups", num_unique_entity_in_candidate_groups, 1);
            current_statement_begin__ = 523;
            validate_non_negative_index("obs_candidate_group", "num_obs", num_obs);
            context__.validate_dims("data initialization", "obs_candidate_group", "int", context__.to_vec(num_obs));
            obs_candidate_group = std::vector<int>(num_obs, int(0));
            vals_i__ = context__.vals_i("obs_candidate_group");
            pos__ = 0;
            size_t obs_candidate_group_k_0_max__ = num_obs;
            for (size_t k_0__ = 0; k_0__ < obs_candidate_group_k_0_max__; ++k_0__) {
                obs_candidate_group[k_0__] = vals_i__[pos__++];
            }
            size_t obs_candidate_group_i_0_max__ = num_obs;
            for (size_t i_0__ = 0; i_0__ < obs_candidate_group_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "obs_candidate_group[i_0__]", obs_candidate_group[i_0__], 1);
                check_less_or_equal(function__, "obs_candidate_group[i_0__]", obs_candidate_group[i_0__], num_candidate_groups);
            }
            current_statement_begin__ = 525;
            validate_non_negative_index("obs_in_unique_entity_in_candidate_groups", "num_obs", num_obs);
            context__.validate_dims("data initialization", "obs_in_unique_entity_in_candidate_groups", "int", context__.to_vec(num_obs));
            obs_in_unique_entity_in_candidate_groups = std::vector<int>(num_obs, int(0));
            vals_i__ = context__.vals_i("obs_in_unique_entity_in_candidate_groups");
            pos__ = 0;
            size_t obs_in_unique_entity_in_candidate_groups_k_0_max__ = num_obs;
            for (size_t k_0__ = 0; k_0__ < obs_in_unique_entity_in_candidate_groups_k_0_max__; ++k_0__) {
                obs_in_unique_entity_in_candidate_groups[k_0__] = vals_i__[pos__++];
            }
            size_t obs_in_unique_entity_in_candidate_groups_i_0_max__ = num_obs;
            for (size_t i_0__ = 0; i_0__ < obs_in_unique_entity_in_candidate_groups_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "obs_in_unique_entity_in_candidate_groups[i_0__]", obs_in_unique_entity_in_candidate_groups[i_0__], 1);
                check_less_or_equal(function__, "obs_in_unique_entity_in_candidate_groups[i_0__]", obs_in_unique_entity_in_candidate_groups[i_0__], num_obs);
            }
            current_statement_begin__ = 529;
            context__.validate_dims("data initialization", "num_discrete_estimands", "int", context__.to_vec());
            num_discrete_estimands = int(0);
            vals_i__ = context__.vals_i("num_discrete_estimands");
            pos__ = 0;
            num_discrete_estimands = vals_i__[pos__++];
            check_greater_or_equal(function__, "num_discrete_estimands", num_discrete_estimands, 0);
            current_statement_begin__ = 530;
            context__.validate_dims("data initialization", "num_atom_estimands", "int", context__.to_vec());
            num_atom_estimands = int(0);
            vals_i__ = context__.vals_i("num_atom_estimands");
            pos__ = 0;
            num_atom_estimands = vals_i__[pos__++];
            check_greater_or_equal(function__, "num_atom_estimands", num_atom_estimands, 0);
            check_less_or_equal(function__, "num_atom_estimands", num_atom_estimands, num_discrete_estimands);
            current_statement_begin__ = 531;
            context__.validate_dims("data initialization", "num_diff_estimands", "int", context__.to_vec());
            num_diff_estimands = int(0);
            vals_i__ = context__.vals_i("num_diff_estimands");
            pos__ = 0;
            num_diff_estimands = vals_i__[pos__++];
            check_greater_or_equal(function__, "num_diff_estimands", num_diff_estimands, 0);
            check_less_or_equal(function__, "num_diff_estimands", num_diff_estimands, num_discrete_estimands);
            current_statement_begin__ = 532;
            context__.validate_dims("data initialization", "num_discretized_groups", "int", context__.to_vec());
            num_discretized_groups = int(0);
            vals_i__ = context__.vals_i("num_discretized_groups");
            pos__ = 0;
            num_discretized_groups = vals_i__[pos__++];
            check_greater_or_equal(function__, "num_discretized_groups", num_discretized_groups, 0);
            check_less_or_equal(function__, "num_discretized_groups", num_discretized_groups, num_atom_estimands);
            current_statement_begin__ = 533;
            context__.validate_dims("data initialization", "num_mean_diff_estimands", "int", context__.to_vec());
            num_mean_diff_estimands = int(0);
            vals_i__ = context__.vals_i("num_mean_diff_estimands");
            pos__ = 0;
            num_mean_diff_estimands = vals_i__[pos__++];
            check_greater_or_equal(function__, "num_mean_diff_estimands", num_mean_diff_estimands, 0);
            current_statement_begin__ = 534;
            context__.validate_dims("data initialization", "num_utility_diff_estimands", "int", context__.to_vec());
            num_utility_diff_estimands = int(0);
            vals_i__ = context__.vals_i("num_utility_diff_estimands");
            pos__ = 0;
            num_utility_diff_estimands = vals_i__[pos__++];
            check_greater_or_equal(function__, "num_utility_diff_estimands", num_utility_diff_estimands, 0);
            current_statement_begin__ = 536;
            validate_non_negative_index("diff_estimand_atoms", "(num_diff_estimands * 2)", (num_diff_estimands * 2));
            context__.validate_dims("data initialization", "diff_estimand_atoms", "int", context__.to_vec((num_diff_estimands * 2)));
            diff_estimand_atoms = std::vector<int>((num_diff_estimands * 2), int(0));
            vals_i__ = context__.vals_i("diff_estimand_atoms");
            pos__ = 0;
            size_t diff_estimand_atoms_k_0_max__ = (num_diff_estimands * 2);
            for (size_t k_0__ = 0; k_0__ < diff_estimand_atoms_k_0_max__; ++k_0__) {
                diff_estimand_atoms[k_0__] = vals_i__[pos__++];
            }
            size_t diff_estimand_atoms_i_0_max__ = (num_diff_estimands * 2);
            for (size_t i_0__ = 0; i_0__ < diff_estimand_atoms_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "diff_estimand_atoms[i_0__]", diff_estimand_atoms[i_0__], 1);
                check_less_or_equal(function__, "diff_estimand_atoms[i_0__]", diff_estimand_atoms[i_0__], num_atom_estimands);
            }
            current_statement_begin__ = 537;
            validate_non_negative_index("mean_diff_estimand_atoms", "(num_mean_diff_estimands * 2)", (num_mean_diff_estimands * 2));
            context__.validate_dims("data initialization", "mean_diff_estimand_atoms", "int", context__.to_vec((num_mean_diff_estimands * 2)));
            mean_diff_estimand_atoms = std::vector<int>((num_mean_diff_estimands * 2), int(0));
            vals_i__ = context__.vals_i("mean_diff_estimand_atoms");
            pos__ = 0;
            size_t mean_diff_estimand_atoms_k_0_max__ = (num_mean_diff_estimands * 2);
            for (size_t k_0__ = 0; k_0__ < mean_diff_estimand_atoms_k_0_max__; ++k_0__) {
                mean_diff_estimand_atoms[k_0__] = vals_i__[pos__++];
            }
            size_t mean_diff_estimand_atoms_i_0_max__ = (num_mean_diff_estimands * 2);
            for (size_t i_0__ = 0; i_0__ < mean_diff_estimand_atoms_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "mean_diff_estimand_atoms[i_0__]", mean_diff_estimand_atoms[i_0__], 1);
                check_less_or_equal(function__, "mean_diff_estimand_atoms[i_0__]", mean_diff_estimand_atoms[i_0__], num_discretized_groups);
            }
            current_statement_begin__ = 538;
            validate_non_negative_index("utility_diff_estimand_atoms", "(num_utility_diff_estimands * 2)", (num_utility_diff_estimands * 2));
            context__.validate_dims("data initialization", "utility_diff_estimand_atoms", "int", context__.to_vec((num_utility_diff_estimands * 2)));
            utility_diff_estimand_atoms = std::vector<int>((num_utility_diff_estimands * 2), int(0));
            vals_i__ = context__.vals_i("utility_diff_estimand_atoms");
            pos__ = 0;
            size_t utility_diff_estimand_atoms_k_0_max__ = (num_utility_diff_estimands * 2);
            for (size_t k_0__ = 0; k_0__ < utility_diff_estimand_atoms_k_0_max__; ++k_0__) {
                utility_diff_estimand_atoms[k_0__] = vals_i__[pos__++];
            }
            size_t utility_diff_estimand_atoms_i_0_max__ = (num_utility_diff_estimands * 2);
            for (size_t i_0__ = 0; i_0__ < utility_diff_estimand_atoms_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "utility_diff_estimand_atoms[i_0__]", utility_diff_estimand_atoms[i_0__], 1);
                check_less_or_equal(function__, "utility_diff_estimand_atoms[i_0__]", utility_diff_estimand_atoms[i_0__], num_discretized_groups);
            }
            current_statement_begin__ = 540;
            validate_non_negative_index("discretized_group_ids", "(num_discretized_groups * (num_cutpoints - 2))", (num_discretized_groups * (num_cutpoints - 2)));
            context__.validate_dims("data initialization", "discretized_group_ids", "int", context__.to_vec((num_discretized_groups * (num_cutpoints - 2))));
            discretized_group_ids = std::vector<int>((num_discretized_groups * (num_cutpoints - 2)), int(0));
            vals_i__ = context__.vals_i("discretized_group_ids");
            pos__ = 0;
            size_t discretized_group_ids_k_0_max__ = (num_discretized_groups * (num_cutpoints - 2));
            for (size_t k_0__ = 0; k_0__ < discretized_group_ids_k_0_max__; ++k_0__) {
                discretized_group_ids[k_0__] = vals_i__[pos__++];
            }
            size_t discretized_group_ids_i_0_max__ = (num_discretized_groups * (num_cutpoints - 2));
            for (size_t i_0__ = 0; i_0__ < discretized_group_ids_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "discretized_group_ids[i_0__]", discretized_group_ids[i_0__], 1);
                check_less_or_equal(function__, "discretized_group_ids[i_0__]", discretized_group_ids[i_0__], num_atom_estimands);
            }
            current_statement_begin__ = 542;
            context__.validate_dims("data initialization", "num_abducted_estimands", "int", context__.to_vec());
            num_abducted_estimands = int(0);
            vals_i__ = context__.vals_i("num_abducted_estimands");
            pos__ = 0;
            num_abducted_estimands = vals_i__[pos__++];
            check_greater_or_equal(function__, "num_abducted_estimands", num_abducted_estimands, 0);
            current_statement_begin__ = 543;
            validate_non_negative_index("abducted_estimand_ids", "num_abducted_estimands", num_abducted_estimands);
            context__.validate_dims("data initialization", "abducted_estimand_ids", "int", context__.to_vec(num_abducted_estimands));
            abducted_estimand_ids = std::vector<int>(num_abducted_estimands, int(0));
            vals_i__ = context__.vals_i("abducted_estimand_ids");
            pos__ = 0;
            size_t abducted_estimand_ids_k_0_max__ = num_abducted_estimands;
            for (size_t k_0__ = 0; k_0__ < abducted_estimand_ids_k_0_max__; ++k_0__) {
                abducted_estimand_ids[k_0__] = vals_i__[pos__++];
            }
            size_t abducted_estimand_ids_i_0_max__ = num_abducted_estimands;
            for (size_t i_0__ = 0; i_0__ < abducted_estimand_ids_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "abducted_estimand_ids[i_0__]", abducted_estimand_ids[i_0__], 1);
                check_less_or_equal(function__, "abducted_estimand_ids[i_0__]", abducted_estimand_ids[i_0__], num_atom_estimands);
            }
            current_statement_begin__ = 545;
            context__.validate_dims("data initialization", "num_estimand_levels", "int", context__.to_vec());
            num_estimand_levels = int(0);
            vals_i__ = context__.vals_i("num_estimand_levels");
            pos__ = 0;
            num_estimand_levels = vals_i__[pos__++];
            check_greater_or_equal(function__, "num_estimand_levels", num_estimand_levels, 0);
            check_less_or_equal(function__, "num_estimand_levels", num_estimand_levels, num_levels);
            current_statement_begin__ = 546;
            validate_non_negative_index("estimand_levels", "num_estimand_levels", num_estimand_levels);
            context__.validate_dims("data initialization", "estimand_levels", "int", context__.to_vec(num_estimand_levels));
            estimand_levels = std::vector<int>(num_estimand_levels, int(0));
            vals_i__ = context__.vals_i("estimand_levels");
            pos__ = 0;
            size_t estimand_levels_k_0_max__ = num_estimand_levels;
            for (size_t k_0__ = 0; k_0__ < estimand_levels_k_0_max__; ++k_0__) {
                estimand_levels[k_0__] = vals_i__[pos__++];
            }
            size_t estimand_levels_i_0_max__ = num_estimand_levels;
            for (size_t i_0__ = 0; i_0__ < estimand_levels_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "estimand_levels[i_0__]", estimand_levels[i_0__], 1);
                check_less_or_equal(function__, "estimand_levels[i_0__]", estimand_levels[i_0__], num_levels);
            }
            current_statement_begin__ = 548;
            context__.validate_dims("data initialization", "num_between_entity_diff_levels", "int", context__.to_vec());
            num_between_entity_diff_levels = int(0);
            vals_i__ = context__.vals_i("num_between_entity_diff_levels");
            pos__ = 0;
            num_between_entity_diff_levels = vals_i__[pos__++];
            check_greater_or_equal(function__, "num_between_entity_diff_levels", num_between_entity_diff_levels, 0);
            check_less_or_equal(function__, "num_between_entity_diff_levels", num_between_entity_diff_levels, num_levels);
            current_statement_begin__ = 549;
            validate_non_negative_index("between_entity_diff_levels", "num_between_entity_diff_levels", num_between_entity_diff_levels);
            context__.validate_dims("data initialization", "between_entity_diff_levels", "int", context__.to_vec(num_between_entity_diff_levels));
            between_entity_diff_levels = std::vector<int>(num_between_entity_diff_levels, int(0));
            vals_i__ = context__.vals_i("between_entity_diff_levels");
            pos__ = 0;
            size_t between_entity_diff_levels_k_0_max__ = num_between_entity_diff_levels;
            for (size_t k_0__ = 0; k_0__ < between_entity_diff_levels_k_0_max__; ++k_0__) {
                between_entity_diff_levels[k_0__] = vals_i__[pos__++];
            }
            size_t between_entity_diff_levels_i_0_max__ = num_between_entity_diff_levels;
            for (size_t i_0__ = 0; i_0__ < between_entity_diff_levels_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "between_entity_diff_levels[i_0__]", between_entity_diff_levels[i_0__], 1);
                check_less_or_equal(function__, "between_entity_diff_levels[i_0__]", between_entity_diff_levels[i_0__], num_levels);
            }
            current_statement_begin__ = 551;
            validate_non_negative_index("abducted_prob_size", "num_abducted_estimands", num_abducted_estimands);
            context__.validate_dims("data initialization", "abducted_prob_size", "int", context__.to_vec(num_abducted_estimands));
            abducted_prob_size = std::vector<int>(num_abducted_estimands, int(0));
            vals_i__ = context__.vals_i("abducted_prob_size");
            pos__ = 0;
            size_t abducted_prob_size_k_0_max__ = num_abducted_estimands;
            for (size_t k_0__ = 0; k_0__ < abducted_prob_size_k_0_max__; ++k_0__) {
                abducted_prob_size[k_0__] = vals_i__[pos__++];
            }
            size_t abducted_prob_size_i_0_max__ = num_abducted_estimands;
            for (size_t i_0__ = 0; i_0__ < abducted_prob_size_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "abducted_prob_size[i_0__]", abducted_prob_size[i_0__], 0);
            }
            current_statement_begin__ = 552;
            validate_non_negative_index("abducted_prob_index", "sum(abducted_prob_size)", sum(abducted_prob_size));
            context__.validate_dims("data initialization", "abducted_prob_index", "int", context__.to_vec(sum(abducted_prob_size)));
            abducted_prob_index = std::vector<int>(sum(abducted_prob_size), int(0));
            vals_i__ = context__.vals_i("abducted_prob_index");
            pos__ = 0;
            size_t abducted_prob_index_k_0_max__ = sum(abducted_prob_size);
            for (size_t k_0__ = 0; k_0__ < abducted_prob_index_k_0_max__; ++k_0__) {
                abducted_prob_index[k_0__] = vals_i__[pos__++];
            }
            size_t abducted_prob_index_i_0_max__ = sum(abducted_prob_size);
            for (size_t i_0__ = 0; i_0__ < abducted_prob_index_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "abducted_prob_index[i_0__]", abducted_prob_index[i_0__], 1);
                check_less_or_equal(function__, "abducted_prob_index[i_0__]", abducted_prob_index[i_0__], (num_r_types * num_experiment_types));
            }
            current_statement_begin__ = 554;
            validate_non_negative_index("est_prob_size", "num_atom_estimands", num_atom_estimands);
            context__.validate_dims("data initialization", "est_prob_size", "int", context__.to_vec(num_atom_estimands));
            est_prob_size = std::vector<int>(num_atom_estimands, int(0));
            vals_i__ = context__.vals_i("est_prob_size");
            pos__ = 0;
            size_t est_prob_size_k_0_max__ = num_atom_estimands;
            for (size_t k_0__ = 0; k_0__ < est_prob_size_k_0_max__; ++k_0__) {
                est_prob_size[k_0__] = vals_i__[pos__++];
            }
            size_t est_prob_size_i_0_max__ = num_atom_estimands;
            for (size_t i_0__ = 0; i_0__ < est_prob_size_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "est_prob_size[i_0__]", est_prob_size[i_0__], 0);
            }
            current_statement_begin__ = 555;
            validate_non_negative_index("est_prob_index", "sum(est_prob_size)", sum(est_prob_size));
            context__.validate_dims("data initialization", "est_prob_index", "int", context__.to_vec(sum(est_prob_size)));
            est_prob_index = std::vector<int>(sum(est_prob_size), int(0));
            vals_i__ = context__.vals_i("est_prob_index");
            pos__ = 0;
            size_t est_prob_index_k_0_max__ = sum(est_prob_size);
            for (size_t k_0__ = 0; k_0__ < est_prob_index_k_0_max__; ++k_0__) {
                est_prob_index[k_0__] = vals_i__[pos__++];
            }
            size_t est_prob_index_i_0_max__ = sum(est_prob_size);
            for (size_t i_0__ = 0; i_0__ < est_prob_index_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "est_prob_index[i_0__]", est_prob_index[i_0__], 1);
                check_less_or_equal(function__, "est_prob_index[i_0__]", est_prob_index[i_0__], (num_r_types * num_experiment_types));
            }
            current_statement_begin__ = 557;
            context__.validate_dims("data initialization", "num_discrete_utility_values", "int", context__.to_vec());
            num_discrete_utility_values = int(0);
            vals_i__ = context__.vals_i("num_discrete_utility_values");
            pos__ = 0;
            num_discrete_utility_values = vals_i__[pos__++];
            check_greater_or_equal(function__, "num_discrete_utility_values", num_discrete_utility_values, 0);
            current_statement_begin__ = 558;
            validate_non_negative_index("utility", "num_discrete_utility_values", num_discrete_utility_values);
            context__.validate_dims("data initialization", "utility", "vector_d", context__.to_vec(num_discrete_utility_values));
            utility = Eigen::Matrix<double, Eigen::Dynamic, 1>(num_discrete_utility_values);
            vals_r__ = context__.vals_r("utility");
            pos__ = 0;
            size_t utility_j_1_max__ = num_discrete_utility_values;
            for (size_t j_1__ = 0; j_1__ < utility_j_1_max__; ++j_1__) {
                utility(j_1__) = vals_r__[pos__++];
            }
            current_statement_begin__ = 568;
            context__.validate_dims("data initialization", "log_lik_level", "int", context__.to_vec());
            log_lik_level = int(0);
            vals_i__ = context__.vals_i("log_lik_level");
            pos__ = 0;
            log_lik_level = vals_i__[pos__++];
            check_greater_or_equal(function__, "log_lik_level", log_lik_level, -(1));
            check_less_or_equal(function__, "log_lik_level", log_lik_level, num_levels);
            current_statement_begin__ = 574;
            context__.validate_dims("data initialization", "discrete_beta_hyper_sd", "double", context__.to_vec());
            discrete_beta_hyper_sd = double(0);
            vals_r__ = context__.vals_r("discrete_beta_hyper_sd");
            pos__ = 0;
            discrete_beta_hyper_sd = vals_r__[pos__++];
            check_greater_or_equal(function__, "discrete_beta_hyper_sd", discrete_beta_hyper_sd, 0);
            current_statement_begin__ = 575;
            context__.validate_dims("data initialization", "discretized_beta_hyper_sd", "double", context__.to_vec());
            discretized_beta_hyper_sd = double(0);
            vals_r__ = context__.vals_r("discretized_beta_hyper_sd");
            pos__ = 0;
            discretized_beta_hyper_sd = vals_r__[pos__++];
            check_greater_or_equal(function__, "discretized_beta_hyper_sd", discretized_beta_hyper_sd, 0);
            current_statement_begin__ = 577;
            validate_non_negative_index("tau_level_sigma", "num_levels", num_levels);
            context__.validate_dims("data initialization", "tau_level_sigma", "vector_d", context__.to_vec(num_levels));
            tau_level_sigma = Eigen::Matrix<double, Eigen::Dynamic, 1>(num_levels);
            vals_r__ = context__.vals_r("tau_level_sigma");
            pos__ = 0;
            size_t tau_level_sigma_j_1_max__ = num_levels;
            for (size_t j_1__ = 0; j_1__ < tau_level_sigma_j_1_max__; ++j_1__) {
                tau_level_sigma(j_1__) = vals_r__[pos__++];
            }
            check_greater_or_equal(function__, "tau_level_sigma", tau_level_sigma, 0);
            current_statement_begin__ = 581;
            context__.validate_dims("data initialization", "run_type", "int", context__.to_vec());
            run_type = int(0);
            vals_i__ = context__.vals_i("run_type");
            pos__ = 0;
            run_type = vals_i__[pos__++];
            check_greater_or_equal(function__, "run_type", run_type, 1);
            check_less_or_equal(function__, "run_type", run_type, 2);
            current_statement_begin__ = 582;
            context__.validate_dims("data initialization", "use_random_binpoint", "int", context__.to_vec());
            use_random_binpoint = int(0);
            vals_i__ = context__.vals_i("use_random_binpoint");
            pos__ = 0;
            use_random_binpoint = vals_i__[pos__++];
            check_greater_or_equal(function__, "use_random_binpoint", use_random_binpoint, 0);
            check_less_or_equal(function__, "use_random_binpoint", use_random_binpoint, 1);
            current_statement_begin__ = 583;
            context__.validate_dims("data initialization", "generate_rep", "int", context__.to_vec());
            generate_rep = int(0);
            vals_i__ = context__.vals_i("generate_rep");
            pos__ = 0;
            generate_rep = vals_i__[pos__++];
            check_greater_or_equal(function__, "generate_rep", generate_rep, 0);
            check_less_or_equal(function__, "generate_rep", generate_rep, 1);
            current_statement_begin__ = 584;
            context__.validate_dims("data initialization", "calculate_marginal_prob", "int", context__.to_vec());
            calculate_marginal_prob = int(0);
            vals_i__ = context__.vals_i("calculate_marginal_prob");
            pos__ = 0;
            calculate_marginal_prob = vals_i__[pos__++];
            check_greater_or_equal(function__, "calculate_marginal_prob", calculate_marginal_prob, 0);
            check_less_or_equal(function__, "calculate_marginal_prob", calculate_marginal_prob, 1);
            // initialize transformed data variables
            current_statement_begin__ = 588;
            RUN_TYPE_PRIOR_PREDICT = int(0);
            stan::math::fill(RUN_TYPE_PRIOR_PREDICT, std::numeric_limits<int>::min());
            stan::math::assign(RUN_TYPE_PRIOR_PREDICT,1);
            current_statement_begin__ = 589;
            RUN_TYPE_FIT = int(0);
            stan::math::fill(RUN_TYPE_FIT, std::numeric_limits<int>::min());
            stan::math::assign(RUN_TYPE_FIT,2);
            current_statement_begin__ = 591;
            num_all_estimands = int(0);
            stan::math::fill(num_all_estimands, std::numeric_limits<int>::min());
            stan::math::assign(num_all_estimands,(((num_discrete_estimands + ((1 + logical_gt(num_discrete_utility_values, 0)) * num_discretized_groups)) + num_mean_diff_estimands) + num_utility_diff_estimands));
            current_statement_begin__ = 593;
            num_discretized_variables = int(0);
            stan::math::fill(num_discretized_variables, std::numeric_limits<int>::min());
            stan::math::assign(num_discretized_variables,std::max((num_cutpoints - 2), 0));
            current_statement_begin__ = 595;
            discrete_group_size = int(0);
            stan::math::fill(discrete_group_size, std::numeric_limits<int>::min());
            stan::math::assign(discrete_group_size,divide(num_r_types, num_discrete_r_types));
            current_statement_begin__ = 597;
            validate_non_negative_index("cutpoint_midpoints", "std::max((num_cutpoints - 1), 0)", std::max((num_cutpoints - 1), 0));
            cutpoint_midpoints = Eigen::Matrix<double, Eigen::Dynamic, 1>(std::max((num_cutpoints - 1), 0));
            stan::math::fill(cutpoint_midpoints, DUMMY_VAR__);
            current_statement_begin__ = 598;
            validate_non_negative_index("discretized_binwidth", "std::max((num_cutpoints - 1), 0)", std::max((num_cutpoints - 1), 0));
            discretized_binwidth = Eigen::Matrix<double, Eigen::Dynamic, 1>(std::max((num_cutpoints - 1), 0));
            stan::math::fill(discretized_binwidth, DUMMY_VAR__);
            current_statement_begin__ = 600;
            validate_non_negative_index("discretize_bin_alpha", "std::max((num_cutpoints - 1), 0)", std::max((num_cutpoints - 1), 0));
            discretize_bin_alpha = std::vector<double>(std::max((num_cutpoints - 1), 0), double(0));
            stan::math::fill(discretize_bin_alpha, DUMMY_VAR__);
            current_statement_begin__ = 601;
            validate_non_negative_index("discretize_bin_beta", "std::max((num_cutpoints - 1), 0)", std::max((num_cutpoints - 1), 0));
            discretize_bin_beta = std::vector<double>(std::max((num_cutpoints - 1), 0), double(0));
            stan::math::fill(discretize_bin_beta, DUMMY_VAR__);
            current_statement_begin__ = 603;
            validate_non_negative_index("entity_discretize_bin_alpha", "((num_unique_entities * (num_cutpoints - 1)) * num_discretized_groups)", ((num_unique_entities * (num_cutpoints - 1)) * num_discretized_groups));
            entity_discretize_bin_alpha = std::vector<double>(((num_unique_entities * (num_cutpoints - 1)) * num_discretized_groups), double(0));
            stan::math::fill(entity_discretize_bin_alpha, DUMMY_VAR__);
            current_statement_begin__ = 604;
            validate_non_negative_index("entity_discretize_bin_beta", "((num_unique_entities * (num_cutpoints - 1)) * num_discretized_groups)", ((num_unique_entities * (num_cutpoints - 1)) * num_discretized_groups));
            entity_discretize_bin_beta = std::vector<double>(((num_unique_entities * (num_cutpoints - 1)) * num_discretized_groups), double(0));
            stan::math::fill(entity_discretize_bin_beta, DUMMY_VAR__);
            current_statement_begin__ = 606;
            num_r_types_full = int(0);
            stan::math::fill(num_r_types_full, std::numeric_limits<int>::min());
            stan::math::assign(num_r_types_full,(num_r_types * num_experiment_types));
            current_statement_begin__ = 607;
            validate_non_negative_index("experiment_r_type_index", "num_r_types_full", num_r_types_full);
            experiment_r_type_index = std::vector<int>(num_r_types_full, int(0));
            stan::math::fill(experiment_r_type_index, std::numeric_limits<int>::min());
            current_statement_begin__ = 609;
            validate_non_negative_index("full_experiment_types_prob", "num_r_types_full", num_r_types_full);
            full_experiment_types_prob = Eigen::Matrix<double, Eigen::Dynamic, 1>(num_r_types_full);
            stan::math::fill(full_experiment_types_prob, DUMMY_VAR__);
            stan::math::assign(full_experiment_types_prob,to_vector(rep_matrix(experiment_types_prob, num_r_types)));
            current_statement_begin__ = 611;
            validate_non_negative_index("level_size", "num_levels", num_levels);
            level_size = std::vector<int>(num_levels, int(0));
            stan::math::fill(level_size, std::numeric_limits<int>::min());
            stan::math::assign(level_size,calculate_level_size(num_levels, unique_entity_ids, pstream__));
            current_statement_begin__ = 612;
            validate_non_negative_index("num_obs_in_unique_entity", "num_unique_entities", num_unique_entities);
            num_obs_in_unique_entity = Eigen::Matrix<double, Eigen::Dynamic, 1>(num_unique_entities);
            stan::math::fill(num_obs_in_unique_entity, DUMMY_VAR__);
            current_statement_begin__ = 613;
            validate_non_negative_index("unique_entity_prop", "std::max(1, num_unique_entities)", std::max(1, num_unique_entities));
            unique_entity_prop = Eigen::Matrix<double, Eigen::Dynamic, 1>(std::max(1, num_unique_entities));
            stan::math::fill(unique_entity_prop, DUMMY_VAR__);
            current_statement_begin__ = 615;
            validate_non_negative_index("num_unique_entities_in_estimand_level_entities", "sum(stan::model::rvalue(level_size, stan::model::cons_list(stan::model::index_multi(estimand_levels), stan::model::nil_index_list()), \"level_size\"))", sum(stan::model::rvalue(level_size, stan::model::cons_list(stan::model::index_multi(estimand_levels), stan::model::nil_index_list()), "level_size")));
            num_unique_entities_in_estimand_level_entities = std::vector<int>(sum(stan::model::rvalue(level_size, stan::model::cons_list(stan::model::index_multi(estimand_levels), stan::model::nil_index_list()), "level_size")), int(0));
            stan::math::fill(num_unique_entities_in_estimand_level_entities, std::numeric_limits<int>::min());
            stan::math::assign(num_unique_entities_in_estimand_level_entities,calculate_num_in_level_entities(stan::model::rvalue(unique_entity_ids, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_multi(estimand_levels), stan::model::nil_index_list())), "unique_entity_ids"), stan::model::rvalue(level_size, stan::model::cons_list(stan::model::index_multi(estimand_levels), stan::model::nil_index_list()), "level_size"), pstream__));
            current_statement_begin__ = 618;
            validate_non_negative_index("unique_entities_in_level_entities", "num_unique_entities", num_unique_entities);
            validate_non_negative_index("unique_entities_in_level_entities", "num_levels", num_levels);
            unique_entities_in_level_entities = std::vector<std::vector<int> >(num_unique_entities, std::vector<int>(num_levels, int(0)));
            stan::math::fill(unique_entities_in_level_entities, std::numeric_limits<int>::min());
            current_statement_begin__ = 623;
            validate_non_negative_index("vec_diff", "((num_diff_estimands * 2) * num_unique_entities)", ((num_diff_estimands * 2) * num_unique_entities));
            vec_diff = Eigen::Matrix<double, Eigen::Dynamic, 1>(((num_diff_estimands * 2) * num_unique_entities));
            stan::math::fill(vec_diff, DUMMY_VAR__);
            stan::math::assign(vec_diff,to_vector(rep_matrix(transpose(stan::math::to_row_vector(stan::math::array_builder<double >().add(1).add(-(1)).array())), (num_diff_estimands * num_unique_entities))));
            current_statement_begin__ = 624;
            validate_non_negative_index("vec_mean_diff", "((num_mean_diff_estimands * 2) * num_unique_entities)", ((num_mean_diff_estimands * 2) * num_unique_entities));
            vec_mean_diff = Eigen::Matrix<double, Eigen::Dynamic, 1>(((num_mean_diff_estimands * 2) * num_unique_entities));
            stan::math::fill(vec_mean_diff, DUMMY_VAR__);
            stan::math::assign(vec_mean_diff,to_vector(rep_matrix(transpose(stan::math::to_row_vector(stan::math::array_builder<double >().add(1).add(-(1)).array())), (num_mean_diff_estimands * num_unique_entities))));
            current_statement_begin__ = 625;
            validate_non_negative_index("vec_utility_diff", "((num_utility_diff_estimands * 2) * num_unique_entities)", ((num_utility_diff_estimands * 2) * num_unique_entities));
            vec_utility_diff = Eigen::Matrix<double, Eigen::Dynamic, 1>(((num_utility_diff_estimands * 2) * num_unique_entities));
            stan::math::fill(vec_utility_diff, DUMMY_VAR__);
            stan::math::assign(vec_utility_diff,to_vector(rep_matrix(transpose(stan::math::to_row_vector(stan::math::array_builder<double >().add(1).add(-(1)).array())), (num_utility_diff_estimands * num_unique_entities))));
            current_statement_begin__ = 627;
            vec_1_size = int(0);
            stan::math::fill(vec_1_size, std::numeric_limits<int>::min());
            stan::math::assign(vec_1_size,max(static_cast<std::vector<int> >(stan::math::array_builder<int >().add(sum(stan::model::rvalue(candidate_group_size, stan::model::cons_list(stan::model::index_multi(unique_entity_candidate_groups), stan::model::nil_index_list()), "candidate_group_size"))).add(sum(stan::model::rvalue(candidate_group_size, stan::model::cons_list(stan::model::index_multi(obs_candidate_group), stan::model::nil_index_list()), "candidate_group_size"))).add((num_unique_entities * sum(abducted_prob_size))).add((num_unique_entities * sum(est_prob_size))).add((num_unique_entities * num_r_types)).array())));
            current_statement_begin__ = 632;
            validate_non_negative_index("vec_1", "vec_1_size", vec_1_size);
            vec_1 = Eigen::Matrix<double, Eigen::Dynamic, 1>(vec_1_size);
            stan::math::fill(vec_1, DUMMY_VAR__);
            stan::math::assign(vec_1,rep_vector(1, vec_1_size));
            current_statement_begin__ = 634;
            validate_non_negative_index("entity_total_num_candidates", "(logical_gt(num_obs, 0) ? num_unique_entities : 0 )", (logical_gt(num_obs, 0) ? num_unique_entities : 0 ));
            entity_total_num_candidates = std::vector<int>((logical_gt(num_obs, 0) ? num_unique_entities : 0 ), int(0));
            stan::math::fill(entity_total_num_candidates, std::numeric_limits<int>::min());
            stan::math::assign(entity_total_num_candidates,calculate_entity_total_num_candidates(num_unique_entity_candidate_groups, unique_entity_candidate_groups, candidate_group_size, pstream__));
            current_statement_begin__ = 643;
            validate_non_negative_index("entity_candidate_group_ids", "sum(entity_total_num_candidates)", sum(entity_total_num_candidates));
            entity_candidate_group_ids = std::vector<int>(sum(entity_total_num_candidates), int(0));
            stan::math::fill(entity_candidate_group_ids, std::numeric_limits<int>::min());
            current_statement_begin__ = 644;
            validate_non_negative_index("entity_candidate_group_csr_row_pos", "(sum(num_unique_entity_candidate_groups) + 1)", (sum(num_unique_entity_candidate_groups) + 1));
            entity_candidate_group_csr_row_pos = std::vector<int>((sum(num_unique_entity_candidate_groups) + 1), int(0));
            stan::math::fill(entity_candidate_group_csr_row_pos, std::numeric_limits<int>::min());
            current_statement_begin__ = 646;
            validate_non_negative_index("obs_candidate_group_ids", "sum(stan::model::rvalue(candidate_group_size, stan::model::cons_list(stan::model::index_multi(obs_candidate_group), stan::model::nil_index_list()), \"candidate_group_size\"))", sum(stan::model::rvalue(candidate_group_size, stan::model::cons_list(stan::model::index_multi(obs_candidate_group), stan::model::nil_index_list()), "candidate_group_size")));
            obs_candidate_group_ids = std::vector<int>(sum(stan::model::rvalue(candidate_group_size, stan::model::cons_list(stan::model::index_multi(obs_candidate_group), stan::model::nil_index_list()), "candidate_group_size")), int(0));
            stan::math::fill(obs_candidate_group_ids, std::numeric_limits<int>::min());
            current_statement_begin__ = 647;
            validate_non_negative_index("obs_candidate_group_csr_row_pos", "(num_obs + 1)", (num_obs + 1));
            obs_candidate_group_csr_row_pos = std::vector<int>((num_obs + 1), int(0));
            stan::math::fill(obs_candidate_group_csr_row_pos, std::numeric_limits<int>::min());
            current_statement_begin__ = 649;
            validate_non_negative_index("entity_abducted_prob_ids", "(sum(abducted_prob_size) * num_unique_entities)", (sum(abducted_prob_size) * num_unique_entities));
            entity_abducted_prob_ids = std::vector<int>((sum(abducted_prob_size) * num_unique_entities), int(0));
            stan::math::fill(entity_abducted_prob_ids, std::numeric_limits<int>::min());
            current_statement_begin__ = 650;
            validate_non_negative_index("entity_abducted_prob_csr_row_pos", "(num_abducted_estimands ? ((num_unique_entities * num_abducted_estimands) + 1) : 0 )", (num_abducted_estimands ? ((num_unique_entities * num_abducted_estimands) + 1) : 0 ));
            entity_abducted_prob_csr_row_pos = std::vector<int>((num_abducted_estimands ? ((num_unique_entities * num_abducted_estimands) + 1) : 0 ), int(0));
            stan::math::fill(entity_abducted_prob_csr_row_pos, std::numeric_limits<int>::min());
            current_statement_begin__ = 652;
            validate_non_negative_index("long_entity_abducted_index", "(num_unique_entities * num_abducted_estimands)", (num_unique_entities * num_abducted_estimands));
            long_entity_abducted_index = std::vector<int>((num_unique_entities * num_abducted_estimands), int(0));
            stan::math::fill(long_entity_abducted_index, std::numeric_limits<int>::min());
            current_statement_begin__ = 654;
            validate_non_negative_index("entity_est_prob_ids", "(sum(est_prob_size) * num_unique_entities)", (sum(est_prob_size) * num_unique_entities));
            entity_est_prob_ids = std::vector<int>((sum(est_prob_size) * num_unique_entities), int(0));
            stan::math::fill(entity_est_prob_ids, std::numeric_limits<int>::min());
            current_statement_begin__ = 655;
            validate_non_negative_index("entity_est_prob_csr_row_pos", "(logical_gt(num_atom_estimands, 0) ? ((num_unique_entities * num_atom_estimands) + 1) : 0 )", (logical_gt(num_atom_estimands, 0) ? ((num_unique_entities * num_atom_estimands) + 1) : 0 ));
            entity_est_prob_csr_row_pos = std::vector<int>((logical_gt(num_atom_estimands, 0) ? ((num_unique_entities * num_atom_estimands) + 1) : 0 ), int(0));
            stan::math::fill(entity_est_prob_csr_row_pos, std::numeric_limits<int>::min());
            current_statement_begin__ = 657;
            validate_non_negative_index("entity_diff_estimand_ids", "((num_diff_estimands * 2) * num_unique_entities)", ((num_diff_estimands * 2) * num_unique_entities));
            entity_diff_estimand_ids = std::vector<int>(((num_diff_estimands * 2) * num_unique_entities), int(0));
            stan::math::fill(entity_diff_estimand_ids, std::numeric_limits<int>::min());
            current_statement_begin__ = 658;
            validate_non_negative_index("entity_diff_estimand_csr_row_pos", "(logical_gt(num_diff_estimands, 0) ? ((num_unique_entities * num_diff_estimands) + 1) : 0 )", (logical_gt(num_diff_estimands, 0) ? ((num_unique_entities * num_diff_estimands) + 1) : 0 ));
            entity_diff_estimand_csr_row_pos = std::vector<int>((logical_gt(num_diff_estimands, 0) ? ((num_unique_entities * num_diff_estimands) + 1) : 0 ), int(0));
            stan::math::fill(entity_diff_estimand_csr_row_pos, std::numeric_limits<int>::min());
            current_statement_begin__ = 660;
            validate_non_negative_index("entity_mean_diff_estimand_ids", "((num_mean_diff_estimands * 2) * num_unique_entities)", ((num_mean_diff_estimands * 2) * num_unique_entities));
            entity_mean_diff_estimand_ids = std::vector<int>(((num_mean_diff_estimands * 2) * num_unique_entities), int(0));
            stan::math::fill(entity_mean_diff_estimand_ids, std::numeric_limits<int>::min());
            current_statement_begin__ = 661;
            validate_non_negative_index("entity_mean_diff_estimand_csr_row_pos", "(logical_gt(num_mean_diff_estimands, 0) ? ((num_unique_entities * num_mean_diff_estimands) + 1) : 0 )", (logical_gt(num_mean_diff_estimands, 0) ? ((num_unique_entities * num_mean_diff_estimands) + 1) : 0 ));
            entity_mean_diff_estimand_csr_row_pos = std::vector<int>((logical_gt(num_mean_diff_estimands, 0) ? ((num_unique_entities * num_mean_diff_estimands) + 1) : 0 ), int(0));
            stan::math::fill(entity_mean_diff_estimand_csr_row_pos, std::numeric_limits<int>::min());
            current_statement_begin__ = 663;
            validate_non_negative_index("entity_utility_diff_estimand_ids", "((num_utility_diff_estimands * 2) * num_unique_entities)", ((num_utility_diff_estimands * 2) * num_unique_entities));
            entity_utility_diff_estimand_ids = std::vector<int>(((num_utility_diff_estimands * 2) * num_unique_entities), int(0));
            stan::math::fill(entity_utility_diff_estimand_ids, std::numeric_limits<int>::min());
            current_statement_begin__ = 664;
            validate_non_negative_index("entity_utility_diff_estimand_csr_row_pos", "(logical_gt(num_utility_diff_estimands, 0) ? ((num_unique_entities * num_utility_diff_estimands) + 1) : 0 )", (logical_gt(num_utility_diff_estimands, 0) ? ((num_unique_entities * num_utility_diff_estimands) + 1) : 0 ));
            entity_utility_diff_estimand_csr_row_pos = std::vector<int>((logical_gt(num_utility_diff_estimands, 0) ? ((num_unique_entities * num_utility_diff_estimands) + 1) : 0 ), int(0));
            stan::math::fill(entity_utility_diff_estimand_csr_row_pos, std::numeric_limits<int>::min());
            current_statement_begin__ = 666;
            total_num_bg_variable_types = int(0);
            stan::math::fill(total_num_bg_variable_types, std::numeric_limits<int>::min());
            stan::math::assign(total_num_bg_variable_types,sum(num_bg_variable_types));
            current_statement_begin__ = 668;
            validate_non_negative_index("marginal_prob_csr_vec", "(sum(num_bg_variable_type_combo_members) * num_unique_entities)", (sum(num_bg_variable_type_combo_members) * num_unique_entities));
            marginal_prob_csr_vec = Eigen::Matrix<double, Eigen::Dynamic, 1>((sum(num_bg_variable_type_combo_members) * num_unique_entities));
            stan::math::fill(marginal_prob_csr_vec, DUMMY_VAR__);
            current_statement_begin__ = 669;
            validate_non_negative_index("entity_marginal_prob_ids", "(sum(num_bg_variable_type_combo_members) * num_unique_entities)", (sum(num_bg_variable_type_combo_members) * num_unique_entities));
            entity_marginal_prob_ids = std::vector<int>((sum(num_bg_variable_type_combo_members) * num_unique_entities), int(0));
            stan::math::fill(entity_marginal_prob_ids, std::numeric_limits<int>::min());
            current_statement_begin__ = 670;
            validate_non_negative_index("entity_marginal_prob_csr_row_pos", "(total_num_bg_variable_types + 1)", (total_num_bg_variable_types + 1));
            entity_marginal_prob_csr_row_pos = std::vector<int>((total_num_bg_variable_types + 1), int(0));
            stan::math::fill(entity_marginal_prob_csr_row_pos, std::numeric_limits<int>::min());
            current_statement_begin__ = 672;
            validate_non_negative_index("level_estimands_csr_vec", "((num_all_estimands * num_unique_entities) * num_estimand_levels)", ((num_all_estimands * num_unique_entities) * num_estimand_levels));
            level_estimands_csr_vec = Eigen::Matrix<double, Eigen::Dynamic, 1>(((num_all_estimands * num_unique_entities) * num_estimand_levels));
            stan::math::fill(level_estimands_csr_vec, DUMMY_VAR__);
            current_statement_begin__ = 673;
            validate_non_negative_index("entity_estimand_ids", "((num_all_estimands * num_unique_entities) * num_estimand_levels)", ((num_all_estimands * num_unique_entities) * num_estimand_levels));
            entity_estimand_ids = std::vector<int>(((num_all_estimands * num_unique_entities) * num_estimand_levels), int(0));
            stan::math::fill(entity_estimand_ids, std::numeric_limits<int>::min());
            current_statement_begin__ = 674;
            validate_non_negative_index("entity_estimand_csr_row_pos", "(logical_gt(num_estimand_levels, 0) ? ((num_all_estimands * sum(stan::model::rvalue(level_size, stan::model::cons_list(stan::model::index_multi(estimand_levels), stan::model::nil_index_list()), \"level_size\"))) + 1) : 0 )", (logical_gt(num_estimand_levels, 0) ? ((num_all_estimands * sum(stan::model::rvalue(level_size, stan::model::cons_list(stan::model::index_multi(estimand_levels), stan::model::nil_index_list()), "level_size"))) + 1) : 0 ));
            entity_estimand_csr_row_pos = std::vector<int>((logical_gt(num_estimand_levels, 0) ? ((num_all_estimands * sum(stan::model::rvalue(level_size, stan::model::cons_list(stan::model::index_multi(estimand_levels), stan::model::nil_index_list()), "level_size"))) + 1) : 0 ), int(0));
            stan::math::fill(entity_estimand_csr_row_pos, std::numeric_limits<int>::min());
            current_statement_begin__ = 676;
            validate_non_negative_index("entity_histogram_vec", "((num_discretized_groups * ((2 * num_discretized_variables) + 1)) * num_unique_entities)", ((num_discretized_groups * ((2 * num_discretized_variables) + 1)) * num_unique_entities));
            entity_histogram_vec = Eigen::Matrix<double, Eigen::Dynamic, 1>(((num_discretized_groups * ((2 * num_discretized_variables) + 1)) * num_unique_entities));
            stan::math::fill(entity_histogram_vec, DUMMY_VAR__);
            current_statement_begin__ = 677;
            validate_non_negative_index("entity_histogram_ids", "((num_discretized_groups * ((2 * num_discretized_variables) + 1)) * num_unique_entities)", ((num_discretized_groups * ((2 * num_discretized_variables) + 1)) * num_unique_entities));
            entity_histogram_ids = std::vector<int>(((num_discretized_groups * ((2 * num_discretized_variables) + 1)) * num_unique_entities), int(0));
            stan::math::fill(entity_histogram_ids, std::numeric_limits<int>::min());
            current_statement_begin__ = 678;
            validate_non_negative_index("entity_histogram_csr_row_pos", "(logical_gt(num_discretized_groups, 0) ? (((num_discretized_groups * (num_cutpoints - 1)) * num_unique_entities) + 1) : 0 )", (logical_gt(num_discretized_groups, 0) ? (((num_discretized_groups * (num_cutpoints - 1)) * num_unique_entities) + 1) : 0 ));
            entity_histogram_csr_row_pos = std::vector<int>((logical_gt(num_discretized_groups, 0) ? (((num_discretized_groups * (num_cutpoints - 1)) * num_unique_entities) + 1) : 0 ), int(0));
            stan::math::fill(entity_histogram_csr_row_pos, std::numeric_limits<int>::min());
            current_statement_begin__ = 680;
            validate_non_negative_index("entity_midpoint_vec", "((num_discretized_groups * (num_cutpoints - 1)) * num_unique_entities)", ((num_discretized_groups * (num_cutpoints - 1)) * num_unique_entities));
            entity_midpoint_vec = Eigen::Matrix<double, Eigen::Dynamic, 1>(((num_discretized_groups * (num_cutpoints - 1)) * num_unique_entities));
            stan::math::fill(entity_midpoint_vec, DUMMY_VAR__);
            current_statement_begin__ = 681;
            validate_non_negative_index("entity_midpoint_ids", "((num_discretized_groups * (num_cutpoints - 1)) * num_unique_entities)", ((num_discretized_groups * (num_cutpoints - 1)) * num_unique_entities));
            entity_midpoint_ids = std::vector<int>(((num_discretized_groups * (num_cutpoints - 1)) * num_unique_entities), int(0));
            stan::math::fill(entity_midpoint_ids, std::numeric_limits<int>::min());
            current_statement_begin__ = 682;
            validate_non_negative_index("entity_midpoint_csr_row_pos", "(logical_gt(num_discretized_groups, 0) ? ((num_discretized_groups * num_unique_entities) + 1) : 0 )", (logical_gt(num_discretized_groups, 0) ? ((num_discretized_groups * num_unique_entities) + 1) : 0 ));
            entity_midpoint_csr_row_pos = std::vector<int>((logical_gt(num_discretized_groups, 0) ? ((num_discretized_groups * num_unique_entities) + 1) : 0 ), int(0));
            stan::math::fill(entity_midpoint_csr_row_pos, std::numeric_limits<int>::min());
            current_statement_begin__ = 684;
            validate_non_negative_index("entity_utility_vec", "(logical_gt(num_discrete_utility_values, 0) ? ((num_discretized_groups * (num_cutpoints - 1)) * num_unique_entities) : 0 )", (logical_gt(num_discrete_utility_values, 0) ? ((num_discretized_groups * (num_cutpoints - 1)) * num_unique_entities) : 0 ));
            entity_utility_vec = Eigen::Matrix<double, Eigen::Dynamic, 1>((logical_gt(num_discrete_utility_values, 0) ? ((num_discretized_groups * (num_cutpoints - 1)) * num_unique_entities) : 0 ));
            stan::math::fill(entity_utility_vec, DUMMY_VAR__);
            current_statement_begin__ = 686;
            validate_non_negative_index("between_entity_diff_csr_vec", "((2 * num_atom_estimands) * (sum(stan::model::rvalue(level_size, stan::model::cons_list(stan::model::index_multi(between_entity_diff_levels), stan::model::nil_index_list()), \"level_size\")) - num_between_entity_diff_levels))", ((2 * num_atom_estimands) * (sum(stan::model::rvalue(level_size, stan::model::cons_list(stan::model::index_multi(between_entity_diff_levels), stan::model::nil_index_list()), "level_size")) - num_between_entity_diff_levels)));
            between_entity_diff_csr_vec = Eigen::Matrix<double, Eigen::Dynamic, 1>(((2 * num_atom_estimands) * (sum(stan::model::rvalue(level_size, stan::model::cons_list(stan::model::index_multi(between_entity_diff_levels), stan::model::nil_index_list()), "level_size")) - num_between_entity_diff_levels)));
            stan::math::fill(between_entity_diff_csr_vec, DUMMY_VAR__);
            stan::math::assign(between_entity_diff_csr_vec,to_vector(rep_matrix(transpose(stan::math::to_row_vector(stan::math::array_builder<double >().add(-(1)).add(1).array())), (num_atom_estimands * (sum(stan::model::rvalue(level_size, stan::model::cons_list(stan::model::index_multi(between_entity_diff_levels), stan::model::nil_index_list()), "level_size")) - num_between_entity_diff_levels)))));
            current_statement_begin__ = 688;
            validate_non_negative_index("between_entity_diff_csr_ids", "((2 * num_atom_estimands) * (sum(stan::model::rvalue(level_size, stan::model::cons_list(stan::model::index_multi(between_entity_diff_levels), stan::model::nil_index_list()), \"level_size\")) - num_between_entity_diff_levels))", ((2 * num_atom_estimands) * (sum(stan::model::rvalue(level_size, stan::model::cons_list(stan::model::index_multi(between_entity_diff_levels), stan::model::nil_index_list()), "level_size")) - num_between_entity_diff_levels)));
            between_entity_diff_csr_ids = std::vector<int>(((2 * num_atom_estimands) * (sum(stan::model::rvalue(level_size, stan::model::cons_list(stan::model::index_multi(between_entity_diff_levels), stan::model::nil_index_list()), "level_size")) - num_between_entity_diff_levels)), int(0));
            stan::math::fill(between_entity_diff_csr_ids, std::numeric_limits<int>::min());
            current_statement_begin__ = 689;
            validate_non_negative_index("between_entity_diff_csr_row_pos", "(logical_gt(num_between_entity_diff_levels, 0) ? ((num_atom_estimands * (sum(stan::model::rvalue(level_size, stan::model::cons_list(stan::model::index_multi(between_entity_diff_levels), stan::model::nil_index_list()), \"level_size\")) - num_between_entity_diff_levels)) + 1) : 0 )", (logical_gt(num_between_entity_diff_levels, 0) ? ((num_atom_estimands * (sum(stan::model::rvalue(level_size, stan::model::cons_list(stan::model::index_multi(between_entity_diff_levels), stan::model::nil_index_list()), "level_size")) - num_between_entity_diff_levels)) + 1) : 0 ));
            between_entity_diff_csr_row_pos = std::vector<int>((logical_gt(num_between_entity_diff_levels, 0) ? ((num_atom_estimands * (sum(stan::model::rvalue(level_size, stan::model::cons_list(stan::model::index_multi(between_entity_diff_levels), stan::model::nil_index_list()), "level_size")) - num_between_entity_diff_levels)) + 1) : 0 ), int(0));
            stan::math::fill(between_entity_diff_csr_row_pos, std::numeric_limits<int>::min());
            current_statement_begin__ = 691;
            validate_non_negative_index("nonzero_beta_offsets", "(std::max((num_discretized_r_types - 1), 0) * num_discrete_r_types)", (std::max((num_discretized_r_types - 1), 0) * num_discrete_r_types));
            nonzero_beta_offsets = std::vector<int>((std::max((num_discretized_r_types - 1), 0) * num_discrete_r_types), int(0));
            stan::math::fill(nonzero_beta_offsets, std::numeric_limits<int>::min());
            // execute transformed data statements
            current_statement_begin__ = 693;
            if (as_bool(logical_gt(num_discretized_r_types, 0))) {
                {
                current_statement_begin__ = 694;
                int index_pos(0);
                (void) index_pos;  // dummy to suppress unused var warning
                stan::math::fill(index_pos, std::numeric_limits<int>::min());
                stan::math::assign(index_pos,1);
                current_statement_begin__ = 695;
                for (int offset_index = 2; offset_index <= (num_discretized_r_types * num_discrete_r_types); ++offset_index) {
                    current_statement_begin__ = 696;
                    if (as_bool(logical_neq(modulus(offset_index, num_discretized_r_types), 1))) {
                        current_statement_begin__ = 697;
                        stan::model::assign(nonzero_beta_offsets, 
                                    stan::model::cons_list(stan::model::index_uni(index_pos), stan::model::nil_index_list()), 
                                    offset_index, 
                                    "assigning variable nonzero_beta_offsets");
                        current_statement_begin__ = 698;
                        stan::math::assign(index_pos, (index_pos + 1));
                    }
                }
                }
            }
            current_statement_begin__ = 708;
            for (int cutpoint_index = 2; cutpoint_index <= num_cutpoints; ++cutpoint_index) {
                current_statement_begin__ = 709;
                stan::model::assign(cutpoint_midpoints, 
                            stan::model::cons_list(stan::model::index_uni((cutpoint_index - 1)), stan::model::nil_index_list()), 
                            mean(stan::model::rvalue(cutpoints, stan::model::cons_list(stan::model::index_min_max((cutpoint_index - 1), cutpoint_index), stan::model::nil_index_list()), "cutpoints")), 
                            "assigning variable cutpoint_midpoints");
                current_statement_begin__ = 711;
                stan::model::assign(discretized_binwidth, 
                            stan::model::cons_list(stan::model::index_uni((cutpoint_index - 1)), stan::model::nil_index_list()), 
                            (get_base1(cutpoints, cutpoint_index, "cutpoints", 1) - get_base1(cutpoints, (cutpoint_index - 1), "cutpoints", 1)), 
                            "assigning variable discretized_binwidth");
                current_statement_begin__ = 713;
                stan::model::assign(discretize_bin_alpha, 
                            stan::model::cons_list(stan::model::index_uni((cutpoint_index - 1)), stan::model::nil_index_list()), 
                            get_base1(cutpoints, (cutpoint_index - 1), "cutpoints", 1), 
                            "assigning variable discretize_bin_alpha");
                current_statement_begin__ = 714;
                stan::model::assign(discretize_bin_beta, 
                            stan::model::cons_list(stan::model::index_uni((cutpoint_index - 1)), stan::model::nil_index_list()), 
                            get_base1(cutpoints, cutpoint_index, "cutpoints", 1), 
                            "assigning variable discretize_bin_beta");
            }
            current_statement_begin__ = 722;
            for (int level_index = 1; level_index <= num_levels; ++level_index) {
                current_statement_begin__ = 723;
                stan::model::assign(unique_entities_in_level_entities, 
                            stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(level_index), stan::model::nil_index_list())), 
                            sort_indices_asc(stan::model::rvalue(unique_entity_ids, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(level_index), stan::model::nil_index_list())), "unique_entity_ids")), 
                            "assigning variable unique_entities_in_level_entities");
            }
            current_statement_begin__ = 732;
            if (as_bool(logical_gt(num_abducted_estimands, 0))) {
                current_statement_begin__ = 733;
                stan::math::assign(entity_abducted_prob_ids, csr_shift_expand_v(abducted_prob_index, num_r_types_full, num_unique_entities, pstream__));
                current_statement_begin__ = 734;
                stan::math::assign(entity_abducted_prob_csr_row_pos, csr_shift_expand_u(abducted_prob_size, num_unique_entities, pstream__));
            }
            current_statement_begin__ = 737;
            if (as_bool(logical_gt(num_atom_estimands, 0))) {
                current_statement_begin__ = 738;
                stan::math::assign(entity_est_prob_ids, csr_shift_expand_v(est_prob_index, num_r_types_full, num_unique_entities, pstream__));
                current_statement_begin__ = 739;
                stan::math::assign(entity_est_prob_csr_row_pos, csr_shift_expand_u(est_prob_size, num_unique_entities, pstream__));
            }
            current_statement_begin__ = 742;
            if (as_bool(logical_gt(num_diff_estimands, 0))) {
                current_statement_begin__ = 743;
                stan::math::assign(entity_diff_estimand_ids, csr_shift_expand_v(diff_estimand_atoms, num_atom_estimands, num_unique_entities, pstream__));
                current_statement_begin__ = 744;
                stan::math::assign(entity_diff_estimand_csr_row_pos, csr_shift_expand_u(rep_array(2, num_diff_estimands), num_unique_entities, pstream__));
            }
            current_statement_begin__ = 747;
            if (as_bool(logical_gt(num_mean_diff_estimands, 0))) {
                current_statement_begin__ = 748;
                stan::math::assign(entity_mean_diff_estimand_ids, csr_shift_expand_v(mean_diff_estimand_atoms, num_discretized_groups, num_unique_entities, pstream__));
                current_statement_begin__ = 749;
                stan::math::assign(entity_mean_diff_estimand_csr_row_pos, csr_shift_expand_u(rep_array(2, num_mean_diff_estimands), num_unique_entities, pstream__));
            }
            current_statement_begin__ = 752;
            if (as_bool(logical_gt(num_utility_diff_estimands, 0))) {
                current_statement_begin__ = 753;
                stan::math::assign(entity_utility_diff_estimand_ids, csr_shift_expand_v(utility_diff_estimand_atoms, num_discretized_groups, num_unique_entities, pstream__));
                current_statement_begin__ = 754;
                stan::math::assign(entity_utility_diff_estimand_csr_row_pos, csr_shift_expand_u(rep_array(2, num_utility_diff_estimands), num_unique_entities, pstream__));
            }
            current_statement_begin__ = 757;
            if (as_bool(logical_gt(num_obs, 0))) {
                {
                current_statement_begin__ = 759;
                int entity_candidate_group_pos(0);
                (void) entity_candidate_group_pos;  // dummy to suppress unused var warning
                stan::math::fill(entity_candidate_group_pos, std::numeric_limits<int>::min());
                stan::math::assign(entity_candidate_group_pos,1);
                current_statement_begin__ = 760;
                int entity_candidate_pos(0);
                (void) entity_candidate_pos;  // dummy to suppress unused var warning
                stan::math::fill(entity_candidate_pos, std::numeric_limits<int>::min());
                stan::math::assign(entity_candidate_pos,1);
                current_statement_begin__ = 761;
                int entity_candidate_group_csr_row_pos_pos(0);
                (void) entity_candidate_group_csr_row_pos_pos;  // dummy to suppress unused var warning
                stan::math::fill(entity_candidate_group_csr_row_pos_pos, std::numeric_limits<int>::min());
                stan::math::assign(entity_candidate_group_csr_row_pos_pos,1);
                current_statement_begin__ = 762;
                int last_candidate_group_size(0);
                (void) last_candidate_group_size;  // dummy to suppress unused var warning
                stan::math::fill(last_candidate_group_size, std::numeric_limits<int>::min());
                current_statement_begin__ = 764;
                int long_entity_abducted_index_pos(0);
                (void) long_entity_abducted_index_pos;  // dummy to suppress unused var warning
                stan::math::fill(long_entity_abducted_index_pos, std::numeric_limits<int>::min());
                stan::math::assign(long_entity_abducted_index_pos,1);
                current_statement_begin__ = 766;
                for (int entity_index = 1; entity_index <= num_unique_entities; ++entity_index) {
                    {
                    current_statement_begin__ = 767;
                    int num_entity_candidate_groups(0);
                    (void) num_entity_candidate_groups;  // dummy to suppress unused var warning
                    stan::math::fill(num_entity_candidate_groups, std::numeric_limits<int>::min());
                    stan::math::assign(num_entity_candidate_groups,get_base1(num_unique_entity_candidate_groups, entity_index, "num_unique_entity_candidate_groups", 1));
                    current_statement_begin__ = 768;
                    int entity_candidate_group_end(0);
                    (void) entity_candidate_group_end;  // dummy to suppress unused var warning
                    stan::math::fill(entity_candidate_group_end, std::numeric_limits<int>::min());
                    stan::math::assign(entity_candidate_group_end,((entity_candidate_group_pos + num_entity_candidate_groups) - 1));
                    current_statement_begin__ = 770;
                    validate_non_negative_index("curr_candidate_groups", "num_entity_candidate_groups", num_entity_candidate_groups);
                    std::vector<int  > curr_candidate_groups(num_entity_candidate_groups, int(0));
                    stan::math::fill(curr_candidate_groups, std::numeric_limits<int>::min());
                    stan::math::assign(curr_candidate_groups,stan::model::rvalue(unique_entity_candidate_groups, stan::model::cons_list(stan::model::index_min_max(entity_candidate_group_pos, entity_candidate_group_end), stan::model::nil_index_list()), "unique_entity_candidate_groups"));
                    current_statement_begin__ = 772;
                    stan::model::assign(num_obs_in_unique_entity, 
                                stan::model::cons_list(stan::model::index_uni(entity_index), stan::model::nil_index_list()), 
                                num_equals(obs_unique_entity_id, static_cast<std::vector<int> >(stan::math::array_builder<int >().add(entity_index).array()), pstream__), 
                                "assigning variable num_obs_in_unique_entity");
                    current_statement_begin__ = 776;
                    for (int candidate_group_index = 1; candidate_group_index <= num_entity_candidate_groups; ++candidate_group_index) {
                        {
                        current_statement_begin__ = 777;
                        int curr_candidate_group(0);
                        (void) curr_candidate_group;  // dummy to suppress unused var warning
                        stan::math::fill(curr_candidate_group, std::numeric_limits<int>::min());
                        stan::math::assign(curr_candidate_group,get_base1(curr_candidate_groups, candidate_group_index, "curr_candidate_groups", 1));
                        current_statement_begin__ = 778;
                        int candidate_pos(0);
                        (void) candidate_pos;  // dummy to suppress unused var warning
                        stan::math::fill(candidate_pos, std::numeric_limits<int>::min());
                        stan::math::assign(candidate_pos,(logical_gt(curr_candidate_group, 1) ? (sum(stan::model::rvalue(candidate_group_size, stan::model::cons_list(stan::model::index_min_max(1, (curr_candidate_group - 1)), stan::model::nil_index_list()), "candidate_group_size")) + 1) : 1 ));
                        current_statement_begin__ = 779;
                        int candidate_end(0);
                        (void) candidate_end;  // dummy to suppress unused var warning
                        stan::math::fill(candidate_end, std::numeric_limits<int>::min());
                        stan::math::assign(candidate_end,sum(stan::model::rvalue(candidate_group_size, stan::model::cons_list(stan::model::index_min_max(1, curr_candidate_group), stan::model::nil_index_list()), "candidate_group_size")));
                        current_statement_begin__ = 781;
                        int entity_candidate_end(0);
                        (void) entity_candidate_end;  // dummy to suppress unused var warning
                        stan::math::fill(entity_candidate_end, std::numeric_limits<int>::min());
                        stan::math::assign(entity_candidate_end,((entity_candidate_pos + get_base1(candidate_group_size, curr_candidate_group, "candidate_group_size", 1)) - 1));
                        current_statement_begin__ = 783;
                        stan::model::assign(entity_candidate_group_ids, 
                                    stan::model::cons_list(stan::model::index_min_max(entity_candidate_pos, entity_candidate_end), stan::model::nil_index_list()), 
                                    array_add(stan::model::rvalue(candidate_group_ids, stan::model::cons_list(stan::model::index_min_max(candidate_pos, candidate_end), stan::model::nil_index_list()), "candidate_group_ids"), static_cast<std::vector<int> >(stan::math::array_builder<int >().add(((entity_index - 1) * num_r_types)).array()), pstream__), 
                                    "assigning variable entity_candidate_group_ids");
                        current_statement_begin__ = 785;
                        stan::model::assign(entity_candidate_group_csr_row_pos, 
                                    stan::model::cons_list(stan::model::index_uni(entity_candidate_group_csr_row_pos_pos), stan::model::nil_index_list()), 
                                    (logical_gt(entity_candidate_group_csr_row_pos_pos, 1) ? (get_base1(entity_candidate_group_csr_row_pos, (entity_candidate_group_csr_row_pos_pos - 1), "entity_candidate_group_csr_row_pos", 1) + last_candidate_group_size) : 1 ), 
                                    "assigning variable entity_candidate_group_csr_row_pos");
                        current_statement_begin__ = 789;
                        stan::math::assign(last_candidate_group_size, get_base1(stan::model::rvalue(candidate_group_size, stan::model::cons_list(stan::model::index_multi(curr_candidate_groups), stan::model::nil_index_list()), "candidate_group_size"), candidate_group_index, "stan::model::rvalue(candidate_group_size, stan::model::cons_list(stan::model::index_multi(curr_candidate_groups), stan::model::nil_index_list()), \"candidate_group_size\")", 1));
                        current_statement_begin__ = 791;
                        stan::math::assign(entity_candidate_pos, (entity_candidate_end + 1));
                        current_statement_begin__ = 792;
                        stan::math::assign(entity_candidate_group_csr_row_pos_pos, (entity_candidate_group_csr_row_pos_pos + 1));
                        }
                    }
                    current_statement_begin__ = 795;
                    stan::model::assign(entity_candidate_group_csr_row_pos, 
                                stan::model::cons_list(stan::model::index_uni(entity_candidate_group_csr_row_pos_pos), stan::model::nil_index_list()), 
                                (get_base1(entity_candidate_group_csr_row_pos, (entity_candidate_group_csr_row_pos_pos - 1), "entity_candidate_group_csr_row_pos", 1) + last_candidate_group_size), 
                                "assigning variable entity_candidate_group_csr_row_pos");
                    current_statement_begin__ = 797;
                    stan::math::assign(entity_candidate_group_pos, (entity_candidate_group_end + 1));
                    current_statement_begin__ = 799;
                    if (as_bool(logical_gt(num_abducted_estimands, 0))) {
                        {
                        current_statement_begin__ = 800;
                        int long_entity_abducted_index_end(0);
                        (void) long_entity_abducted_index_end;  // dummy to suppress unused var warning
                        stan::math::fill(long_entity_abducted_index_end, std::numeric_limits<int>::min());
                        stan::math::assign(long_entity_abducted_index_end,((long_entity_abducted_index_pos + num_abducted_estimands) - 1));
                        current_statement_begin__ = 802;
                        stan::model::assign(long_entity_abducted_index, 
                                    stan::model::cons_list(stan::model::index_min_max(long_entity_abducted_index_pos, long_entity_abducted_index_end), stan::model::nil_index_list()), 
                                    array_add(abducted_estimand_ids, static_cast<std::vector<int> >(stan::math::array_builder<int >().add(((entity_index - 1) * num_atom_estimands)).array()), pstream__), 
                                    "assigning variable long_entity_abducted_index");
                        current_statement_begin__ = 804;
                        stan::math::assign(long_entity_abducted_index_pos, (long_entity_abducted_index_end + 1));
                        }
                    }
                    }
                }
                }
                {
                current_statement_begin__ = 810;
                int obs_candidate_pos(0);
                (void) obs_candidate_pos;  // dummy to suppress unused var warning
                stan::math::fill(obs_candidate_pos, std::numeric_limits<int>::min());
                stan::math::assign(obs_candidate_pos,1);
                current_statement_begin__ = 811;
                int last_candidate_group_size(0);
                (void) last_candidate_group_size;  // dummy to suppress unused var warning
                stan::math::fill(last_candidate_group_size, std::numeric_limits<int>::min());
                current_statement_begin__ = 813;
                for (int obs_index = 1; obs_index <= num_obs; ++obs_index) {
                    {
                    current_statement_begin__ = 814;
                    int entity_index(0);
                    (void) entity_index;  // dummy to suppress unused var warning
                    stan::math::fill(entity_index, std::numeric_limits<int>::min());
                    stan::math::assign(entity_index,get_base1(obs_unique_entity_id, obs_index, "obs_unique_entity_id", 1));
                    current_statement_begin__ = 815;
                    int obs_candidate_end(0);
                    (void) obs_candidate_end;  // dummy to suppress unused var warning
                    stan::math::fill(obs_candidate_end, std::numeric_limits<int>::min());
                    stan::math::assign(obs_candidate_end,((obs_candidate_pos + get_base1(candidate_group_size, get_base1(obs_candidate_group, obs_index, "obs_candidate_group", 1), "candidate_group_size", 1)) - 1));
                    current_statement_begin__ = 817;
                    int curr_candidate_group(0);
                    (void) curr_candidate_group;  // dummy to suppress unused var warning
                    stan::math::fill(curr_candidate_group, std::numeric_limits<int>::min());
                    stan::math::assign(curr_candidate_group,get_base1(obs_candidate_group, obs_index, "obs_candidate_group", 1));
                    current_statement_begin__ = 819;
                    int candidate_pos(0);
                    (void) candidate_pos;  // dummy to suppress unused var warning
                    stan::math::fill(candidate_pos, std::numeric_limits<int>::min());
                    stan::math::assign(candidate_pos,(logical_gt(curr_candidate_group, 1) ? (sum(stan::model::rvalue(candidate_group_size, stan::model::cons_list(stan::model::index_min_max(1, (curr_candidate_group - 1)), stan::model::nil_index_list()), "candidate_group_size")) + 1) : 1 ));
                    current_statement_begin__ = 820;
                    int candidate_end(0);
                    (void) candidate_end;  // dummy to suppress unused var warning
                    stan::math::fill(candidate_end, std::numeric_limits<int>::min());
                    stan::math::assign(candidate_end,sum(stan::model::rvalue(candidate_group_size, stan::model::cons_list(stan::model::index_min_max(1, curr_candidate_group), stan::model::nil_index_list()), "candidate_group_size")));
                    current_statement_begin__ = 822;
                    stan::model::assign(obs_candidate_group_ids, 
                                stan::model::cons_list(stan::model::index_min_max(obs_candidate_pos, obs_candidate_end), stan::model::nil_index_list()), 
                                array_add(stan::model::rvalue(candidate_group_ids, stan::model::cons_list(stan::model::index_min_max(candidate_pos, candidate_end), stan::model::nil_index_list()), "candidate_group_ids"), static_cast<std::vector<int> >(stan::math::array_builder<int >().add(((entity_index - 1) * num_r_types)).array()), pstream__), 
                                "assigning variable obs_candidate_group_ids");
                    current_statement_begin__ = 824;
                    stan::model::assign(obs_candidate_group_csr_row_pos, 
                                stan::model::cons_list(stan::model::index_uni(obs_index), stan::model::nil_index_list()), 
                                (logical_gt(obs_index, 1) ? (get_base1(obs_candidate_group_csr_row_pos, (obs_index - 1), "obs_candidate_group_csr_row_pos", 1) + last_candidate_group_size) : 1 ), 
                                "assigning variable obs_candidate_group_csr_row_pos");
                    current_statement_begin__ = 826;
                    stan::math::assign(last_candidate_group_size, get_base1(candidate_group_size, curr_candidate_group, "candidate_group_size", 1));
                    current_statement_begin__ = 828;
                    stan::math::assign(obs_candidate_pos, (obs_candidate_end + 1));
                    }
                }
                current_statement_begin__ = 831;
                stan::model::assign(obs_candidate_group_csr_row_pos, 
                            stan::model::cons_list(stan::model::index_uni((num_obs + 1)), stan::model::nil_index_list()), 
                            (get_base1(obs_candidate_group_csr_row_pos, num_obs, "obs_candidate_group_csr_row_pos", 1) + last_candidate_group_size), 
                            "assigning variable obs_candidate_group_csr_row_pos");
                current_statement_begin__ = 833;
                stan::math::assign(unique_entity_prop, divide(num_obs_in_unique_entity, num_obs));
                }
            } else {
                current_statement_begin__ = 836;
                stan::model::assign(obs_candidate_group_csr_row_pos, 
                            stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list()), 
                            1, 
                            "assigning variable obs_candidate_group_csr_row_pos");
                current_statement_begin__ = 838;
                stan::math::assign(unique_entity_prop, rep_vector((1.0 / num_unique_entities), num_unique_entities));
                current_statement_begin__ = 840;
                stan::model::assign(entity_candidate_group_csr_row_pos, 
                            stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list()), 
                            1, 
                            "assigning variable entity_candidate_group_csr_row_pos");
                current_statement_begin__ = 842;
                stan::math::assign(num_obs_in_unique_entity, rep_vector(0, num_unique_entities));
            }
            {
            current_statement_begin__ = 847;
            int latent_type_marginal_members_pos(0);
            (void) latent_type_marginal_members_pos;  // dummy to suppress unused var warning
            stan::math::fill(latent_type_marginal_members_pos, std::numeric_limits<int>::min());
            stan::math::assign(latent_type_marginal_members_pos,1);
            current_statement_begin__ = 848;
            int entity_marginal_prob_pos(0);
            (void) entity_marginal_prob_pos;  // dummy to suppress unused var warning
            stan::math::fill(entity_marginal_prob_pos, std::numeric_limits<int>::min());
            stan::math::assign(entity_marginal_prob_pos,1);
            current_statement_begin__ = 849;
            int entity_marginal_prob_csr_row_pos_pos(0);
            (void) entity_marginal_prob_csr_row_pos_pos;  // dummy to suppress unused var warning
            stan::math::fill(entity_marginal_prob_csr_row_pos_pos, std::numeric_limits<int>::min());
            stan::math::assign(entity_marginal_prob_csr_row_pos_pos,1);
            current_statement_begin__ = 850;
            int last_entity_marginal_prob_size(0);
            (void) last_entity_marginal_prob_size;  // dummy to suppress unused var warning
            stan::math::fill(last_entity_marginal_prob_size, std::numeric_limits<int>::min());
            current_statement_begin__ = 852;
            for (int latent_type_index = 1; latent_type_index <= total_num_bg_variable_types; ++latent_type_index) {
                {
                current_statement_begin__ = 853;
                int curr_var_size(0);
                (void) curr_var_size;  // dummy to suppress unused var warning
                stan::math::fill(curr_var_size, std::numeric_limits<int>::min());
                stan::math::assign(curr_var_size,get_base1(num_bg_variable_type_combo_members, latent_type_index, "num_bg_variable_type_combo_members", 1));
                current_statement_begin__ = 854;
                int latent_type_marginal_members_end(0);
                (void) latent_type_marginal_members_end;  // dummy to suppress unused var warning
                stan::math::fill(latent_type_marginal_members_end, std::numeric_limits<int>::min());
                stan::math::assign(latent_type_marginal_members_end,((latent_type_marginal_members_pos + curr_var_size) - 1));
                current_statement_begin__ = 856;
                stan::model::assign(entity_marginal_prob_csr_row_pos, 
                            stan::model::cons_list(stan::model::index_uni(entity_marginal_prob_csr_row_pos_pos), stan::model::nil_index_list()), 
                            (logical_gt(entity_marginal_prob_csr_row_pos_pos, 1) ? (get_base1(entity_marginal_prob_csr_row_pos, (entity_marginal_prob_csr_row_pos_pos - 1), "entity_marginal_prob_csr_row_pos", 1) + last_entity_marginal_prob_size) : 1 ), 
                            "assigning variable entity_marginal_prob_csr_row_pos");
                current_statement_begin__ = 860;
                stan::math::assign(last_entity_marginal_prob_size, (curr_var_size * num_unique_entities));
                current_statement_begin__ = 862;
                for (int entity_index = 1; entity_index <= num_unique_entities; ++entity_index) {
                    {
                    current_statement_begin__ = 863;
                    local_scalar_t__ entity_prop(DUMMY_VAR__);
                    (void) entity_prop;  // dummy to suppress unused var warning
                    stan::math::initialize(entity_prop, DUMMY_VAR__);
                    stan::math::fill(entity_prop, DUMMY_VAR__);
                    stan::math::assign(entity_prop,(get_base1(num_obs_in_unique_entity, entity_index, "num_obs_in_unique_entity", 1) / std::max(num_obs, 1)));
                    current_statement_begin__ = 864;
                    int entity_marginal_prob_end(0);
                    (void) entity_marginal_prob_end;  // dummy to suppress unused var warning
                    stan::math::fill(entity_marginal_prob_end, std::numeric_limits<int>::min());
                    stan::math::assign(entity_marginal_prob_end,((entity_marginal_prob_pos + curr_var_size) - 1));
                    current_statement_begin__ = 866;
                    stan::model::assign(marginal_prob_csr_vec, 
                                stan::model::cons_list(stan::model::index_min_max(entity_marginal_prob_pos, entity_marginal_prob_end), stan::model::nil_index_list()), 
                                rep_vector(entity_prop, curr_var_size), 
                                "assigning variable marginal_prob_csr_vec");
                    current_statement_begin__ = 868;
                    stan::model::assign(entity_marginal_prob_ids, 
                                stan::model::cons_list(stan::model::index_min_max(entity_marginal_prob_pos, entity_marginal_prob_end), stan::model::nil_index_list()), 
                                array_add(stan::model::rvalue(bg_variable_type_combo_members, stan::model::cons_list(stan::model::index_min_max(latent_type_marginal_members_pos, latent_type_marginal_members_end), stan::model::nil_index_list()), "bg_variable_type_combo_members"), static_cast<std::vector<int> >(stan::math::array_builder<int >().add(((entity_index - 1) * num_r_types)).array()), pstream__), 
                                "assigning variable entity_marginal_prob_ids");
                    current_statement_begin__ = 871;
                    stan::math::assign(entity_marginal_prob_pos, (entity_marginal_prob_end + 1));
                    }
                }
                current_statement_begin__ = 874;
                stan::math::assign(latent_type_marginal_members_pos, (latent_type_marginal_members_end + 1));
                current_statement_begin__ = 875;
                stan::math::assign(entity_marginal_prob_csr_row_pos_pos, (entity_marginal_prob_csr_row_pos_pos + 1));
                }
            }
            current_statement_begin__ = 878;
            stan::model::assign(entity_marginal_prob_csr_row_pos, 
                        stan::model::cons_list(stan::model::index_uni(entity_marginal_prob_csr_row_pos_pos), stan::model::nil_index_list()), 
                        (get_base1(entity_marginal_prob_csr_row_pos, (entity_marginal_prob_csr_row_pos_pos - 1), "entity_marginal_prob_csr_row_pos", 1) + last_entity_marginal_prob_size), 
                        "assigning variable entity_marginal_prob_csr_row_pos");
            }
            current_statement_begin__ = 881;
            if (as_bool(logical_gt(num_estimand_levels, 0))) {
                {
                current_statement_begin__ = 882;
                int estimand_entity_pos(0);
                (void) estimand_entity_pos;  // dummy to suppress unused var warning
                stan::math::fill(estimand_entity_pos, std::numeric_limits<int>::min());
                stan::math::assign(estimand_entity_pos,1);
                current_statement_begin__ = 883;
                int level_estimands_csr_vec_pos(0);
                (void) level_estimands_csr_vec_pos;  // dummy to suppress unused var warning
                stan::math::fill(level_estimands_csr_vec_pos, std::numeric_limits<int>::min());
                stan::math::assign(level_estimands_csr_vec_pos,1);
                current_statement_begin__ = 884;
                int entity_estimand_csr_row_pos_pos(0);
                (void) entity_estimand_csr_row_pos_pos;  // dummy to suppress unused var warning
                stan::math::fill(entity_estimand_csr_row_pos_pos, std::numeric_limits<int>::min());
                stan::math::assign(entity_estimand_csr_row_pos_pos,1);
                current_statement_begin__ = 885;
                int last_num_unique_entities(0);
                (void) last_num_unique_entities;  // dummy to suppress unused var warning
                stan::math::fill(last_num_unique_entities, std::numeric_limits<int>::min());
                current_statement_begin__ = 887;
                for (int estimand_level_index = 1; estimand_level_index <= num_estimand_levels; ++estimand_level_index) {
                    {
                    current_statement_begin__ = 888;
                    int curr_estimand_level(0);
                    (void) curr_estimand_level;  // dummy to suppress unused var warning
                    stan::math::fill(curr_estimand_level, std::numeric_limits<int>::min());
                    stan::math::assign(curr_estimand_level,get_base1(estimand_levels, estimand_level_index, "estimand_levels", 1));
                    current_statement_begin__ = 889;
                    int curr_estimand_level_size(0);
                    (void) curr_estimand_level_size;  // dummy to suppress unused var warning
                    stan::math::fill(curr_estimand_level_size, std::numeric_limits<int>::min());
                    stan::math::assign(curr_estimand_level_size,get_base1(level_size, curr_estimand_level, "level_size", 1));
                    current_statement_begin__ = 890;
                    validate_non_negative_index("curr_num_unique_entities", "curr_estimand_level_size", curr_estimand_level_size);
                    std::vector<int  > curr_num_unique_entities(curr_estimand_level_size, int(0));
                    stan::math::fill(curr_num_unique_entities, std::numeric_limits<int>::min());
                    stan::math::assign(curr_num_unique_entities,array_extract_group_values(num_unique_entities_in_estimand_level_entities, stan::model::rvalue(level_size, stan::model::cons_list(stan::model::index_multi(estimand_levels), stan::model::nil_index_list()), "level_size"), static_cast<std::vector<int> >(stan::math::array_builder<int >().add(estimand_level_index).array()), pstream__));
                    current_statement_begin__ = 892;
                    for (int estimand_level_entity_index = 1; estimand_level_entity_index <= curr_estimand_level_size; ++estimand_level_entity_index) {
                        {
                        current_statement_begin__ = 893;
                        validate_non_negative_index("unique_entities_in_curr_level_entity", "get_base1(curr_num_unique_entities, estimand_level_entity_index, \"curr_num_unique_entities\", 1)", get_base1(curr_num_unique_entities, estimand_level_entity_index, "curr_num_unique_entities", 1));
                        std::vector<int  > unique_entities_in_curr_level_entity(get_base1(curr_num_unique_entities, estimand_level_entity_index, "curr_num_unique_entities", 1), int(0));
                        stan::math::fill(unique_entities_in_curr_level_entity, std::numeric_limits<int>::min());
                        stan::math::assign(unique_entities_in_curr_level_entity,array_extract_group_values(stan::model::rvalue(unique_entities_in_level_entities, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(curr_estimand_level), stan::model::nil_index_list())), "unique_entities_in_level_entities"), curr_num_unique_entities, static_cast<std::vector<int> >(stan::math::array_builder<int >().add(estimand_level_entity_index).array()), pstream__));
                        current_statement_begin__ = 896;
                        validate_non_negative_index("unique_entities_estimand_offset", "get_base1(curr_num_unique_entities, estimand_level_entity_index, \"curr_num_unique_entities\", 1)", get_base1(curr_num_unique_entities, estimand_level_entity_index, "curr_num_unique_entities", 1));
                        std::vector<int  > unique_entities_estimand_offset(get_base1(curr_num_unique_entities, estimand_level_entity_index, "curr_num_unique_entities", 1), int(0));
                        stan::math::fill(unique_entities_estimand_offset, std::numeric_limits<int>::min());
                        stan::math::assign(unique_entities_estimand_offset,array_product(array_add(unique_entities_in_curr_level_entity, static_cast<std::vector<int> >(stan::math::array_builder<int >().add(-(1)).array()), pstream__), static_cast<std::vector<int> >(stan::math::array_builder<int >().add(num_all_estimands).array()), pstream__));
                        current_statement_begin__ = 899;
                        validate_non_negative_index("curr_num_obs_in_unique_entity", "get_base1(curr_num_unique_entities, estimand_level_entity_index, \"curr_num_unique_entities\", 1)", get_base1(curr_num_unique_entities, estimand_level_entity_index, "curr_num_unique_entities", 1));
                        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> curr_num_obs_in_unique_entity(get_base1(curr_num_unique_entities, estimand_level_entity_index, "curr_num_unique_entities", 1));
                        stan::math::initialize(curr_num_obs_in_unique_entity, DUMMY_VAR__);
                        stan::math::fill(curr_num_obs_in_unique_entity, DUMMY_VAR__);
                        stan::math::assign(curr_num_obs_in_unique_entity,stan::model::rvalue(num_obs_in_unique_entity, stan::model::cons_list(stan::model::index_multi(unique_entities_in_curr_level_entity), stan::model::nil_index_list()), "num_obs_in_unique_entity"));
                        current_statement_begin__ = 901;
                        for (int estimand_index = 1; estimand_index <= num_all_estimands; ++estimand_index) {
                            {
                            current_statement_begin__ = 902;
                            int level_estimands_csr_vec_end(0);
                            (void) level_estimands_csr_vec_end;  // dummy to suppress unused var warning
                            stan::math::fill(level_estimands_csr_vec_end, std::numeric_limits<int>::min());
                            stan::math::assign(level_estimands_csr_vec_end,((level_estimands_csr_vec_pos + get_base1(curr_num_unique_entities, estimand_level_entity_index, "curr_num_unique_entities", 1)) - 1));
                            current_statement_begin__ = 904;
                            stan::model::assign(entity_estimand_ids, 
                                        stan::model::cons_list(stan::model::index_min_max(level_estimands_csr_vec_pos, level_estimands_csr_vec_end), stan::model::nil_index_list()), 
                                        array_add(unique_entities_estimand_offset, static_cast<std::vector<int> >(stan::math::array_builder<int >().add(estimand_index).array()), pstream__), 
                                        "assigning variable entity_estimand_ids");
                            current_statement_begin__ = 905;
                            stan::model::assign(level_estimands_csr_vec, 
                                        stan::model::cons_list(stan::model::index_min_max(level_estimands_csr_vec_pos, level_estimands_csr_vec_end), stan::model::nil_index_list()), 
                                        divide(curr_num_obs_in_unique_entity, sum(curr_num_obs_in_unique_entity)), 
                                        "assigning variable level_estimands_csr_vec");
                            current_statement_begin__ = 907;
                            stan::model::assign(entity_estimand_csr_row_pos, 
                                        stan::model::cons_list(stan::model::index_uni(entity_estimand_csr_row_pos_pos), stan::model::nil_index_list()), 
                                        (logical_gt(entity_estimand_csr_row_pos_pos, 1) ? (get_base1(entity_estimand_csr_row_pos, (entity_estimand_csr_row_pos_pos - 1), "entity_estimand_csr_row_pos", 1) + last_num_unique_entities) : 1 ), 
                                        "assigning variable entity_estimand_csr_row_pos");
                            current_statement_begin__ = 911;
                            stan::math::assign(last_num_unique_entities, get_base1(curr_num_unique_entities, estimand_level_entity_index, "curr_num_unique_entities", 1));
                            current_statement_begin__ = 913;
                            stan::math::assign(entity_estimand_csr_row_pos_pos, (entity_estimand_csr_row_pos_pos + 1));
                            current_statement_begin__ = 914;
                            stan::math::assign(level_estimands_csr_vec_pos, (level_estimands_csr_vec_end + 1));
                            }
                        }
                        current_statement_begin__ = 917;
                        stan::math::assign(estimand_entity_pos, (estimand_entity_pos + 1));
                        }
                    }
                    }
                }
                current_statement_begin__ = 921;
                stan::model::assign(entity_estimand_csr_row_pos, 
                            stan::model::cons_list(stan::model::index_uni(entity_estimand_csr_row_pos_pos), stan::model::nil_index_list()), 
                            (get_base1(entity_estimand_csr_row_pos, (entity_estimand_csr_row_pos_pos - 1), "entity_estimand_csr_row_pos", 1) + last_num_unique_entities), 
                            "assigning variable entity_estimand_csr_row_pos");
                }
            }
            current_statement_begin__ = 924;
            if (as_bool(logical_gt(num_discretized_groups, 0))) {
                {
                current_statement_begin__ = 925;
                int discretized_group_pos(0);
                (void) discretized_group_pos;  // dummy to suppress unused var warning
                stan::math::fill(discretized_group_pos, std::numeric_limits<int>::min());
                stan::math::assign(discretized_group_pos,1);
                current_statement_begin__ = 926;
                int histogram_vec_pos(0);
                (void) histogram_vec_pos;  // dummy to suppress unused var warning
                stan::math::fill(histogram_vec_pos, std::numeric_limits<int>::min());
                stan::math::assign(histogram_vec_pos,1);
                current_statement_begin__ = 927;
                int histogram_ids_pos(0);
                (void) histogram_ids_pos;  // dummy to suppress unused var warning
                stan::math::fill(histogram_ids_pos, std::numeric_limits<int>::min());
                stan::math::assign(histogram_ids_pos,1);
                current_statement_begin__ = 929;
                int midpoint_vec_pos(0);
                (void) midpoint_vec_pos;  // dummy to suppress unused var warning
                stan::math::fill(midpoint_vec_pos, std::numeric_limits<int>::min());
                stan::math::assign(midpoint_vec_pos,1);
                current_statement_begin__ = 930;
                int midpoint_ids_pos(0);
                (void) midpoint_ids_pos;  // dummy to suppress unused var warning
                stan::math::fill(midpoint_ids_pos, std::numeric_limits<int>::min());
                stan::math::assign(midpoint_ids_pos,1);
                current_statement_begin__ = 932;
                int histogram_ids_size(0);
                (void) histogram_ids_size;  // dummy to suppress unused var warning
                stan::math::fill(histogram_ids_size, std::numeric_limits<int>::min());
                stan::math::assign(histogram_ids_size,(num_discretized_groups * ((2 * num_discretized_variables) + 1)));
                current_statement_begin__ = 933;
                validate_non_negative_index("histogram_last_id_pos", "num_discretized_groups", num_discretized_groups);
                std::vector<int  > histogram_last_id_pos(num_discretized_groups, int(0));
                stan::math::fill(histogram_last_id_pos, std::numeric_limits<int>::min());
                current_statement_begin__ = 934;
                int last_histogram_one_pos(0);
                (void) last_histogram_one_pos;  // dummy to suppress unused var warning
                stan::math::fill(last_histogram_one_pos, std::numeric_limits<int>::min());
                stan::math::assign(last_histogram_one_pos,((num_unique_entities * num_atom_estimands) + 1));
                current_statement_begin__ = 936;
                validate_non_negative_index("histogram_ids", "histogram_ids_size", histogram_ids_size);
                std::vector<int  > histogram_ids(histogram_ids_size, int(0));
                stan::math::fill(histogram_ids, std::numeric_limits<int>::min());
                current_statement_begin__ = 938;
                validate_non_negative_index("midpoint_ids", "(num_discretized_groups * (num_cutpoints - 1))", (num_discretized_groups * (num_cutpoints - 1)));
                std::vector<int  > midpoint_ids((num_discretized_groups * (num_cutpoints - 1)), int(0));
                stan::math::fill(midpoint_ids, std::numeric_limits<int>::min());
                current_statement_begin__ = 941;
                validate_non_negative_index("histogram_row_sizes", "((num_cutpoints - 1) * num_discretized_groups)", ((num_cutpoints - 1) * num_discretized_groups));
                std::vector<int  > histogram_row_sizes(((num_cutpoints - 1) * num_discretized_groups), int(0));
                stan::math::fill(histogram_row_sizes, std::numeric_limits<int>::min());
                stan::math::assign(histogram_row_sizes,to_array_1d(rep_array(append_array(static_cast<std::vector<int> >(stan::math::array_builder<int >().add(1).array()), rep_array(2, num_discretized_variables)), num_discretized_groups)));
                current_statement_begin__ = 943;
                stan::math::assign(entity_histogram_csr_row_pos, csr_shift_expand_u(histogram_row_sizes, num_unique_entities, pstream__));
                current_statement_begin__ = 944;
                stan::math::assign(entity_midpoint_csr_row_pos, csr_shift_expand_u(rep_array((num_cutpoints - 1), num_discretized_groups), num_unique_entities, pstream__));
                current_statement_begin__ = 946;
                for (int discretized_group_index = 1; discretized_group_index <= num_discretized_groups; ++discretized_group_index) {
                    {
                    current_statement_begin__ = 947;
                    int histogram_ids_end(0);
                    (void) histogram_ids_end;  // dummy to suppress unused var warning
                    stan::math::fill(histogram_ids_end, std::numeric_limits<int>::min());
                    stan::math::assign(histogram_ids_end,((histogram_ids_pos + ((2 * num_discretized_variables) + 1)) - 1));
                    current_statement_begin__ = 948;
                    int discretized_group_end(0);
                    (void) discretized_group_end;  // dummy to suppress unused var warning
                    stan::math::fill(discretized_group_end, std::numeric_limits<int>::min());
                    stan::math::assign(discretized_group_end,((discretized_group_pos + num_discretized_variables) - 1));
                    current_statement_begin__ = 949;
                    int midpoint_ids_end(0);
                    (void) midpoint_ids_end;  // dummy to suppress unused var warning
                    stan::math::fill(midpoint_ids_end, std::numeric_limits<int>::min());
                    stan::math::assign(midpoint_ids_end,((midpoint_ids_pos + (num_cutpoints - 1)) - 1));
                    current_statement_begin__ = 951;
                    validate_non_negative_index("curr_group_members", "num_discretized_variables", num_discretized_variables);
                    std::vector<int  > curr_group_members(num_discretized_variables, int(0));
                    stan::math::fill(curr_group_members, std::numeric_limits<int>::min());
                    stan::math::assign(curr_group_members,stan::model::rvalue(discretized_group_ids, stan::model::cons_list(stan::model::index_min_max(discretized_group_pos, discretized_group_end), stan::model::nil_index_list()), "discretized_group_ids"));
                    current_statement_begin__ = 953;
                    stan::model::assign(histogram_last_id_pos, 
                                stan::model::cons_list(stan::model::index_uni(discretized_group_index), stan::model::nil_index_list()), 
                                histogram_ids_end, 
                                "assigning variable histogram_last_id_pos");
                    current_statement_begin__ = 955;
                    for (int entity_index = 1; entity_index <= num_unique_entities; ++entity_index) {
                        {
                        current_statement_begin__ = 956;
                        int histogram_vec_end(0);
                        (void) histogram_vec_end;  // dummy to suppress unused var warning
                        stan::math::fill(histogram_vec_end, std::numeric_limits<int>::min());
                        stan::math::assign(histogram_vec_end,((histogram_vec_pos + ((2 * num_discretized_variables) + 1)) - 1));
                        current_statement_begin__ = 957;
                        int midpoint_vec_end(0);
                        (void) midpoint_vec_end;  // dummy to suppress unused var warning
                        stan::math::fill(midpoint_vec_end, std::numeric_limits<int>::min());
                        stan::math::assign(midpoint_vec_end,((midpoint_vec_pos + (num_cutpoints - 1)) - 1));
                        current_statement_begin__ = 959;
                        stan::model::assign(entity_histogram_vec, 
                                    stan::model::cons_list(stan::model::index_min_max(histogram_vec_pos, histogram_vec_end), stan::model::nil_index_list()), 
                                    append_row(to_vector(rep_matrix(transpose(stan::math::to_row_vector(stan::math::array_builder<double >().add(1).add(-(1)).array())), num_discretized_variables)), 1), 
                                    "assigning variable entity_histogram_vec");
                        current_statement_begin__ = 960;
                        stan::model::assign(entity_midpoint_vec, 
                                    stan::model::cons_list(stan::model::index_min_max(midpoint_vec_pos, midpoint_vec_end), stan::model::nil_index_list()), 
                                    cutpoint_midpoints, 
                                    "assigning variable entity_midpoint_vec");
                        current_statement_begin__ = 962;
                        if (as_bool(logical_gt(num_discrete_utility_values, 0))) {
                            current_statement_begin__ = 963;
                            stan::model::assign(entity_utility_vec, 
                                        stan::model::cons_list(stan::model::index_min_max(midpoint_vec_pos, midpoint_vec_end), stan::model::nil_index_list()), 
                                        utility, 
                                        "assigning variable entity_utility_vec");
                        }
                        current_statement_begin__ = 966;
                        stan::model::assign(entity_discretize_bin_alpha, 
                                    stan::model::cons_list(stan::model::index_min_max(midpoint_vec_pos, midpoint_vec_end), stan::model::nil_index_list()), 
                                    discretize_bin_alpha, 
                                    "assigning variable entity_discretize_bin_alpha");
                        current_statement_begin__ = 967;
                        stan::model::assign(entity_discretize_bin_beta, 
                                    stan::model::cons_list(stan::model::index_min_max(midpoint_vec_pos, midpoint_vec_end), stan::model::nil_index_list()), 
                                    discretize_bin_beta, 
                                    "assigning variable entity_discretize_bin_beta");
                        current_statement_begin__ = 969;
                        stan::math::assign(histogram_vec_pos, (histogram_vec_end + 1));
                        current_statement_begin__ = 970;
                        stan::math::assign(midpoint_vec_pos, (midpoint_vec_end + 1));
                        }
                    }
                    current_statement_begin__ = 973;
                    for (int group_member_index = 1; group_member_index <= num_discretized_variables; ++group_member_index) {
                        {
                        current_statement_begin__ = 974;
                        int offset(0);
                        (void) offset;  // dummy to suppress unused var warning
                        stan::math::fill(offset, std::numeric_limits<int>::min());
                        stan::math::assign(offset,(2 * (group_member_index - 1)));
                        current_statement_begin__ = 976;
                        stan::model::assign(histogram_ids, 
                                    stan::model::cons_list(stan::model::index_min_max((histogram_ids_pos + offset), ((histogram_ids_pos + offset) + 1)), stan::model::nil_index_list()), 
                                    rep_array(get_base1(curr_group_members, group_member_index, "curr_group_members", 1), 2), 
                                    "assigning variable histogram_ids");
                        }
                    }
                    current_statement_begin__ = 979;
                    stan::model::assign(histogram_ids, 
                                stan::model::cons_list(stan::model::index_min_max((histogram_ids_end - 1), histogram_ids_end), stan::model::nil_index_list()), 
                                static_cast<std::vector<int> >(stan::math::array_builder<int >().add(get_base1(curr_group_members, num_discretized_variables, "curr_group_members", 1)).add(0).array()), 
                                "assigning variable histogram_ids");
                    current_statement_begin__ = 981;
                    stan::model::assign(midpoint_ids, 
                                stan::model::cons_list(stan::model::index_min_max(midpoint_ids_pos, midpoint_ids_end), stan::model::nil_index_list()), 
                                seq((1 + ((discretized_group_index - 1) * (num_cutpoints - 1))), (discretized_group_index * (num_cutpoints - 1)), 1, pstream__), 
                                "assigning variable midpoint_ids");
                    current_statement_begin__ = 983;
                    stan::math::assign(histogram_ids_pos, (histogram_ids_end + 1));
                    current_statement_begin__ = 984;
                    stan::math::assign(discretized_group_pos, (discretized_group_end + 1));
                    current_statement_begin__ = 985;
                    stan::math::assign(midpoint_ids_pos, (midpoint_ids_end + 1));
                    }
                }
                current_statement_begin__ = 988;
                stan::math::assign(entity_histogram_ids, csr_shift_expand_v(histogram_ids, num_atom_estimands, num_unique_entities, pstream__));
                current_statement_begin__ = 990;
                for (int entity_index = 1; entity_index <= num_unique_entities; ++entity_index) {
                    current_statement_begin__ = 991;
                    stan::model::assign(entity_histogram_ids, 
                                stan::model::cons_list(stan::model::index_multi(array_add(histogram_last_id_pos, static_cast<std::vector<int> >(stan::math::array_builder<int >().add(((entity_index - 1) * histogram_ids_size)).array()), pstream__)), stan::model::nil_index_list()), 
                                rep_array(last_histogram_one_pos, num_discretized_groups), 
                                "assigning variable entity_histogram_ids");
                }
                current_statement_begin__ = 994;
                stan::math::assign(entity_midpoint_ids, csr_shift_expand_v(midpoint_ids, (num_discretized_groups * (num_cutpoints - 1)), num_unique_entities, pstream__));
                }
            }
            current_statement_begin__ = 997;
            if (as_bool(logical_gt(num_between_entity_diff_levels, 0))) {
                {
                current_statement_begin__ = 998;
                int between_csr_ids_pos(0);
                (void) between_csr_ids_pos;  // dummy to suppress unused var warning
                stan::math::fill(between_csr_ids_pos, std::numeric_limits<int>::min());
                stan::math::assign(between_csr_ids_pos,1);
                current_statement_begin__ = 1000;
                stan::math::assign(between_entity_diff_csr_row_pos, seq(1, (((2 * num_atom_estimands) * (sum(stan::model::rvalue(level_size, stan::model::cons_list(stan::model::index_multi(between_entity_diff_levels), stan::model::nil_index_list()), "level_size")) - num_between_entity_diff_levels)) + 1), 2, pstream__));
                current_statement_begin__ = 1002;
                for (int between_diff_level_index_index = 1; between_diff_level_index_index <= num_between_entity_diff_levels; ++between_diff_level_index_index) {
                    {
                    current_statement_begin__ = 1003;
                    int between_diff_level_index(0);
                    (void) between_diff_level_index;  // dummy to suppress unused var warning
                    stan::math::fill(between_diff_level_index, std::numeric_limits<int>::min());
                    stan::math::assign(between_diff_level_index,get_base1(between_entity_diff_levels, between_diff_level_index_index, "between_entity_diff_levels", 1));
                    current_statement_begin__ = 1004;
                    int between_diff_level_offset(0);
                    (void) between_diff_level_offset;  // dummy to suppress unused var warning
                    stan::math::fill(between_diff_level_offset, std::numeric_limits<int>::min());
                    stan::math::assign(between_diff_level_offset,(logical_gt(between_diff_level_index, 1) ? (sum(stan::model::rvalue(level_size, stan::model::cons_list(stan::model::index_max((between_diff_level_index - 1)), stan::model::nil_index_list()), "level_size")) * num_all_estimands) : 0 ));
                    current_statement_begin__ = 1006;
                    for (int between_diff_entity_index = 1; between_diff_entity_index <= (get_base1(level_size, between_diff_level_index, "level_size", 1) - 1); ++between_diff_entity_index) {
                        {
                        current_statement_begin__ = 1007;
                        validate_non_negative_index("diff_pair", "2", 2);
                        std::vector<int  > diff_pair(2, int(0));
                        stan::math::fill(diff_pair, std::numeric_limits<int>::min());
                        stan::math::assign(diff_pair,static_cast<std::vector<int> >(stan::math::array_builder<int >().add(between_diff_level_offset).add((between_diff_level_offset + (num_all_estimands * between_diff_entity_index))).array()));
                        current_statement_begin__ = 1009;
                        for (int estimand_index = 1; estimand_index <= num_atom_estimands; ++estimand_index) {
                            current_statement_begin__ = 1010;
                            stan::model::assign(between_entity_diff_csr_ids, 
                                        stan::model::cons_list(stan::model::index_min_max(between_csr_ids_pos, (between_csr_ids_pos + 1)), stan::model::nil_index_list()), 
                                        array_add(diff_pair, static_cast<std::vector<int> >(stan::math::array_builder<int >().add(estimand_index).array()), pstream__), 
                                        "assigning variable between_entity_diff_csr_ids");
                            current_statement_begin__ = 1011;
                            stan::math::assign(between_csr_ids_pos, (between_csr_ids_pos + 2));
                        }
                        }
                    }
                    }
                }
                }
            }
            {
            current_statement_begin__ = 1018;
            int exp_r_pos(0);
            (void) exp_r_pos;  // dummy to suppress unused var warning
            stan::math::fill(exp_r_pos, std::numeric_limits<int>::min());
            stan::math::assign(exp_r_pos,1);
            current_statement_begin__ = 1020;
            for (int r_type_index = 1; r_type_index <= num_r_types; ++r_type_index) {
                {
                current_statement_begin__ = 1021;
                int exp_r_end(0);
                (void) exp_r_end;  // dummy to suppress unused var warning
                stan::math::fill(exp_r_end, std::numeric_limits<int>::min());
                stan::math::assign(exp_r_end,((exp_r_pos + num_experiment_types) - 1));
                current_statement_begin__ = 1023;
                stan::model::assign(experiment_r_type_index, 
                            stan::model::cons_list(stan::model::index_min_max(exp_r_pos, exp_r_end), stan::model::nil_index_list()), 
                            rep_array(r_type_index, num_experiment_types), 
                            "assigning variable experiment_r_type_index");
                current_statement_begin__ = 1025;
                stan::math::assign(exp_r_pos, (exp_r_end + 1));
                }
            }
            }
            // validate transformed data
            current_statement_begin__ = 606;
            check_greater_or_equal(function__, "num_r_types_full", num_r_types_full, num_r_types);
            current_statement_begin__ = 607;
            size_t experiment_r_type_index_i_0_max__ = num_r_types_full;
            for (size_t i_0__ = 0; i_0__ < experiment_r_type_index_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "experiment_r_type_index[i_0__]", experiment_r_type_index[i_0__], 1);
                check_less_or_equal(function__, "experiment_r_type_index[i_0__]", experiment_r_type_index[i_0__], num_r_types);
            }
            current_statement_begin__ = 609;
            check_greater_or_equal(function__, "full_experiment_types_prob", full_experiment_types_prob, 0);
            check_less_or_equal(function__, "full_experiment_types_prob", full_experiment_types_prob, 1);
            current_statement_begin__ = 611;
            size_t level_size_i_0_max__ = num_levels;
            for (size_t i_0__ = 0; i_0__ < level_size_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "level_size[i_0__]", level_size[i_0__], 1);
            }
            current_statement_begin__ = 612;
            check_greater_or_equal(function__, "num_obs_in_unique_entity", num_obs_in_unique_entity, 0);
            check_less_or_equal(function__, "num_obs_in_unique_entity", num_obs_in_unique_entity, num_obs);
            current_statement_begin__ = 613;
            stan::math::check_simplex(function__, "unique_entity_prop", unique_entity_prop);
            current_statement_begin__ = 615;
            size_t num_unique_entities_in_estimand_level_entities_i_0_max__ = sum(stan::model::rvalue(level_size, stan::model::cons_list(stan::model::index_multi(estimand_levels), stan::model::nil_index_list()), "level_size"));
            for (size_t i_0__ = 0; i_0__ < num_unique_entities_in_estimand_level_entities_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "num_unique_entities_in_estimand_level_entities[i_0__]", num_unique_entities_in_estimand_level_entities[i_0__], 1);
                check_less_or_equal(function__, "num_unique_entities_in_estimand_level_entities[i_0__]", num_unique_entities_in_estimand_level_entities[i_0__], num_unique_entities);
            }
            current_statement_begin__ = 618;
            size_t unique_entities_in_level_entities_i_0_max__ = num_unique_entities;
            size_t unique_entities_in_level_entities_i_1_max__ = num_levels;
            for (size_t i_0__ = 0; i_0__ < unique_entities_in_level_entities_i_0_max__; ++i_0__) {
                for (size_t i_1__ = 0; i_1__ < unique_entities_in_level_entities_i_1_max__; ++i_1__) {
                    check_greater_or_equal(function__, "unique_entities_in_level_entities[i_0__][i_1__]", unique_entities_in_level_entities[i_0__][i_1__], 1);
                    check_less_or_equal(function__, "unique_entities_in_level_entities[i_0__][i_1__]", unique_entities_in_level_entities[i_0__][i_1__], num_unique_entities);
                }
            }
            current_statement_begin__ = 623;
            check_greater_or_equal(function__, "vec_diff", vec_diff, -(1));
            check_less_or_equal(function__, "vec_diff", vec_diff, 1);
            current_statement_begin__ = 624;
            check_greater_or_equal(function__, "vec_mean_diff", vec_mean_diff, -(1));
            check_less_or_equal(function__, "vec_mean_diff", vec_mean_diff, 1);
            current_statement_begin__ = 625;
            check_greater_or_equal(function__, "vec_utility_diff", vec_utility_diff, -(1));
            check_less_or_equal(function__, "vec_utility_diff", vec_utility_diff, 1);
            current_statement_begin__ = 632;
            check_greater_or_equal(function__, "vec_1", vec_1, 1);
            check_less_or_equal(function__, "vec_1", vec_1, 1);
            current_statement_begin__ = 634;
            size_t entity_total_num_candidates_i_0_max__ = (logical_gt(num_obs, 0) ? num_unique_entities : 0 );
            for (size_t i_0__ = 0; i_0__ < entity_total_num_candidates_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "entity_total_num_candidates[i_0__]", entity_total_num_candidates[i_0__], 1);
            }
            current_statement_begin__ = 643;
            size_t entity_candidate_group_ids_i_0_max__ = sum(entity_total_num_candidates);
            for (size_t i_0__ = 0; i_0__ < entity_candidate_group_ids_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "entity_candidate_group_ids[i_0__]", entity_candidate_group_ids[i_0__], 1);
                check_less_or_equal(function__, "entity_candidate_group_ids[i_0__]", entity_candidate_group_ids[i_0__], (num_r_types * num_unique_entities));
            }
            current_statement_begin__ = 644;
            size_t entity_candidate_group_csr_row_pos_i_0_max__ = (sum(num_unique_entity_candidate_groups) + 1);
            for (size_t i_0__ = 0; i_0__ < entity_candidate_group_csr_row_pos_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "entity_candidate_group_csr_row_pos[i_0__]", entity_candidate_group_csr_row_pos[i_0__], 1);
                check_less_or_equal(function__, "entity_candidate_group_csr_row_pos[i_0__]", entity_candidate_group_csr_row_pos[i_0__], (sum(stan::model::rvalue(candidate_group_size, stan::model::cons_list(stan::model::index_multi(unique_entity_candidate_groups), stan::model::nil_index_list()), "candidate_group_size")) + 1));
            }
            current_statement_begin__ = 646;
            size_t obs_candidate_group_ids_i_0_max__ = sum(stan::model::rvalue(candidate_group_size, stan::model::cons_list(stan::model::index_multi(obs_candidate_group), stan::model::nil_index_list()), "candidate_group_size"));
            for (size_t i_0__ = 0; i_0__ < obs_candidate_group_ids_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "obs_candidate_group_ids[i_0__]", obs_candidate_group_ids[i_0__], 1);
                check_less_or_equal(function__, "obs_candidate_group_ids[i_0__]", obs_candidate_group_ids[i_0__], (num_r_types * num_unique_entities));
            }
            current_statement_begin__ = 647;
            size_t obs_candidate_group_csr_row_pos_i_0_max__ = (num_obs + 1);
            for (size_t i_0__ = 0; i_0__ < obs_candidate_group_csr_row_pos_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "obs_candidate_group_csr_row_pos[i_0__]", obs_candidate_group_csr_row_pos[i_0__], 1);
                check_less_or_equal(function__, "obs_candidate_group_csr_row_pos[i_0__]", obs_candidate_group_csr_row_pos[i_0__], (sum(stan::model::rvalue(candidate_group_size, stan::model::cons_list(stan::model::index_multi(obs_candidate_group), stan::model::nil_index_list()), "candidate_group_size")) + 1));
            }
            current_statement_begin__ = 649;
            size_t entity_abducted_prob_ids_i_0_max__ = (sum(abducted_prob_size) * num_unique_entities);
            for (size_t i_0__ = 0; i_0__ < entity_abducted_prob_ids_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "entity_abducted_prob_ids[i_0__]", entity_abducted_prob_ids[i_0__], 1);
                check_less_or_equal(function__, "entity_abducted_prob_ids[i_0__]", entity_abducted_prob_ids[i_0__], (num_r_types_full * num_unique_entities));
            }
            current_statement_begin__ = 650;
            size_t entity_abducted_prob_csr_row_pos_i_0_max__ = (num_abducted_estimands ? ((num_unique_entities * num_abducted_estimands) + 1) : 0 );
            for (size_t i_0__ = 0; i_0__ < entity_abducted_prob_csr_row_pos_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "entity_abducted_prob_csr_row_pos[i_0__]", entity_abducted_prob_csr_row_pos[i_0__], 1);
            }
            current_statement_begin__ = 652;
            size_t long_entity_abducted_index_i_0_max__ = (num_unique_entities * num_abducted_estimands);
            for (size_t i_0__ = 0; i_0__ < long_entity_abducted_index_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "long_entity_abducted_index[i_0__]", long_entity_abducted_index[i_0__], 1);
            }
            current_statement_begin__ = 654;
            size_t entity_est_prob_ids_i_0_max__ = (sum(est_prob_size) * num_unique_entities);
            for (size_t i_0__ = 0; i_0__ < entity_est_prob_ids_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "entity_est_prob_ids[i_0__]", entity_est_prob_ids[i_0__], 1);
                check_less_or_equal(function__, "entity_est_prob_ids[i_0__]", entity_est_prob_ids[i_0__], (num_r_types_full * num_unique_entities));
            }
            current_statement_begin__ = 655;
            size_t entity_est_prob_csr_row_pos_i_0_max__ = (logical_gt(num_atom_estimands, 0) ? ((num_unique_entities * num_atom_estimands) + 1) : 0 );
            for (size_t i_0__ = 0; i_0__ < entity_est_prob_csr_row_pos_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "entity_est_prob_csr_row_pos[i_0__]", entity_est_prob_csr_row_pos[i_0__], 1);
            }
            current_statement_begin__ = 657;
            size_t entity_diff_estimand_ids_i_0_max__ = ((num_diff_estimands * 2) * num_unique_entities);
            for (size_t i_0__ = 0; i_0__ < entity_diff_estimand_ids_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "entity_diff_estimand_ids[i_0__]", entity_diff_estimand_ids[i_0__], 1);
                check_less_or_equal(function__, "entity_diff_estimand_ids[i_0__]", entity_diff_estimand_ids[i_0__], (num_atom_estimands * num_unique_entities));
            }
            current_statement_begin__ = 658;
            size_t entity_diff_estimand_csr_row_pos_i_0_max__ = (logical_gt(num_diff_estimands, 0) ? ((num_unique_entities * num_diff_estimands) + 1) : 0 );
            for (size_t i_0__ = 0; i_0__ < entity_diff_estimand_csr_row_pos_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "entity_diff_estimand_csr_row_pos[i_0__]", entity_diff_estimand_csr_row_pos[i_0__], 1);
            }
            current_statement_begin__ = 660;
            size_t entity_mean_diff_estimand_ids_i_0_max__ = ((num_mean_diff_estimands * 2) * num_unique_entities);
            for (size_t i_0__ = 0; i_0__ < entity_mean_diff_estimand_ids_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "entity_mean_diff_estimand_ids[i_0__]", entity_mean_diff_estimand_ids[i_0__], 1);
                check_less_or_equal(function__, "entity_mean_diff_estimand_ids[i_0__]", entity_mean_diff_estimand_ids[i_0__], (num_discretized_groups * num_unique_entities));
            }
            current_statement_begin__ = 661;
            size_t entity_mean_diff_estimand_csr_row_pos_i_0_max__ = (logical_gt(num_mean_diff_estimands, 0) ? ((num_unique_entities * num_mean_diff_estimands) + 1) : 0 );
            for (size_t i_0__ = 0; i_0__ < entity_mean_diff_estimand_csr_row_pos_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "entity_mean_diff_estimand_csr_row_pos[i_0__]", entity_mean_diff_estimand_csr_row_pos[i_0__], 1);
            }
            current_statement_begin__ = 663;
            size_t entity_utility_diff_estimand_ids_i_0_max__ = ((num_utility_diff_estimands * 2) * num_unique_entities);
            for (size_t i_0__ = 0; i_0__ < entity_utility_diff_estimand_ids_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "entity_utility_diff_estimand_ids[i_0__]", entity_utility_diff_estimand_ids[i_0__], 1);
                check_less_or_equal(function__, "entity_utility_diff_estimand_ids[i_0__]", entity_utility_diff_estimand_ids[i_0__], (num_discretized_groups * num_unique_entities));
            }
            current_statement_begin__ = 664;
            size_t entity_utility_diff_estimand_csr_row_pos_i_0_max__ = (logical_gt(num_utility_diff_estimands, 0) ? ((num_unique_entities * num_utility_diff_estimands) + 1) : 0 );
            for (size_t i_0__ = 0; i_0__ < entity_utility_diff_estimand_csr_row_pos_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "entity_utility_diff_estimand_csr_row_pos[i_0__]", entity_utility_diff_estimand_csr_row_pos[i_0__], 1);
            }
            current_statement_begin__ = 666;
            check_greater_or_equal(function__, "total_num_bg_variable_types", total_num_bg_variable_types, 1);
            current_statement_begin__ = 668;
            check_greater_or_equal(function__, "marginal_prob_csr_vec", marginal_prob_csr_vec, 0);
            check_less_or_equal(function__, "marginal_prob_csr_vec", marginal_prob_csr_vec, 1);
            current_statement_begin__ = 669;
            size_t entity_marginal_prob_ids_i_0_max__ = (sum(num_bg_variable_type_combo_members) * num_unique_entities);
            for (size_t i_0__ = 0; i_0__ < entity_marginal_prob_ids_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "entity_marginal_prob_ids[i_0__]", entity_marginal_prob_ids[i_0__], 1);
                check_less_or_equal(function__, "entity_marginal_prob_ids[i_0__]", entity_marginal_prob_ids[i_0__], (num_r_types * num_unique_entities));
            }
            current_statement_begin__ = 670;
            size_t entity_marginal_prob_csr_row_pos_i_0_max__ = (total_num_bg_variable_types + 1);
            for (size_t i_0__ = 0; i_0__ < entity_marginal_prob_csr_row_pos_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "entity_marginal_prob_csr_row_pos[i_0__]", entity_marginal_prob_csr_row_pos[i_0__], 1);
            }
            current_statement_begin__ = 672;
            check_greater_or_equal(function__, "level_estimands_csr_vec", level_estimands_csr_vec, 0);
            check_less_or_equal(function__, "level_estimands_csr_vec", level_estimands_csr_vec, 1);
            current_statement_begin__ = 673;
            size_t entity_estimand_ids_i_0_max__ = ((num_all_estimands * num_unique_entities) * num_estimand_levels);
            for (size_t i_0__ = 0; i_0__ < entity_estimand_ids_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "entity_estimand_ids[i_0__]", entity_estimand_ids[i_0__], 1);
                check_less_or_equal(function__, "entity_estimand_ids[i_0__]", entity_estimand_ids[i_0__], (num_all_estimands * num_unique_entities));
            }
            current_statement_begin__ = 674;
            size_t entity_estimand_csr_row_pos_i_0_max__ = (logical_gt(num_estimand_levels, 0) ? ((num_all_estimands * sum(stan::model::rvalue(level_size, stan::model::cons_list(stan::model::index_multi(estimand_levels), stan::model::nil_index_list()), "level_size"))) + 1) : 0 );
            for (size_t i_0__ = 0; i_0__ < entity_estimand_csr_row_pos_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "entity_estimand_csr_row_pos[i_0__]", entity_estimand_csr_row_pos[i_0__], 1);
            }
            current_statement_begin__ = 676;
            check_greater_or_equal(function__, "entity_histogram_vec", entity_histogram_vec, -(1));
            check_less_or_equal(function__, "entity_histogram_vec", entity_histogram_vec, 1);
            current_statement_begin__ = 677;
            size_t entity_histogram_ids_i_0_max__ = ((num_discretized_groups * ((2 * num_discretized_variables) + 1)) * num_unique_entities);
            for (size_t i_0__ = 0; i_0__ < entity_histogram_ids_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "entity_histogram_ids[i_0__]", entity_histogram_ids[i_0__], 1);
                check_less_or_equal(function__, "entity_histogram_ids[i_0__]", entity_histogram_ids[i_0__], ((num_atom_estimands * num_unique_entities) + 1));
            }
            current_statement_begin__ = 678;
            size_t entity_histogram_csr_row_pos_i_0_max__ = (logical_gt(num_discretized_groups, 0) ? (((num_discretized_groups * (num_cutpoints - 1)) * num_unique_entities) + 1) : 0 );
            for (size_t i_0__ = 0; i_0__ < entity_histogram_csr_row_pos_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "entity_histogram_csr_row_pos[i_0__]", entity_histogram_csr_row_pos[i_0__], 1);
            }
            current_statement_begin__ = 680;
            check_greater_or_equal(function__, "entity_midpoint_vec", entity_midpoint_vec, min(cutpoint_midpoints));
            check_less_or_equal(function__, "entity_midpoint_vec", entity_midpoint_vec, max(cutpoint_midpoints));
            current_statement_begin__ = 681;
            size_t entity_midpoint_ids_i_0_max__ = ((num_discretized_groups * (num_cutpoints - 1)) * num_unique_entities);
            for (size_t i_0__ = 0; i_0__ < entity_midpoint_ids_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "entity_midpoint_ids[i_0__]", entity_midpoint_ids[i_0__], 1);
                check_less_or_equal(function__, "entity_midpoint_ids[i_0__]", entity_midpoint_ids[i_0__], ((num_discretized_groups * (num_cutpoints - 1)) * num_unique_entities));
            }
            current_statement_begin__ = 682;
            size_t entity_midpoint_csr_row_pos_i_0_max__ = (logical_gt(num_discretized_groups, 0) ? ((num_discretized_groups * num_unique_entities) + 1) : 0 );
            for (size_t i_0__ = 0; i_0__ < entity_midpoint_csr_row_pos_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "entity_midpoint_csr_row_pos[i_0__]", entity_midpoint_csr_row_pos[i_0__], 1);
            }
            current_statement_begin__ = 684;
            check_greater_or_equal(function__, "entity_utility_vec", entity_utility_vec, min(utility));
            check_less_or_equal(function__, "entity_utility_vec", entity_utility_vec, max(utility));
            current_statement_begin__ = 686;
            check_greater_or_equal(function__, "between_entity_diff_csr_vec", between_entity_diff_csr_vec, -(1));
            check_less_or_equal(function__, "between_entity_diff_csr_vec", between_entity_diff_csr_vec, 1);
            current_statement_begin__ = 688;
            size_t between_entity_diff_csr_ids_i_0_max__ = ((2 * num_atom_estimands) * (sum(stan::model::rvalue(level_size, stan::model::cons_list(stan::model::index_multi(between_entity_diff_levels), stan::model::nil_index_list()), "level_size")) - num_between_entity_diff_levels));
            for (size_t i_0__ = 0; i_0__ < between_entity_diff_csr_ids_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "between_entity_diff_csr_ids[i_0__]", between_entity_diff_csr_ids[i_0__], 1);
                check_less_or_equal(function__, "between_entity_diff_csr_ids[i_0__]", between_entity_diff_csr_ids[i_0__], (num_all_estimands * sum(level_size)));
            }
            current_statement_begin__ = 689;
            size_t between_entity_diff_csr_row_pos_i_0_max__ = (logical_gt(num_between_entity_diff_levels, 0) ? ((num_atom_estimands * (sum(stan::model::rvalue(level_size, stan::model::cons_list(stan::model::index_multi(between_entity_diff_levels), stan::model::nil_index_list()), "level_size")) - num_between_entity_diff_levels)) + 1) : 0 );
            for (size_t i_0__ = 0; i_0__ < between_entity_diff_csr_row_pos_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "between_entity_diff_csr_row_pos[i_0__]", between_entity_diff_csr_row_pos[i_0__], 1);
            }
            current_statement_begin__ = 691;
            size_t nonzero_beta_offsets_i_0_max__ = (std::max((num_discretized_r_types - 1), 0) * num_discrete_r_types);
            for (size_t i_0__ = 0; i_0__ < nonzero_beta_offsets_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "nonzero_beta_offsets[i_0__]", nonzero_beta_offsets[i_0__], 2);
            }
            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            current_statement_begin__ = 1031;
            validate_non_negative_index("toplevel_discrete_beta", "(num_discrete_r_types - 1)", (num_discrete_r_types - 1));
            num_params_r__ += (num_discrete_r_types - 1);
            current_statement_begin__ = 1033;
            validate_non_negative_index("discrete_level_beta_raw", "(num_discrete_r_types - 1)", (num_discrete_r_types - 1));
            validate_non_negative_index("discrete_level_beta_raw", "sum(level_size)", sum(level_size));
            num_params_r__ += ((num_discrete_r_types - 1) * sum(level_size));
            current_statement_begin__ = 1034;
            validate_non_negative_index("discrete_level_beta_sigma", "(num_discrete_r_types - 1)", (num_discrete_r_types - 1));
            validate_non_negative_index("discrete_level_beta_sigma", "num_levels", num_levels);
            num_params_r__ += ((num_discrete_r_types - 1) * num_levels);
            current_statement_begin__ = 1036;
            validate_non_negative_index("toplevel_discretized_beta", "std::max(0, (num_discretized_r_types - 1))", std::max(0, (num_discretized_r_types - 1)));
            validate_non_negative_index("toplevel_discretized_beta", "num_discrete_r_types", num_discrete_r_types);
            validate_non_negative_index("toplevel_discretized_beta", "num_discretized_variables", num_discretized_variables);
            num_params_r__ += ((std::max(0, (num_discretized_r_types - 1)) * num_discrete_r_types) * num_discretized_variables);
            current_statement_begin__ = 1038;
            validate_non_negative_index("discretized_level_beta_raw", "(std::max((num_discretized_r_types - 1), 0) * num_discrete_r_types)", (std::max((num_discretized_r_types - 1), 0) * num_discrete_r_types));
            validate_non_negative_index("discretized_level_beta_raw", "sum(level_size)", sum(level_size));
            validate_non_negative_index("discretized_level_beta_raw", "num_discretized_variables", num_discretized_variables);
            num_params_r__ += (((std::max((num_discretized_r_types - 1), 0) * num_discrete_r_types) * sum(level_size)) * num_discretized_variables);
            current_statement_begin__ = 1039;
            validate_non_negative_index("discretized_level_beta_sigma", "std::max((num_discretized_r_types - 1), 0)", std::max((num_discretized_r_types - 1), 0));
            validate_non_negative_index("discretized_level_beta_sigma", "num_levels", num_levels);
            validate_non_negative_index("discretized_level_beta_sigma", "num_discretized_variables", num_discretized_variables);
            num_params_r__ += ((std::max((num_discretized_r_types - 1), 0) * num_levels) * num_discretized_variables);
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }
    ~model_bounded() { }
    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        typedef double local_scalar_t__;
        stan::io::writer<double> writer__(params_r__, params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;
        current_statement_begin__ = 1031;
        if (!(context__.contains_r("toplevel_discrete_beta")))
            stan::lang::rethrow_located(std::runtime_error(std::string("Variable toplevel_discrete_beta missing")), current_statement_begin__, prog_reader__());
        vals_r__ = context__.vals_r("toplevel_discrete_beta");
        pos__ = 0U;
        validate_non_negative_index("toplevel_discrete_beta", "(num_discrete_r_types - 1)", (num_discrete_r_types - 1));
        context__.validate_dims("parameter initialization", "toplevel_discrete_beta", "vector_d", context__.to_vec((num_discrete_r_types - 1)));
        Eigen::Matrix<double, Eigen::Dynamic, 1> toplevel_discrete_beta((num_discrete_r_types - 1));
        size_t toplevel_discrete_beta_j_1_max__ = (num_discrete_r_types - 1);
        for (size_t j_1__ = 0; j_1__ < toplevel_discrete_beta_j_1_max__; ++j_1__) {
            toplevel_discrete_beta(j_1__) = vals_r__[pos__++];
        }
        try {
            writer__.vector_unconstrain(toplevel_discrete_beta);
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(std::runtime_error(std::string("Error transforming variable toplevel_discrete_beta: ") + e.what()), current_statement_begin__, prog_reader__());
        }
        current_statement_begin__ = 1033;
        if (!(context__.contains_r("discrete_level_beta_raw")))
            stan::lang::rethrow_located(std::runtime_error(std::string("Variable discrete_level_beta_raw missing")), current_statement_begin__, prog_reader__());
        vals_r__ = context__.vals_r("discrete_level_beta_raw");
        pos__ = 0U;
        validate_non_negative_index("discrete_level_beta_raw", "(num_discrete_r_types - 1)", (num_discrete_r_types - 1));
        validate_non_negative_index("discrete_level_beta_raw", "sum(level_size)", sum(level_size));
        context__.validate_dims("parameter initialization", "discrete_level_beta_raw", "matrix_d", context__.to_vec((num_discrete_r_types - 1),sum(level_size)));
        Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic> discrete_level_beta_raw((num_discrete_r_types - 1), sum(level_size));
        size_t discrete_level_beta_raw_j_2_max__ = sum(level_size);
        size_t discrete_level_beta_raw_j_1_max__ = (num_discrete_r_types - 1);
        for (size_t j_2__ = 0; j_2__ < discrete_level_beta_raw_j_2_max__; ++j_2__) {
            for (size_t j_1__ = 0; j_1__ < discrete_level_beta_raw_j_1_max__; ++j_1__) {
                discrete_level_beta_raw(j_1__, j_2__) = vals_r__[pos__++];
            }
        }
        try {
            writer__.matrix_unconstrain(discrete_level_beta_raw);
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(std::runtime_error(std::string("Error transforming variable discrete_level_beta_raw: ") + e.what()), current_statement_begin__, prog_reader__());
        }
        current_statement_begin__ = 1034;
        if (!(context__.contains_r("discrete_level_beta_sigma")))
            stan::lang::rethrow_located(std::runtime_error(std::string("Variable discrete_level_beta_sigma missing")), current_statement_begin__, prog_reader__());
        vals_r__ = context__.vals_r("discrete_level_beta_sigma");
        pos__ = 0U;
        validate_non_negative_index("discrete_level_beta_sigma", "(num_discrete_r_types - 1)", (num_discrete_r_types - 1));
        validate_non_negative_index("discrete_level_beta_sigma", "num_levels", num_levels);
        context__.validate_dims("parameter initialization", "discrete_level_beta_sigma", "matrix_d", context__.to_vec((num_discrete_r_types - 1),num_levels));
        Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic> discrete_level_beta_sigma((num_discrete_r_types - 1), num_levels);
        size_t discrete_level_beta_sigma_j_2_max__ = num_levels;
        size_t discrete_level_beta_sigma_j_1_max__ = (num_discrete_r_types - 1);
        for (size_t j_2__ = 0; j_2__ < discrete_level_beta_sigma_j_2_max__; ++j_2__) {
            for (size_t j_1__ = 0; j_1__ < discrete_level_beta_sigma_j_1_max__; ++j_1__) {
                discrete_level_beta_sigma(j_1__, j_2__) = vals_r__[pos__++];
            }
        }
        try {
            writer__.matrix_lb_unconstrain(0, discrete_level_beta_sigma);
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(std::runtime_error(std::string("Error transforming variable discrete_level_beta_sigma: ") + e.what()), current_statement_begin__, prog_reader__());
        }
        current_statement_begin__ = 1036;
        if (!(context__.contains_r("toplevel_discretized_beta")))
            stan::lang::rethrow_located(std::runtime_error(std::string("Variable toplevel_discretized_beta missing")), current_statement_begin__, prog_reader__());
        vals_r__ = context__.vals_r("toplevel_discretized_beta");
        pos__ = 0U;
        validate_non_negative_index("toplevel_discretized_beta", "std::max(0, (num_discretized_r_types - 1))", std::max(0, (num_discretized_r_types - 1)));
        validate_non_negative_index("toplevel_discretized_beta", "num_discrete_r_types", num_discrete_r_types);
        validate_non_negative_index("toplevel_discretized_beta", "num_discretized_variables", num_discretized_variables);
        context__.validate_dims("parameter initialization", "toplevel_discretized_beta", "matrix_d", context__.to_vec(num_discretized_variables,std::max(0, (num_discretized_r_types - 1)),num_discrete_r_types));
        std::vector<Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic> > toplevel_discretized_beta(num_discretized_variables, Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic>(std::max(0, (num_discretized_r_types - 1)), num_discrete_r_types));
        size_t toplevel_discretized_beta_j_2_max__ = num_discrete_r_types;
        size_t toplevel_discretized_beta_j_1_max__ = std::max(0, (num_discretized_r_types - 1));
        size_t toplevel_discretized_beta_k_0_max__ = num_discretized_variables;
        for (size_t j_2__ = 0; j_2__ < toplevel_discretized_beta_j_2_max__; ++j_2__) {
            for (size_t j_1__ = 0; j_1__ < toplevel_discretized_beta_j_1_max__; ++j_1__) {
                for (size_t k_0__ = 0; k_0__ < toplevel_discretized_beta_k_0_max__; ++k_0__) {
                    toplevel_discretized_beta[k_0__](j_1__, j_2__) = vals_r__[pos__++];
                }
            }
        }
        size_t toplevel_discretized_beta_i_0_max__ = num_discretized_variables;
        for (size_t i_0__ = 0; i_0__ < toplevel_discretized_beta_i_0_max__; ++i_0__) {
            try {
                writer__.matrix_unconstrain(toplevel_discretized_beta[i_0__]);
            } catch (const std::exception& e) {
                stan::lang::rethrow_located(std::runtime_error(std::string("Error transforming variable toplevel_discretized_beta: ") + e.what()), current_statement_begin__, prog_reader__());
            }
        }
        current_statement_begin__ = 1038;
        if (!(context__.contains_r("discretized_level_beta_raw")))
            stan::lang::rethrow_located(std::runtime_error(std::string("Variable discretized_level_beta_raw missing")), current_statement_begin__, prog_reader__());
        vals_r__ = context__.vals_r("discretized_level_beta_raw");
        pos__ = 0U;
        validate_non_negative_index("discretized_level_beta_raw", "(std::max((num_discretized_r_types - 1), 0) * num_discrete_r_types)", (std::max((num_discretized_r_types - 1), 0) * num_discrete_r_types));
        validate_non_negative_index("discretized_level_beta_raw", "sum(level_size)", sum(level_size));
        validate_non_negative_index("discretized_level_beta_raw", "num_discretized_variables", num_discretized_variables);
        context__.validate_dims("parameter initialization", "discretized_level_beta_raw", "matrix_d", context__.to_vec(num_discretized_variables,(std::max((num_discretized_r_types - 1), 0) * num_discrete_r_types),sum(level_size)));
        std::vector<Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic> > discretized_level_beta_raw(num_discretized_variables, Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic>((std::max((num_discretized_r_types - 1), 0) * num_discrete_r_types), sum(level_size)));
        size_t discretized_level_beta_raw_j_2_max__ = sum(level_size);
        size_t discretized_level_beta_raw_j_1_max__ = (std::max((num_discretized_r_types - 1), 0) * num_discrete_r_types);
        size_t discretized_level_beta_raw_k_0_max__ = num_discretized_variables;
        for (size_t j_2__ = 0; j_2__ < discretized_level_beta_raw_j_2_max__; ++j_2__) {
            for (size_t j_1__ = 0; j_1__ < discretized_level_beta_raw_j_1_max__; ++j_1__) {
                for (size_t k_0__ = 0; k_0__ < discretized_level_beta_raw_k_0_max__; ++k_0__) {
                    discretized_level_beta_raw[k_0__](j_1__, j_2__) = vals_r__[pos__++];
                }
            }
        }
        size_t discretized_level_beta_raw_i_0_max__ = num_discretized_variables;
        for (size_t i_0__ = 0; i_0__ < discretized_level_beta_raw_i_0_max__; ++i_0__) {
            try {
                writer__.matrix_unconstrain(discretized_level_beta_raw[i_0__]);
            } catch (const std::exception& e) {
                stan::lang::rethrow_located(std::runtime_error(std::string("Error transforming variable discretized_level_beta_raw: ") + e.what()), current_statement_begin__, prog_reader__());
            }
        }
        current_statement_begin__ = 1039;
        if (!(context__.contains_r("discretized_level_beta_sigma")))
            stan::lang::rethrow_located(std::runtime_error(std::string("Variable discretized_level_beta_sigma missing")), current_statement_begin__, prog_reader__());
        vals_r__ = context__.vals_r("discretized_level_beta_sigma");
        pos__ = 0U;
        validate_non_negative_index("discretized_level_beta_sigma", "std::max((num_discretized_r_types - 1), 0)", std::max((num_discretized_r_types - 1), 0));
        validate_non_negative_index("discretized_level_beta_sigma", "num_levels", num_levels);
        validate_non_negative_index("discretized_level_beta_sigma", "num_discretized_variables", num_discretized_variables);
        context__.validate_dims("parameter initialization", "discretized_level_beta_sigma", "matrix_d", context__.to_vec(num_discretized_variables,std::max((num_discretized_r_types - 1), 0),num_levels));
        std::vector<Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic> > discretized_level_beta_sigma(num_discretized_variables, Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic>(std::max((num_discretized_r_types - 1), 0), num_levels));
        size_t discretized_level_beta_sigma_j_2_max__ = num_levels;
        size_t discretized_level_beta_sigma_j_1_max__ = std::max((num_discretized_r_types - 1), 0);
        size_t discretized_level_beta_sigma_k_0_max__ = num_discretized_variables;
        for (size_t j_2__ = 0; j_2__ < discretized_level_beta_sigma_j_2_max__; ++j_2__) {
            for (size_t j_1__ = 0; j_1__ < discretized_level_beta_sigma_j_1_max__; ++j_1__) {
                for (size_t k_0__ = 0; k_0__ < discretized_level_beta_sigma_k_0_max__; ++k_0__) {
                    discretized_level_beta_sigma[k_0__](j_1__, j_2__) = vals_r__[pos__++];
                }
            }
        }
        size_t discretized_level_beta_sigma_i_0_max__ = num_discretized_variables;
        for (size_t i_0__ = 0; i_0__ < discretized_level_beta_sigma_i_0_max__; ++i_0__) {
            try {
                writer__.matrix_lb_unconstrain(0, discretized_level_beta_sigma[i_0__]);
            } catch (const std::exception& e) {
                stan::lang::rethrow_located(std::runtime_error(std::string("Error transforming variable discretized_level_beta_sigma: ") + e.what()), current_statement_begin__, prog_reader__());
            }
        }
        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }
    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }
    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(std::vector<T__>& params_r__,
                 std::vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {
        typedef T__ local_scalar_t__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // dummy to suppress unused var warning
        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;
        try {
            stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
            // model parameters
            current_statement_begin__ = 1031;
            Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> toplevel_discrete_beta;
            (void) toplevel_discrete_beta;  // dummy to suppress unused var warning
            if (jacobian__)
                toplevel_discrete_beta = in__.vector_constrain((num_discrete_r_types - 1), lp__);
            else
                toplevel_discrete_beta = in__.vector_constrain((num_discrete_r_types - 1));
            current_statement_begin__ = 1033;
            Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> discrete_level_beta_raw;
            (void) discrete_level_beta_raw;  // dummy to suppress unused var warning
            if (jacobian__)
                discrete_level_beta_raw = in__.matrix_constrain((num_discrete_r_types - 1), sum(level_size), lp__);
            else
                discrete_level_beta_raw = in__.matrix_constrain((num_discrete_r_types - 1), sum(level_size));
            current_statement_begin__ = 1034;
            Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> discrete_level_beta_sigma;
            (void) discrete_level_beta_sigma;  // dummy to suppress unused var warning
            if (jacobian__)
                discrete_level_beta_sigma = in__.matrix_lb_constrain(0, (num_discrete_r_types - 1), num_levels, lp__);
            else
                discrete_level_beta_sigma = in__.matrix_lb_constrain(0, (num_discrete_r_types - 1), num_levels);
            current_statement_begin__ = 1036;
            std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> > toplevel_discretized_beta;
            size_t toplevel_discretized_beta_d_0_max__ = num_discretized_variables;
            toplevel_discretized_beta.reserve(toplevel_discretized_beta_d_0_max__);
            for (size_t d_0__ = 0; d_0__ < toplevel_discretized_beta_d_0_max__; ++d_0__) {
                if (jacobian__)
                    toplevel_discretized_beta.push_back(in__.matrix_constrain(std::max(0, (num_discretized_r_types - 1)), num_discrete_r_types, lp__));
                else
                    toplevel_discretized_beta.push_back(in__.matrix_constrain(std::max(0, (num_discretized_r_types - 1)), num_discrete_r_types));
            }
            current_statement_begin__ = 1038;
            std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> > discretized_level_beta_raw;
            size_t discretized_level_beta_raw_d_0_max__ = num_discretized_variables;
            discretized_level_beta_raw.reserve(discretized_level_beta_raw_d_0_max__);
            for (size_t d_0__ = 0; d_0__ < discretized_level_beta_raw_d_0_max__; ++d_0__) {
                if (jacobian__)
                    discretized_level_beta_raw.push_back(in__.matrix_constrain((std::max((num_discretized_r_types - 1), 0) * num_discrete_r_types), sum(level_size), lp__));
                else
                    discretized_level_beta_raw.push_back(in__.matrix_constrain((std::max((num_discretized_r_types - 1), 0) * num_discrete_r_types), sum(level_size)));
            }
            current_statement_begin__ = 1039;
            std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> > discretized_level_beta_sigma;
            size_t discretized_level_beta_sigma_d_0_max__ = num_discretized_variables;
            discretized_level_beta_sigma.reserve(discretized_level_beta_sigma_d_0_max__);
            for (size_t d_0__ = 0; d_0__ < discretized_level_beta_sigma_d_0_max__; ++d_0__) {
                if (jacobian__)
                    discretized_level_beta_sigma.push_back(in__.matrix_lb_constrain(0, std::max((num_discretized_r_types - 1), 0), num_levels, lp__));
                else
                    discretized_level_beta_sigma.push_back(in__.matrix_lb_constrain(0, std::max((num_discretized_r_types - 1), 0), num_levels));
            }
            // transformed parameters
            current_statement_begin__ = 1044;
            validate_non_negative_index("r_log_prob", "(num_r_types * num_unique_entities)", (num_r_types * num_unique_entities));
            Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> r_log_prob((num_r_types * num_unique_entities));
            stan::math::initialize(r_log_prob, DUMMY_VAR__);
            stan::math::fill(r_log_prob, DUMMY_VAR__);
            current_statement_begin__ = 1046;
            validate_non_negative_index("entity_candidates_group_logp", "(logical_eq(run_type, RUN_TYPE_FIT) ? sum(num_unique_entity_candidate_groups) : 0 )", (logical_eq(run_type, RUN_TYPE_FIT) ? sum(num_unique_entity_candidate_groups) : 0 ));
            Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> entity_candidates_group_logp((logical_eq(run_type, RUN_TYPE_FIT) ? sum(num_unique_entity_candidate_groups) : 0 ));
            stan::math::initialize(entity_candidates_group_logp, DUMMY_VAR__);
            stan::math::fill(entity_candidates_group_logp, DUMMY_VAR__);
            current_statement_begin__ = 1048;
            validate_non_negative_index("discrete_beta", "num_discrete_r_types", num_discrete_r_types);
            validate_non_negative_index("discrete_beta", "num_unique_entities", num_unique_entities);
            Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> discrete_beta(num_discrete_r_types, num_unique_entities);
            stan::math::initialize(discrete_beta, DUMMY_VAR__);
            stan::math::fill(discrete_beta, DUMMY_VAR__);
            stan::math::assign(discrete_beta,rep_matrix(append_row(0, toplevel_discrete_beta), num_unique_entities));
            current_statement_begin__ = 1050;
            validate_non_negative_index("discretized_beta", "(num_discretized_r_types * num_discrete_r_types)", (num_discretized_r_types * num_discrete_r_types));
            validate_non_negative_index("discretized_beta", "num_unique_entities", num_unique_entities);
            validate_non_negative_index("discretized_beta", "num_discretized_variables", num_discretized_variables);
            std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> > discretized_beta(num_discretized_variables, Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic>((num_discretized_r_types * num_discrete_r_types), num_unique_entities));
            stan::math::initialize(discretized_beta, DUMMY_VAR__);
            stan::math::fill(discretized_beta, DUMMY_VAR__);
            // transformed parameters block statements
            current_statement_begin__ = 1052;
            for (int discretized_var_index = 1; discretized_var_index <= num_discretized_variables; ++discretized_var_index) {
                {
                current_statement_begin__ = 1053;
                validate_non_negative_index("curr_discretized_beta", "num_discretized_r_types", num_discretized_r_types);
                validate_non_negative_index("curr_discretized_beta", "num_discrete_r_types", num_discrete_r_types);
                Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> curr_discretized_beta(num_discretized_r_types, num_discrete_r_types);
                stan::math::initialize(curr_discretized_beta, DUMMY_VAR__);
                stan::math::fill(curr_discretized_beta, DUMMY_VAR__);
                stan::math::assign(curr_discretized_beta,append_row(rep_row_vector(0, num_discrete_r_types), get_base1(toplevel_discretized_beta, discretized_var_index, "toplevel_discretized_beta", 1)));
                current_statement_begin__ = 1056;
                stan::model::assign(discretized_beta, 
                            stan::model::cons_list(stan::model::index_uni(discretized_var_index), stan::model::nil_index_list()), 
                            rep_matrix(to_vector(curr_discretized_beta), num_unique_entities), 
                            "assigning variable discretized_beta");
                }
            }
            current_statement_begin__ = 1059;
            if (as_bool(logical_gt(num_levels, 0))) {
                {
                current_statement_begin__ = 1060;
                int level_entity_pos(0);
                (void) level_entity_pos;  // dummy to suppress unused var warning
                stan::math::fill(level_entity_pos, std::numeric_limits<int>::min());
                stan::math::assign(level_entity_pos,1);
                current_statement_begin__ = 1062;
                for (int level_index = 1; level_index <= num_levels; ++level_index) {
                    {
                    current_statement_begin__ = 1063;
                    int level_entity_end(0);
                    (void) level_entity_end;  // dummy to suppress unused var warning
                    stan::math::fill(level_entity_end, std::numeric_limits<int>::min());
                    stan::math::assign(level_entity_end,((level_entity_pos + get_base1(level_size, level_index, "level_size", 1)) - 1));
                    current_statement_begin__ = 1065;
                    validate_non_negative_index("curr_discrete_level_beta", "(num_discrete_r_types - 1)", (num_discrete_r_types - 1));
                    validate_non_negative_index("curr_discrete_level_beta", "get_base1(level_size, level_index, \"level_size\", 1)", get_base1(level_size, level_index, "level_size", 1));
                    Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> curr_discrete_level_beta((num_discrete_r_types - 1), get_base1(level_size, level_index, "level_size", 1));
                    stan::math::initialize(curr_discrete_level_beta, DUMMY_VAR__);
                    stan::math::fill(curr_discrete_level_beta, DUMMY_VAR__);
                    stan::math::assign(curr_discrete_level_beta,elt_multiply(stan::model::rvalue(discrete_level_beta_raw, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_min_max(level_entity_pos, level_entity_end), stan::model::nil_index_list())), "discrete_level_beta_raw"), rep_matrix(stan::model::rvalue(discrete_level_beta_sigma, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(level_index), stan::model::nil_index_list())), "discrete_level_beta_sigma"), get_base1(level_size, level_index, "level_size", 1))));
                    current_statement_begin__ = 1068;
                    stan::model::assign(discrete_beta, 
                                stan::model::cons_list(stan::model::index_min(2), stan::model::nil_index_list()), 
                                add(stan::model::rvalue(discrete_beta, stan::model::cons_list(stan::model::index_min(2), stan::model::nil_index_list()), "discrete_beta"), stan::model::rvalue(curr_discrete_level_beta, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_multi(stan::model::rvalue(unique_entity_ids, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(level_index), stan::model::nil_index_list())), "unique_entity_ids")), stan::model::nil_index_list())), "curr_discrete_level_beta")), 
                                "assigning variable discrete_beta");
                    current_statement_begin__ = 1070;
                    for (int discretized_var_index = 1; discretized_var_index <= num_discretized_variables; ++discretized_var_index) {
                        {
                        current_statement_begin__ = 1071;
                        validate_non_negative_index("curr_discretized_level_beta", "(std::max((num_discretized_r_types - 1), 0) * num_discrete_r_types)", (std::max((num_discretized_r_types - 1), 0) * num_discrete_r_types));
                        validate_non_negative_index("curr_discretized_level_beta", "get_base1(level_size, level_index, \"level_size\", 1)", get_base1(level_size, level_index, "level_size", 1));
                        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> curr_discretized_level_beta((std::max((num_discretized_r_types - 1), 0) * num_discrete_r_types), get_base1(level_size, level_index, "level_size", 1));
                        stan::math::initialize(curr_discretized_level_beta, DUMMY_VAR__);
                        stan::math::fill(curr_discretized_level_beta, DUMMY_VAR__);
                        stan::math::assign(curr_discretized_level_beta,elt_multiply(stan::model::rvalue(discretized_level_beta_raw, stan::model::cons_list(stan::model::index_uni(discretized_var_index), stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_min_max(level_entity_pos, level_entity_end), stan::model::nil_index_list()))), "discretized_level_beta_raw"), rep_matrix(to_vector(rep_matrix(stan::model::rvalue(discretized_level_beta_sigma, stan::model::cons_list(stan::model::index_uni(discretized_var_index), stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(level_index), stan::model::nil_index_list()))), "discretized_level_beta_sigma"), num_discrete_r_types)), get_base1(level_size, level_index, "level_size", 1))));
                        current_statement_begin__ = 1075;
                        stan::model::assign(discretized_beta, 
                                    stan::model::cons_list(stan::model::index_uni(discretized_var_index), stan::model::cons_list(stan::model::index_multi(nonzero_beta_offsets), stan::model::nil_index_list())), 
                                    add(stan::model::rvalue(discretized_beta, stan::model::cons_list(stan::model::index_uni(discretized_var_index), stan::model::cons_list(stan::model::index_multi(nonzero_beta_offsets), stan::model::nil_index_list())), "discretized_beta"), stan::model::rvalue(curr_discretized_level_beta, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_multi(stan::model::rvalue(unique_entity_ids, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(level_index), stan::model::nil_index_list())), "unique_entity_ids")), stan::model::nil_index_list())), "curr_discretized_level_beta")), 
                                    "assigning variable discretized_beta");
                        }
                    }
                    current_statement_begin__ = 1078;
                    stan::math::assign(level_entity_pos, (level_entity_end + 1));
                    }
                }
                }
            }
            current_statement_begin__ = 1082;
            for (int entity_index = 1; entity_index <= num_unique_entities; ++entity_index) {
                {
                current_statement_begin__ = 1083;
                validate_non_negative_index("curr_discrete_log_prob", "num_discrete_r_types", num_discrete_r_types);
                Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> curr_discrete_log_prob(num_discrete_r_types);
                stan::math::initialize(curr_discrete_log_prob, DUMMY_VAR__);
                stan::math::fill(curr_discrete_log_prob, DUMMY_VAR__);
                stan::math::assign(curr_discrete_log_prob,log_softmax(stan::model::rvalue(discrete_beta, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(entity_index), stan::model::nil_index_list())), "discrete_beta")));
                current_statement_begin__ = 1085;
                if (as_bool(logical_gt(num_discretized_r_types, 0))) {
                    {
                    current_statement_begin__ = 1086;
                    int r_prob_pos(0);
                    (void) r_prob_pos;  // dummy to suppress unused var warning
                    stan::math::fill(r_prob_pos, std::numeric_limits<int>::min());
                    stan::math::assign(r_prob_pos,(((entity_index - 1) * num_r_types) + 1));
                    current_statement_begin__ = 1087;
                    int r_prob_end(0);
                    (void) r_prob_end;  // dummy to suppress unused var warning
                    stan::math::fill(r_prob_end, std::numeric_limits<int>::min());
                    stan::math::assign(r_prob_end,(entity_index * num_r_types));
                    current_statement_begin__ = 1089;
                    stan::model::assign(r_log_prob, 
                                stan::model::cons_list(stan::model::index_min_max(r_prob_pos, r_prob_end), stan::model::nil_index_list()), 
                                calculate_r_type_joint_log_prob(num_r_types, num_discrete_r_types, num_discretized_r_types, discrete_group_size, num_compatible_discretized_r_types, compatible_discretized_r_types, compatible_discretized_pair_ids, curr_discrete_log_prob, discretized_beta, entity_index, pstream__), 
                                "assigning variable r_log_prob");
                    }
                } else {
                    {
                    current_statement_begin__ = 1093;
                    int r_prob_pos(0);
                    (void) r_prob_pos;  // dummy to suppress unused var warning
                    stan::math::fill(r_prob_pos, std::numeric_limits<int>::min());
                    stan::math::assign(r_prob_pos,(((entity_index - 1) * num_r_types) + 1));
                    current_statement_begin__ = 1094;
                    int r_prob_end(0);
                    (void) r_prob_end;  // dummy to suppress unused var warning
                    stan::math::fill(r_prob_end, std::numeric_limits<int>::min());
                    stan::math::assign(r_prob_end,(entity_index * num_r_types));
                    current_statement_begin__ = 1096;
                    stan::model::assign(r_log_prob, 
                                stan::model::cons_list(stan::model::index_min_max(r_prob_pos, r_prob_end), stan::model::nil_index_list()), 
                                stan::model::rvalue(curr_discrete_log_prob, stan::model::cons_list(stan::model::index_multi(discrete_r_type_id), stan::model::nil_index_list()), "curr_discrete_log_prob"), 
                                "assigning variable r_log_prob");
                    }
                }
                }
            }
            current_statement_begin__ = 1100;
            if (as_bool(logical_eq(run_type, RUN_TYPE_FIT))) {
                current_statement_begin__ = 1107;
                stan::math::assign(entity_candidates_group_logp, csr_log_sum_exp(sum(num_unique_entity_candidate_groups), (num_r_types * num_unique_entities), entity_candidate_group_ids, entity_candidate_group_csr_row_pos, r_log_prob, pstream__));
            }
            // validate transformed parameters
            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            current_statement_begin__ = 1044;
            size_t r_log_prob_j_1_max__ = (num_r_types * num_unique_entities);
            for (size_t j_1__ = 0; j_1__ < r_log_prob_j_1_max__; ++j_1__) {
                if (stan::math::is_uninitialized(r_log_prob(j_1__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: r_log_prob" << "(" << j_1__ << ")";
                    stan::lang::rethrow_located(std::runtime_error(std::string("Error initializing variable r_log_prob: ") + msg__.str()), current_statement_begin__, prog_reader__());
                }
            }
            check_less_or_equal(function__, "r_log_prob", r_log_prob, 0);
            current_statement_begin__ = 1046;
            size_t entity_candidates_group_logp_j_1_max__ = (logical_eq(run_type, RUN_TYPE_FIT) ? sum(num_unique_entity_candidate_groups) : 0 );
            for (size_t j_1__ = 0; j_1__ < entity_candidates_group_logp_j_1_max__; ++j_1__) {
                if (stan::math::is_uninitialized(entity_candidates_group_logp(j_1__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: entity_candidates_group_logp" << "(" << j_1__ << ")";
                    stan::lang::rethrow_located(std::runtime_error(std::string("Error initializing variable entity_candidates_group_logp: ") + msg__.str()), current_statement_begin__, prog_reader__());
                }
            }
            current_statement_begin__ = 1048;
            size_t discrete_beta_j_1_max__ = num_discrete_r_types;
            size_t discrete_beta_j_2_max__ = num_unique_entities;
            for (size_t j_1__ = 0; j_1__ < discrete_beta_j_1_max__; ++j_1__) {
                for (size_t j_2__ = 0; j_2__ < discrete_beta_j_2_max__; ++j_2__) {
                    if (stan::math::is_uninitialized(discrete_beta(j_1__, j_2__))) {
                        std::stringstream msg__;
                        msg__ << "Undefined transformed parameter: discrete_beta" << "(" << j_1__ << ", " << j_2__ << ")";
                        stan::lang::rethrow_located(std::runtime_error(std::string("Error initializing variable discrete_beta: ") + msg__.str()), current_statement_begin__, prog_reader__());
                    }
                }
            }
            current_statement_begin__ = 1050;
            size_t discretized_beta_k_0_max__ = num_discretized_variables;
            size_t discretized_beta_j_1_max__ = (num_discretized_r_types * num_discrete_r_types);
            size_t discretized_beta_j_2_max__ = num_unique_entities;
            for (size_t k_0__ = 0; k_0__ < discretized_beta_k_0_max__; ++k_0__) {
                for (size_t j_1__ = 0; j_1__ < discretized_beta_j_1_max__; ++j_1__) {
                    for (size_t j_2__ = 0; j_2__ < discretized_beta_j_2_max__; ++j_2__) {
                        if (stan::math::is_uninitialized(discretized_beta[k_0__](j_1__, j_2__))) {
                            std::stringstream msg__;
                            msg__ << "Undefined transformed parameter: discretized_beta" << "[" << k_0__ << "]" << "(" << j_1__ << ", " << j_2__ << ")";
                            stan::lang::rethrow_located(std::runtime_error(std::string("Error initializing variable discretized_beta: ") + msg__.str()), current_statement_begin__, prog_reader__());
                        }
                    }
                }
            }
            // model body
            current_statement_begin__ = 1116;
            lp_accum__.add(normal_log<propto__>(toplevel_discrete_beta, 0, discrete_beta_hyper_sd));
            current_statement_begin__ = 1118;
            if (as_bool(logical_gt(num_levels, 0))) {
                current_statement_begin__ = 1119;
                lp_accum__.add(std_normal_log<propto__>(to_vector(discrete_level_beta_raw)));
                current_statement_begin__ = 1121;
                for (int level_index = 1; level_index <= num_levels; ++level_index) {
                    current_statement_begin__ = 1122;
                    lp_accum__.add(normal_log<propto__>(stan::model::rvalue(discrete_level_beta_sigma, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(level_index), stan::model::nil_index_list())), "discrete_level_beta_sigma"), 0, get_base1(tau_level_sigma, level_index, "tau_level_sigma", 1)));
                }
            }
            current_statement_begin__ = 1126;
            for (int discretized_var_index = 1; discretized_var_index <= num_discretized_variables; ++discretized_var_index) {
                current_statement_begin__ = 1127;
                lp_accum__.add(normal_log<propto__>(to_vector(get_base1(toplevel_discretized_beta, discretized_var_index, "toplevel_discretized_beta", 1)), 0, discretized_beta_hyper_sd));
                current_statement_begin__ = 1129;
                if (as_bool(logical_gt(num_levels, 0))) {
                    current_statement_begin__ = 1130;
                    lp_accum__.add(std_normal_log<propto__>(to_vector(get_base1(discretized_level_beta_raw, discretized_var_index, "discretized_level_beta_raw", 1))));
                    current_statement_begin__ = 1132;
                    for (int level_index = 1; level_index <= num_levels; ++level_index) {
                        current_statement_begin__ = 1133;
                        lp_accum__.add(normal_log<propto__>(stan::model::rvalue(discretized_level_beta_sigma, stan::model::cons_list(stan::model::index_uni(discretized_var_index), stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(level_index), stan::model::nil_index_list()))), "discretized_level_beta_sigma"), 0, get_base1(tau_level_sigma, level_index, "tau_level_sigma", 1)));
                    }
                }
            }
            current_statement_begin__ = 1138;
            if (as_bool(logical_eq(run_type, RUN_TYPE_FIT))) {
                current_statement_begin__ = 1139;
                lp_accum__.add(multiply(num_unique_entity_in_candidate_groups, entity_candidates_group_logp));
            }
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
        lp_accum__.add(lp__);
        return lp_accum__.sum();
    } // log_prob()
    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }
    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("toplevel_discrete_beta");
        names__.push_back("discrete_level_beta_raw");
        names__.push_back("discrete_level_beta_sigma");
        names__.push_back("toplevel_discretized_beta");
        names__.push_back("discretized_level_beta_raw");
        names__.push_back("discretized_level_beta_sigma");
        names__.push_back("r_log_prob");
        names__.push_back("entity_candidates_group_logp");
        names__.push_back("discrete_beta");
        names__.push_back("discretized_beta");
        names__.push_back("log_lik");
        names__.push_back("total_abducted_log_prob");
        names__.push_back("iter_atom_estimand");
        names__.push_back("iter_diff_estimand");
        names__.push_back("iter_entity_estimand");
        names__.push_back("iter_estimand");
        names__.push_back("iter_level_entity_estimand");
        names__.push_back("iter_level_entity_estimand_sd");
        names__.push_back("iter_between_level_entity_diff_estimand");
        names__.push_back("iter_entity_discretized_histogram_vec");
        names__.push_back("iter_entity_discretized_mean");
        names__.push_back("iter_entity_discretized_utility");
        names__.push_back("iter_mean_diff_estimand");
        names__.push_back("iter_utility_diff_estimand");
        names__.push_back("marginal_p_r");
    }
    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back((num_discrete_r_types - 1));
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back((num_discrete_r_types - 1));
        dims__.push_back(sum(level_size));
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back((num_discrete_r_types - 1));
        dims__.push_back(num_levels);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(num_discretized_variables);
        dims__.push_back(std::max(0, (num_discretized_r_types - 1)));
        dims__.push_back(num_discrete_r_types);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(num_discretized_variables);
        dims__.push_back((std::max((num_discretized_r_types - 1), 0) * num_discrete_r_types));
        dims__.push_back(sum(level_size));
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(num_discretized_variables);
        dims__.push_back(std::max((num_discretized_r_types - 1), 0));
        dims__.push_back(num_levels);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back((num_r_types * num_unique_entities));
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back((logical_eq(run_type, RUN_TYPE_FIT) ? sum(num_unique_entity_candidate_groups) : 0 ));
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(num_discrete_r_types);
        dims__.push_back(num_unique_entities);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(num_discretized_variables);
        dims__.push_back((num_discretized_r_types * num_discrete_r_types));
        dims__.push_back(num_unique_entities);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(((primitive_value(logical_eq(run_type, RUN_TYPE_FIT)) && primitive_value(logical_gt(log_lik_level, -(1)))) ? (logical_gt(log_lik_level, 0) ? get_base1(level_size, log_lik_level, "level_size", 1) : num_obs ) : 0 ));
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back((num_abducted_estimands * num_unique_entities));
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(num_atom_estimands);
        dims__.push_back(num_unique_entities);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(num_diff_estimands);
        dims__.push_back(num_unique_entities);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(num_all_estimands);
        dims__.push_back(num_unique_entities);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(num_all_estimands);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(num_all_estimands);
        dims__.push_back(sum(stan::model::rvalue(level_size, stan::model::cons_list(stan::model::index_multi(estimand_levels), stan::model::nil_index_list()), "level_size")));
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(num_all_estimands);
        dims__.push_back((logical_eq(run_type, RUN_TYPE_PRIOR_PREDICT) ? num_estimand_levels : 0 ));
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(num_atom_estimands);
        dims__.push_back((sum(stan::model::rvalue(level_size, stan::model::cons_list(stan::model::index_multi(between_entity_diff_levels), stan::model::nil_index_list()), "level_size")) - num_between_entity_diff_levels));
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(((num_discretized_groups * (num_cutpoints - 1)) * num_unique_entities));
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(num_discretized_groups);
        dims__.push_back(num_unique_entities);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back((logical_gt(num_discrete_utility_values, 0) ? num_discretized_groups : 0 ));
        dims__.push_back(num_unique_entities);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(num_mean_diff_estimands);
        dims__.push_back(num_unique_entities);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(num_mean_diff_estimands);
        dims__.push_back(num_unique_entities);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back((calculate_marginal_prob ? total_num_bg_variable_types : 0 ));
        dimss__.push_back(dims__);
    }
    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        typedef double local_scalar_t__;
        vars__.resize(0);
        stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
        static const char* function__ = "model_bounded_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        Eigen::Matrix<double, Eigen::Dynamic, 1> toplevel_discrete_beta = in__.vector_constrain((num_discrete_r_types - 1));
        size_t toplevel_discrete_beta_j_1_max__ = (num_discrete_r_types - 1);
        for (size_t j_1__ = 0; j_1__ < toplevel_discrete_beta_j_1_max__; ++j_1__) {
            vars__.push_back(toplevel_discrete_beta(j_1__));
        }
        Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic> discrete_level_beta_raw = in__.matrix_constrain((num_discrete_r_types - 1), sum(level_size));
        size_t discrete_level_beta_raw_j_2_max__ = sum(level_size);
        size_t discrete_level_beta_raw_j_1_max__ = (num_discrete_r_types - 1);
        for (size_t j_2__ = 0; j_2__ < discrete_level_beta_raw_j_2_max__; ++j_2__) {
            for (size_t j_1__ = 0; j_1__ < discrete_level_beta_raw_j_1_max__; ++j_1__) {
                vars__.push_back(discrete_level_beta_raw(j_1__, j_2__));
            }
        }
        Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic> discrete_level_beta_sigma = in__.matrix_lb_constrain(0, (num_discrete_r_types - 1), num_levels);
        size_t discrete_level_beta_sigma_j_2_max__ = num_levels;
        size_t discrete_level_beta_sigma_j_1_max__ = (num_discrete_r_types - 1);
        for (size_t j_2__ = 0; j_2__ < discrete_level_beta_sigma_j_2_max__; ++j_2__) {
            for (size_t j_1__ = 0; j_1__ < discrete_level_beta_sigma_j_1_max__; ++j_1__) {
                vars__.push_back(discrete_level_beta_sigma(j_1__, j_2__));
            }
        }
        std::vector<Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic> > toplevel_discretized_beta;
        size_t toplevel_discretized_beta_d_0_max__ = num_discretized_variables;
        toplevel_discretized_beta.reserve(toplevel_discretized_beta_d_0_max__);
        for (size_t d_0__ = 0; d_0__ < toplevel_discretized_beta_d_0_max__; ++d_0__) {
            toplevel_discretized_beta.push_back(in__.matrix_constrain(std::max(0, (num_discretized_r_types - 1)), num_discrete_r_types));
        }
        size_t toplevel_discretized_beta_j_2_max__ = num_discrete_r_types;
        size_t toplevel_discretized_beta_j_1_max__ = std::max(0, (num_discretized_r_types - 1));
        size_t toplevel_discretized_beta_k_0_max__ = num_discretized_variables;
        for (size_t j_2__ = 0; j_2__ < toplevel_discretized_beta_j_2_max__; ++j_2__) {
            for (size_t j_1__ = 0; j_1__ < toplevel_discretized_beta_j_1_max__; ++j_1__) {
                for (size_t k_0__ = 0; k_0__ < toplevel_discretized_beta_k_0_max__; ++k_0__) {
                    vars__.push_back(toplevel_discretized_beta[k_0__](j_1__, j_2__));
                }
            }
        }
        std::vector<Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic> > discretized_level_beta_raw;
        size_t discretized_level_beta_raw_d_0_max__ = num_discretized_variables;
        discretized_level_beta_raw.reserve(discretized_level_beta_raw_d_0_max__);
        for (size_t d_0__ = 0; d_0__ < discretized_level_beta_raw_d_0_max__; ++d_0__) {
            discretized_level_beta_raw.push_back(in__.matrix_constrain((std::max((num_discretized_r_types - 1), 0) * num_discrete_r_types), sum(level_size)));
        }
        size_t discretized_level_beta_raw_j_2_max__ = sum(level_size);
        size_t discretized_level_beta_raw_j_1_max__ = (std::max((num_discretized_r_types - 1), 0) * num_discrete_r_types);
        size_t discretized_level_beta_raw_k_0_max__ = num_discretized_variables;
        for (size_t j_2__ = 0; j_2__ < discretized_level_beta_raw_j_2_max__; ++j_2__) {
            for (size_t j_1__ = 0; j_1__ < discretized_level_beta_raw_j_1_max__; ++j_1__) {
                for (size_t k_0__ = 0; k_0__ < discretized_level_beta_raw_k_0_max__; ++k_0__) {
                    vars__.push_back(discretized_level_beta_raw[k_0__](j_1__, j_2__));
                }
            }
        }
        std::vector<Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic> > discretized_level_beta_sigma;
        size_t discretized_level_beta_sigma_d_0_max__ = num_discretized_variables;
        discretized_level_beta_sigma.reserve(discretized_level_beta_sigma_d_0_max__);
        for (size_t d_0__ = 0; d_0__ < discretized_level_beta_sigma_d_0_max__; ++d_0__) {
            discretized_level_beta_sigma.push_back(in__.matrix_lb_constrain(0, std::max((num_discretized_r_types - 1), 0), num_levels));
        }
        size_t discretized_level_beta_sigma_j_2_max__ = num_levels;
        size_t discretized_level_beta_sigma_j_1_max__ = std::max((num_discretized_r_types - 1), 0);
        size_t discretized_level_beta_sigma_k_0_max__ = num_discretized_variables;
        for (size_t j_2__ = 0; j_2__ < discretized_level_beta_sigma_j_2_max__; ++j_2__) {
            for (size_t j_1__ = 0; j_1__ < discretized_level_beta_sigma_j_1_max__; ++j_1__) {
                for (size_t k_0__ = 0; k_0__ < discretized_level_beta_sigma_k_0_max__; ++k_0__) {
                    vars__.push_back(discretized_level_beta_sigma[k_0__](j_1__, j_2__));
                }
            }
        }
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
        if (!include_tparams__ && !include_gqs__) return;
        try {
            // declare and define transformed parameters
            current_statement_begin__ = 1044;
            validate_non_negative_index("r_log_prob", "(num_r_types * num_unique_entities)", (num_r_types * num_unique_entities));
            Eigen::Matrix<double, Eigen::Dynamic, 1> r_log_prob((num_r_types * num_unique_entities));
            stan::math::initialize(r_log_prob, DUMMY_VAR__);
            stan::math::fill(r_log_prob, DUMMY_VAR__);
            current_statement_begin__ = 1046;
            validate_non_negative_index("entity_candidates_group_logp", "(logical_eq(run_type, RUN_TYPE_FIT) ? sum(num_unique_entity_candidate_groups) : 0 )", (logical_eq(run_type, RUN_TYPE_FIT) ? sum(num_unique_entity_candidate_groups) : 0 ));
            Eigen::Matrix<double, Eigen::Dynamic, 1> entity_candidates_group_logp((logical_eq(run_type, RUN_TYPE_FIT) ? sum(num_unique_entity_candidate_groups) : 0 ));
            stan::math::initialize(entity_candidates_group_logp, DUMMY_VAR__);
            stan::math::fill(entity_candidates_group_logp, DUMMY_VAR__);
            current_statement_begin__ = 1048;
            validate_non_negative_index("discrete_beta", "num_discrete_r_types", num_discrete_r_types);
            validate_non_negative_index("discrete_beta", "num_unique_entities", num_unique_entities);
            Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic> discrete_beta(num_discrete_r_types, num_unique_entities);
            stan::math::initialize(discrete_beta, DUMMY_VAR__);
            stan::math::fill(discrete_beta, DUMMY_VAR__);
            stan::math::assign(discrete_beta,rep_matrix(append_row(0, toplevel_discrete_beta), num_unique_entities));
            current_statement_begin__ = 1050;
            validate_non_negative_index("discretized_beta", "(num_discretized_r_types * num_discrete_r_types)", (num_discretized_r_types * num_discrete_r_types));
            validate_non_negative_index("discretized_beta", "num_unique_entities", num_unique_entities);
            validate_non_negative_index("discretized_beta", "num_discretized_variables", num_discretized_variables);
            std::vector<Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic> > discretized_beta(num_discretized_variables, Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic>((num_discretized_r_types * num_discrete_r_types), num_unique_entities));
            stan::math::initialize(discretized_beta, DUMMY_VAR__);
            stan::math::fill(discretized_beta, DUMMY_VAR__);
            // do transformed parameters statements
            current_statement_begin__ = 1052;
            for (int discretized_var_index = 1; discretized_var_index <= num_discretized_variables; ++discretized_var_index) {
                {
                current_statement_begin__ = 1053;
                validate_non_negative_index("curr_discretized_beta", "num_discretized_r_types", num_discretized_r_types);
                validate_non_negative_index("curr_discretized_beta", "num_discrete_r_types", num_discrete_r_types);
                Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> curr_discretized_beta(num_discretized_r_types, num_discrete_r_types);
                stan::math::initialize(curr_discretized_beta, DUMMY_VAR__);
                stan::math::fill(curr_discretized_beta, DUMMY_VAR__);
                stan::math::assign(curr_discretized_beta,append_row(rep_row_vector(0, num_discrete_r_types), get_base1(toplevel_discretized_beta, discretized_var_index, "toplevel_discretized_beta", 1)));
                current_statement_begin__ = 1056;
                stan::model::assign(discretized_beta, 
                            stan::model::cons_list(stan::model::index_uni(discretized_var_index), stan::model::nil_index_list()), 
                            rep_matrix(to_vector(curr_discretized_beta), num_unique_entities), 
                            "assigning variable discretized_beta");
                }
            }
            current_statement_begin__ = 1059;
            if (as_bool(logical_gt(num_levels, 0))) {
                {
                current_statement_begin__ = 1060;
                int level_entity_pos(0);
                (void) level_entity_pos;  // dummy to suppress unused var warning
                stan::math::fill(level_entity_pos, std::numeric_limits<int>::min());
                stan::math::assign(level_entity_pos,1);
                current_statement_begin__ = 1062;
                for (int level_index = 1; level_index <= num_levels; ++level_index) {
                    {
                    current_statement_begin__ = 1063;
                    int level_entity_end(0);
                    (void) level_entity_end;  // dummy to suppress unused var warning
                    stan::math::fill(level_entity_end, std::numeric_limits<int>::min());
                    stan::math::assign(level_entity_end,((level_entity_pos + get_base1(level_size, level_index, "level_size", 1)) - 1));
                    current_statement_begin__ = 1065;
                    validate_non_negative_index("curr_discrete_level_beta", "(num_discrete_r_types - 1)", (num_discrete_r_types - 1));
                    validate_non_negative_index("curr_discrete_level_beta", "get_base1(level_size, level_index, \"level_size\", 1)", get_base1(level_size, level_index, "level_size", 1));
                    Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> curr_discrete_level_beta((num_discrete_r_types - 1), get_base1(level_size, level_index, "level_size", 1));
                    stan::math::initialize(curr_discrete_level_beta, DUMMY_VAR__);
                    stan::math::fill(curr_discrete_level_beta, DUMMY_VAR__);
                    stan::math::assign(curr_discrete_level_beta,elt_multiply(stan::model::rvalue(discrete_level_beta_raw, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_min_max(level_entity_pos, level_entity_end), stan::model::nil_index_list())), "discrete_level_beta_raw"), rep_matrix(stan::model::rvalue(discrete_level_beta_sigma, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(level_index), stan::model::nil_index_list())), "discrete_level_beta_sigma"), get_base1(level_size, level_index, "level_size", 1))));
                    current_statement_begin__ = 1068;
                    stan::model::assign(discrete_beta, 
                                stan::model::cons_list(stan::model::index_min(2), stan::model::nil_index_list()), 
                                add(stan::model::rvalue(discrete_beta, stan::model::cons_list(stan::model::index_min(2), stan::model::nil_index_list()), "discrete_beta"), stan::model::rvalue(curr_discrete_level_beta, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_multi(stan::model::rvalue(unique_entity_ids, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(level_index), stan::model::nil_index_list())), "unique_entity_ids")), stan::model::nil_index_list())), "curr_discrete_level_beta")), 
                                "assigning variable discrete_beta");
                    current_statement_begin__ = 1070;
                    for (int discretized_var_index = 1; discretized_var_index <= num_discretized_variables; ++discretized_var_index) {
                        {
                        current_statement_begin__ = 1071;
                        validate_non_negative_index("curr_discretized_level_beta", "(std::max((num_discretized_r_types - 1), 0) * num_discrete_r_types)", (std::max((num_discretized_r_types - 1), 0) * num_discrete_r_types));
                        validate_non_negative_index("curr_discretized_level_beta", "get_base1(level_size, level_index, \"level_size\", 1)", get_base1(level_size, level_index, "level_size", 1));
                        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> curr_discretized_level_beta((std::max((num_discretized_r_types - 1), 0) * num_discrete_r_types), get_base1(level_size, level_index, "level_size", 1));
                        stan::math::initialize(curr_discretized_level_beta, DUMMY_VAR__);
                        stan::math::fill(curr_discretized_level_beta, DUMMY_VAR__);
                        stan::math::assign(curr_discretized_level_beta,elt_multiply(stan::model::rvalue(discretized_level_beta_raw, stan::model::cons_list(stan::model::index_uni(discretized_var_index), stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_min_max(level_entity_pos, level_entity_end), stan::model::nil_index_list()))), "discretized_level_beta_raw"), rep_matrix(to_vector(rep_matrix(stan::model::rvalue(discretized_level_beta_sigma, stan::model::cons_list(stan::model::index_uni(discretized_var_index), stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(level_index), stan::model::nil_index_list()))), "discretized_level_beta_sigma"), num_discrete_r_types)), get_base1(level_size, level_index, "level_size", 1))));
                        current_statement_begin__ = 1075;
                        stan::model::assign(discretized_beta, 
                                    stan::model::cons_list(stan::model::index_uni(discretized_var_index), stan::model::cons_list(stan::model::index_multi(nonzero_beta_offsets), stan::model::nil_index_list())), 
                                    add(stan::model::rvalue(discretized_beta, stan::model::cons_list(stan::model::index_uni(discretized_var_index), stan::model::cons_list(stan::model::index_multi(nonzero_beta_offsets), stan::model::nil_index_list())), "discretized_beta"), stan::model::rvalue(curr_discretized_level_beta, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_multi(stan::model::rvalue(unique_entity_ids, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(level_index), stan::model::nil_index_list())), "unique_entity_ids")), stan::model::nil_index_list())), "curr_discretized_level_beta")), 
                                    "assigning variable discretized_beta");
                        }
                    }
                    current_statement_begin__ = 1078;
                    stan::math::assign(level_entity_pos, (level_entity_end + 1));
                    }
                }
                }
            }
            current_statement_begin__ = 1082;
            for (int entity_index = 1; entity_index <= num_unique_entities; ++entity_index) {
                {
                current_statement_begin__ = 1083;
                validate_non_negative_index("curr_discrete_log_prob", "num_discrete_r_types", num_discrete_r_types);
                Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> curr_discrete_log_prob(num_discrete_r_types);
                stan::math::initialize(curr_discrete_log_prob, DUMMY_VAR__);
                stan::math::fill(curr_discrete_log_prob, DUMMY_VAR__);
                stan::math::assign(curr_discrete_log_prob,log_softmax(stan::model::rvalue(discrete_beta, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(entity_index), stan::model::nil_index_list())), "discrete_beta")));
                current_statement_begin__ = 1085;
                if (as_bool(logical_gt(num_discretized_r_types, 0))) {
                    {
                    current_statement_begin__ = 1086;
                    int r_prob_pos(0);
                    (void) r_prob_pos;  // dummy to suppress unused var warning
                    stan::math::fill(r_prob_pos, std::numeric_limits<int>::min());
                    stan::math::assign(r_prob_pos,(((entity_index - 1) * num_r_types) + 1));
                    current_statement_begin__ = 1087;
                    int r_prob_end(0);
                    (void) r_prob_end;  // dummy to suppress unused var warning
                    stan::math::fill(r_prob_end, std::numeric_limits<int>::min());
                    stan::math::assign(r_prob_end,(entity_index * num_r_types));
                    current_statement_begin__ = 1089;
                    stan::model::assign(r_log_prob, 
                                stan::model::cons_list(stan::model::index_min_max(r_prob_pos, r_prob_end), stan::model::nil_index_list()), 
                                calculate_r_type_joint_log_prob(num_r_types, num_discrete_r_types, num_discretized_r_types, discrete_group_size, num_compatible_discretized_r_types, compatible_discretized_r_types, compatible_discretized_pair_ids, curr_discrete_log_prob, discretized_beta, entity_index, pstream__), 
                                "assigning variable r_log_prob");
                    }
                } else {
                    {
                    current_statement_begin__ = 1093;
                    int r_prob_pos(0);
                    (void) r_prob_pos;  // dummy to suppress unused var warning
                    stan::math::fill(r_prob_pos, std::numeric_limits<int>::min());
                    stan::math::assign(r_prob_pos,(((entity_index - 1) * num_r_types) + 1));
                    current_statement_begin__ = 1094;
                    int r_prob_end(0);
                    (void) r_prob_end;  // dummy to suppress unused var warning
                    stan::math::fill(r_prob_end, std::numeric_limits<int>::min());
                    stan::math::assign(r_prob_end,(entity_index * num_r_types));
                    current_statement_begin__ = 1096;
                    stan::model::assign(r_log_prob, 
                                stan::model::cons_list(stan::model::index_min_max(r_prob_pos, r_prob_end), stan::model::nil_index_list()), 
                                stan::model::rvalue(curr_discrete_log_prob, stan::model::cons_list(stan::model::index_multi(discrete_r_type_id), stan::model::nil_index_list()), "curr_discrete_log_prob"), 
                                "assigning variable r_log_prob");
                    }
                }
                }
            }
            current_statement_begin__ = 1100;
            if (as_bool(logical_eq(run_type, RUN_TYPE_FIT))) {
                current_statement_begin__ = 1107;
                stan::math::assign(entity_candidates_group_logp, csr_log_sum_exp(sum(num_unique_entity_candidate_groups), (num_r_types * num_unique_entities), entity_candidate_group_ids, entity_candidate_group_csr_row_pos, r_log_prob, pstream__));
            }
            if (!include_gqs__ && !include_tparams__) return;
            // validate transformed parameters
            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            current_statement_begin__ = 1044;
            check_less_or_equal(function__, "r_log_prob", r_log_prob, 0);
            // write transformed parameters
            if (include_tparams__) {
                size_t r_log_prob_j_1_max__ = (num_r_types * num_unique_entities);
                for (size_t j_1__ = 0; j_1__ < r_log_prob_j_1_max__; ++j_1__) {
                    vars__.push_back(r_log_prob(j_1__));
                }
                size_t entity_candidates_group_logp_j_1_max__ = (logical_eq(run_type, RUN_TYPE_FIT) ? sum(num_unique_entity_candidate_groups) : 0 );
                for (size_t j_1__ = 0; j_1__ < entity_candidates_group_logp_j_1_max__; ++j_1__) {
                    vars__.push_back(entity_candidates_group_logp(j_1__));
                }
                size_t discrete_beta_j_2_max__ = num_unique_entities;
                size_t discrete_beta_j_1_max__ = num_discrete_r_types;
                for (size_t j_2__ = 0; j_2__ < discrete_beta_j_2_max__; ++j_2__) {
                    for (size_t j_1__ = 0; j_1__ < discrete_beta_j_1_max__; ++j_1__) {
                        vars__.push_back(discrete_beta(j_1__, j_2__));
                    }
                }
                size_t discretized_beta_j_2_max__ = num_unique_entities;
                size_t discretized_beta_j_1_max__ = (num_discretized_r_types * num_discrete_r_types);
                size_t discretized_beta_k_0_max__ = num_discretized_variables;
                for (size_t j_2__ = 0; j_2__ < discretized_beta_j_2_max__; ++j_2__) {
                    for (size_t j_1__ = 0; j_1__ < discretized_beta_j_1_max__; ++j_1__) {
                        for (size_t k_0__ = 0; k_0__ < discretized_beta_k_0_max__; ++k_0__) {
                            vars__.push_back(discretized_beta[k_0__](j_1__, j_2__));
                        }
                    }
                }
            }
            if (!include_gqs__) return;
            // declare and define generated quantities
            current_statement_begin__ = 1144;
            validate_non_negative_index("log_lik", "((primitive_value(logical_eq(run_type, RUN_TYPE_FIT)) && primitive_value(logical_gt(log_lik_level, -(1)))) ? (logical_gt(log_lik_level, 0) ? get_base1(level_size, log_lik_level, \"level_size\", 1) : num_obs ) : 0 )", ((primitive_value(logical_eq(run_type, RUN_TYPE_FIT)) && primitive_value(logical_gt(log_lik_level, -(1)))) ? (logical_gt(log_lik_level, 0) ? get_base1(level_size, log_lik_level, "level_size", 1) : num_obs ) : 0 ));
            Eigen::Matrix<double, Eigen::Dynamic, 1> log_lik(((primitive_value(logical_eq(run_type, RUN_TYPE_FIT)) && primitive_value(logical_gt(log_lik_level, -(1)))) ? (logical_gt(log_lik_level, 0) ? get_base1(level_size, log_lik_level, "level_size", 1) : num_obs ) : 0 ));
            stan::math::initialize(log_lik, DUMMY_VAR__);
            stan::math::fill(log_lik, DUMMY_VAR__);
            current_statement_begin__ = 1147;
            validate_non_negative_index("total_abducted_log_prob", "(num_abducted_estimands * num_unique_entities)", (num_abducted_estimands * num_unique_entities));
            Eigen::Matrix<double, Eigen::Dynamic, 1> total_abducted_log_prob((num_abducted_estimands * num_unique_entities));
            stan::math::initialize(total_abducted_log_prob, DUMMY_VAR__);
            stan::math::fill(total_abducted_log_prob, DUMMY_VAR__);
            current_statement_begin__ = 1150;
            validate_non_negative_index("iter_atom_estimand", "num_atom_estimands", num_atom_estimands);
            validate_non_negative_index("iter_atom_estimand", "num_unique_entities", num_unique_entities);
            Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic> iter_atom_estimand(num_atom_estimands, num_unique_entities);
            stan::math::initialize(iter_atom_estimand, DUMMY_VAR__);
            stan::math::fill(iter_atom_estimand, DUMMY_VAR__);
            current_statement_begin__ = 1152;
            validate_non_negative_index("iter_diff_estimand", "num_diff_estimands", num_diff_estimands);
            validate_non_negative_index("iter_diff_estimand", "num_unique_entities", num_unique_entities);
            Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic> iter_diff_estimand(num_diff_estimands, num_unique_entities);
            stan::math::initialize(iter_diff_estimand, DUMMY_VAR__);
            stan::math::fill(iter_diff_estimand, DUMMY_VAR__);
            current_statement_begin__ = 1154;
            validate_non_negative_index("iter_entity_estimand", "num_all_estimands", num_all_estimands);
            validate_non_negative_index("iter_entity_estimand", "num_unique_entities", num_unique_entities);
            Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic> iter_entity_estimand(num_all_estimands, num_unique_entities);
            stan::math::initialize(iter_entity_estimand, DUMMY_VAR__);
            stan::math::fill(iter_entity_estimand, DUMMY_VAR__);
            current_statement_begin__ = 1155;
            validate_non_negative_index("iter_estimand", "num_all_estimands", num_all_estimands);
            Eigen::Matrix<double, Eigen::Dynamic, 1> iter_estimand(num_all_estimands);
            stan::math::initialize(iter_estimand, DUMMY_VAR__);
            stan::math::fill(iter_estimand, DUMMY_VAR__);
            current_statement_begin__ = 1156;
            validate_non_negative_index("iter_level_entity_estimand", "num_all_estimands", num_all_estimands);
            validate_non_negative_index("iter_level_entity_estimand", "sum(stan::model::rvalue(level_size, stan::model::cons_list(stan::model::index_multi(estimand_levels), stan::model::nil_index_list()), \"level_size\"))", sum(stan::model::rvalue(level_size, stan::model::cons_list(stan::model::index_multi(estimand_levels), stan::model::nil_index_list()), "level_size")));
            Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic> iter_level_entity_estimand(num_all_estimands, sum(stan::model::rvalue(level_size, stan::model::cons_list(stan::model::index_multi(estimand_levels), stan::model::nil_index_list()), "level_size")));
            stan::math::initialize(iter_level_entity_estimand, DUMMY_VAR__);
            stan::math::fill(iter_level_entity_estimand, DUMMY_VAR__);
            current_statement_begin__ = 1157;
            validate_non_negative_index("iter_level_entity_estimand_sd", "num_all_estimands", num_all_estimands);
            validate_non_negative_index("iter_level_entity_estimand_sd", "(logical_eq(run_type, RUN_TYPE_PRIOR_PREDICT) ? num_estimand_levels : 0 )", (logical_eq(run_type, RUN_TYPE_PRIOR_PREDICT) ? num_estimand_levels : 0 ));
            Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic> iter_level_entity_estimand_sd(num_all_estimands, (logical_eq(run_type, RUN_TYPE_PRIOR_PREDICT) ? num_estimand_levels : 0 ));
            stan::math::initialize(iter_level_entity_estimand_sd, DUMMY_VAR__);
            stan::math::fill(iter_level_entity_estimand_sd, DUMMY_VAR__);
            current_statement_begin__ = 1158;
            validate_non_negative_index("iter_between_level_entity_diff_estimand", "num_atom_estimands", num_atom_estimands);
            validate_non_negative_index("iter_between_level_entity_diff_estimand", "(sum(stan::model::rvalue(level_size, stan::model::cons_list(stan::model::index_multi(between_entity_diff_levels), stan::model::nil_index_list()), \"level_size\")) - num_between_entity_diff_levels)", (sum(stan::model::rvalue(level_size, stan::model::cons_list(stan::model::index_multi(between_entity_diff_levels), stan::model::nil_index_list()), "level_size")) - num_between_entity_diff_levels));
            Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic> iter_between_level_entity_diff_estimand(num_atom_estimands, (sum(stan::model::rvalue(level_size, stan::model::cons_list(stan::model::index_multi(between_entity_diff_levels), stan::model::nil_index_list()), "level_size")) - num_between_entity_diff_levels));
            stan::math::initialize(iter_between_level_entity_diff_estimand, DUMMY_VAR__);
            stan::math::fill(iter_between_level_entity_diff_estimand, DUMMY_VAR__);
            current_statement_begin__ = 1162;
            validate_non_negative_index("iter_entity_discretized_histogram_vec", "((num_discretized_groups * (num_cutpoints - 1)) * num_unique_entities)", ((num_discretized_groups * (num_cutpoints - 1)) * num_unique_entities));
            Eigen::Matrix<double, Eigen::Dynamic, 1> iter_entity_discretized_histogram_vec(((num_discretized_groups * (num_cutpoints - 1)) * num_unique_entities));
            stan::math::initialize(iter_entity_discretized_histogram_vec, DUMMY_VAR__);
            stan::math::fill(iter_entity_discretized_histogram_vec, DUMMY_VAR__);
            current_statement_begin__ = 1163;
            validate_non_negative_index("iter_entity_discretized_mean", "num_discretized_groups", num_discretized_groups);
            validate_non_negative_index("iter_entity_discretized_mean", "num_unique_entities", num_unique_entities);
            Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic> iter_entity_discretized_mean(num_discretized_groups, num_unique_entities);
            stan::math::initialize(iter_entity_discretized_mean, DUMMY_VAR__);
            stan::math::fill(iter_entity_discretized_mean, DUMMY_VAR__);
            current_statement_begin__ = 1164;
            validate_non_negative_index("iter_entity_discretized_utility", "(logical_gt(num_discrete_utility_values, 0) ? num_discretized_groups : 0 )", (logical_gt(num_discrete_utility_values, 0) ? num_discretized_groups : 0 ));
            validate_non_negative_index("iter_entity_discretized_utility", "num_unique_entities", num_unique_entities);
            Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic> iter_entity_discretized_utility((logical_gt(num_discrete_utility_values, 0) ? num_discretized_groups : 0 ), num_unique_entities);
            stan::math::initialize(iter_entity_discretized_utility, DUMMY_VAR__);
            stan::math::fill(iter_entity_discretized_utility, DUMMY_VAR__);
            current_statement_begin__ = 1165;
            validate_non_negative_index("iter_mean_diff_estimand", "num_mean_diff_estimands", num_mean_diff_estimands);
            validate_non_negative_index("iter_mean_diff_estimand", "num_unique_entities", num_unique_entities);
            Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic> iter_mean_diff_estimand(num_mean_diff_estimands, num_unique_entities);
            stan::math::initialize(iter_mean_diff_estimand, DUMMY_VAR__);
            stan::math::fill(iter_mean_diff_estimand, DUMMY_VAR__);
            current_statement_begin__ = 1166;
            validate_non_negative_index("iter_utility_diff_estimand", "num_mean_diff_estimands", num_mean_diff_estimands);
            validate_non_negative_index("iter_utility_diff_estimand", "num_unique_entities", num_unique_entities);
            Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic> iter_utility_diff_estimand(num_mean_diff_estimands, num_unique_entities);
            stan::math::initialize(iter_utility_diff_estimand, DUMMY_VAR__);
            stan::math::fill(iter_utility_diff_estimand, DUMMY_VAR__);
            current_statement_begin__ = 1168;
            validate_non_negative_index("marginal_p_r", "(calculate_marginal_prob ? total_num_bg_variable_types : 0 )", (calculate_marginal_prob ? total_num_bg_variable_types : 0 ));
            Eigen::Matrix<double, Eigen::Dynamic, 1> marginal_p_r((calculate_marginal_prob ? total_num_bg_variable_types : 0 ));
            stan::math::initialize(marginal_p_r, DUMMY_VAR__);
            stan::math::fill(marginal_p_r, DUMMY_VAR__);
            // generated quantities statements
            current_statement_begin__ = 1174;
            if (as_bool((primitive_value(logical_eq(run_type, RUN_TYPE_FIT)) && primitive_value(logical_gt(log_lik_level, -(1)))))) {
                current_statement_begin__ = 1175;
                stan::math::assign(log_lik, csr_log_sum_exp(num_obs, (num_r_types * num_unique_entities), obs_candidate_group_ids, obs_candidate_group_csr_row_pos, r_log_prob, pstream__));
            }
            current_statement_begin__ = 1189;
            if (as_bool(logical_gt(num_discrete_estimands, 0))) {
                {
                current_statement_begin__ = 1192;
                validate_non_negative_index("full_r_log_prob", "num_experiment_types", num_experiment_types);
                validate_non_negative_index("full_r_log_prob", "(num_r_types * num_unique_entities)", (num_r_types * num_unique_entities));
                Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> full_r_log_prob(num_experiment_types, (num_r_types * num_unique_entities));
                stan::math::initialize(full_r_log_prob, DUMMY_VAR__);
                stan::math::fill(full_r_log_prob, DUMMY_VAR__);
                stan::math::assign(full_r_log_prob,add(rep_matrix(transpose(r_log_prob), num_experiment_types), rep_matrix(stan::math::log(experiment_types_prob), (num_r_types * num_unique_entities))));
                current_statement_begin__ = 1193;
                validate_non_negative_index("full_r_log_prob_vec", "(num_r_types_full * num_unique_entities)", (num_r_types_full * num_unique_entities));
                Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> full_r_log_prob_vec((num_r_types_full * num_unique_entities));
                stan::math::initialize(full_r_log_prob_vec, DUMMY_VAR__);
                stan::math::fill(full_r_log_prob_vec, DUMMY_VAR__);
                stan::math::assign(full_r_log_prob_vec,to_vector(full_r_log_prob));
                current_statement_begin__ = 1195;
                validate_non_negative_index("iter_atom_log_estimand_vec", "(num_atom_estimands * num_unique_entities)", (num_atom_estimands * num_unique_entities));
                Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> iter_atom_log_estimand_vec((num_atom_estimands * num_unique_entities));
                stan::math::initialize(iter_atom_log_estimand_vec, DUMMY_VAR__);
                stan::math::fill(iter_atom_log_estimand_vec, DUMMY_VAR__);
                stan::math::assign(iter_atom_log_estimand_vec,csr_log_sum_exp((num_atom_estimands * num_unique_entities), (num_r_types_full * num_unique_entities), entity_est_prob_ids, entity_est_prob_csr_row_pos, full_r_log_prob_vec, pstream__));
                current_statement_begin__ = 1208;
                validate_non_negative_index("iter_diff_estimand_vec", "(num_diff_estimands * num_unique_entities)", (num_diff_estimands * num_unique_entities));
                Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> iter_diff_estimand_vec((num_diff_estimands * num_unique_entities));
                stan::math::initialize(iter_diff_estimand_vec, DUMMY_VAR__);
                stan::math::fill(iter_diff_estimand_vec, DUMMY_VAR__);
                current_statement_begin__ = 1210;
                if (as_bool(logical_gt(num_abducted_estimands, 0))) {
                    current_statement_begin__ = 1211;
                    stan::math::assign(total_abducted_log_prob, csr_log_sum_exp((num_abducted_estimands * num_unique_entities), (num_r_types_full * num_unique_entities), entity_abducted_prob_ids, entity_abducted_prob_csr_row_pos, full_r_log_prob_vec, pstream__));
                    current_statement_begin__ = 1226;
                    stan::model::assign(iter_atom_log_estimand_vec, 
                                stan::model::cons_list(stan::model::index_multi(long_entity_abducted_index), stan::model::nil_index_list()), 
                                subtract(stan::model::rvalue(iter_atom_log_estimand_vec, stan::model::cons_list(stan::model::index_multi(long_entity_abducted_index), stan::model::nil_index_list()), "iter_atom_log_estimand_vec"), total_abducted_log_prob), 
                                "assigning variable iter_atom_log_estimand_vec");
                }
                current_statement_begin__ = 1229;
                stan::math::assign(iter_atom_estimand, to_matrix(stan::math::exp(iter_atom_log_estimand_vec), num_atom_estimands, num_unique_entities));
                current_statement_begin__ = 1231;
                if (as_bool(logical_gt(num_diff_estimands, 0))) {
                    current_statement_begin__ = 1232;
                    stan::math::assign(iter_diff_estimand_vec, csr_diff_exp((num_diff_estimands * num_unique_entities), (num_atom_estimands * num_unique_entities), entity_diff_estimand_ids, iter_atom_log_estimand_vec, pstream__));
                    current_statement_begin__ = 1259;
                    stan::math::assign(iter_diff_estimand, to_matrix(iter_diff_estimand_vec, num_diff_estimands, num_unique_entities));
                }
                current_statement_begin__ = 1262;
                if (as_bool(logical_gt(num_discretized_groups, 0))) {
                    {
                    current_statement_begin__ = 1263;
                    validate_non_negative_index("iter_entity_discretized_mean_vec", "(num_discretized_groups * num_unique_entities)", (num_discretized_groups * num_unique_entities));
                    Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> iter_entity_discretized_mean_vec((num_discretized_groups * num_unique_entities));
                    stan::math::initialize(iter_entity_discretized_mean_vec, DUMMY_VAR__);
                    stan::math::fill(iter_entity_discretized_mean_vec, DUMMY_VAR__);
                    current_statement_begin__ = 1265;
                    stan::math::assign(iter_entity_discretized_histogram_vec, csr_matrix_times_vector(((num_discretized_groups * (num_cutpoints - 1)) * num_unique_entities), ((num_atom_estimands * num_unique_entities) + 1), entity_histogram_vec, entity_histogram_ids, entity_histogram_csr_row_pos, append_row(stan::math::exp(iter_atom_log_estimand_vec), 1)));
                    current_statement_begin__ = 1275;
                    stan::math::assign(iter_entity_discretized_mean_vec, csr_matrix_times_vector((num_discretized_groups * num_unique_entities), ((num_discretized_groups * (num_cutpoints - 1)) * num_unique_entities), (use_random_binpoint ? stan::math::promote_scalar<double>(to_vector(uniform_rng(entity_discretize_bin_alpha, entity_discretize_bin_beta, base_rng__))) : stan::math::promote_scalar<double>(entity_midpoint_vec) ), entity_midpoint_ids, entity_midpoint_csr_row_pos, iter_entity_discretized_histogram_vec));
                    current_statement_begin__ = 1284;
                    if (as_bool(logical_gt(num_discrete_utility_values, 0))) {
                        {
                        current_statement_begin__ = 1285;
                        validate_non_negative_index("iter_entity_discretized_utility_vec", "(num_discretized_groups * num_unique_entities)", (num_discretized_groups * num_unique_entities));
                        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> iter_entity_discretized_utility_vec((num_discretized_groups * num_unique_entities));
                        stan::math::initialize(iter_entity_discretized_utility_vec, DUMMY_VAR__);
                        stan::math::fill(iter_entity_discretized_utility_vec, DUMMY_VAR__);
                        stan::math::assign(iter_entity_discretized_utility_vec,csr_matrix_times_vector((num_discretized_groups * num_unique_entities), ((num_discretized_groups * (num_cutpoints - 1)) * num_unique_entities), entity_utility_vec, entity_midpoint_ids, entity_midpoint_csr_row_pos, iter_entity_discretized_histogram_vec));
                        current_statement_begin__ = 1295;
                        stan::math::assign(iter_entity_discretized_utility, to_matrix(iter_entity_discretized_utility_vec, num_discretized_groups, num_unique_entities));
                        current_statement_begin__ = 1297;
                        if (as_bool(logical_gt(num_utility_diff_estimands, 0))) {
                            {
                            current_statement_begin__ = 1298;
                            validate_non_negative_index("iter_utility_diff_estimand_vec", "(num_utility_diff_estimands * num_unique_entities)", (num_utility_diff_estimands * num_unique_entities));
                            Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> iter_utility_diff_estimand_vec((num_utility_diff_estimands * num_unique_entities));
                            stan::math::initialize(iter_utility_diff_estimand_vec, DUMMY_VAR__);
                            stan::math::fill(iter_utility_diff_estimand_vec, DUMMY_VAR__);
                            stan::math::assign(iter_utility_diff_estimand_vec,csr_matrix_times_vector((num_utility_diff_estimands * num_unique_entities), (num_discretized_groups * num_unique_entities), vec_utility_diff, entity_utility_diff_estimand_ids, entity_utility_diff_estimand_csr_row_pos, iter_entity_discretized_utility_vec));
                            current_statement_begin__ = 1306;
                            stan::math::assign(iter_utility_diff_estimand, to_matrix(iter_utility_diff_estimand_vec, num_utility_diff_estimands, num_unique_entities));
                            }
                        }
                        }
                    }
                    current_statement_begin__ = 1310;
                    stan::math::assign(iter_entity_discretized_mean, to_matrix(iter_entity_discretized_mean_vec, num_discretized_groups, num_unique_entities));
                    current_statement_begin__ = 1312;
                    if (as_bool(logical_gt(num_mean_diff_estimands, 0))) {
                        {
                        current_statement_begin__ = 1313;
                        validate_non_negative_index("iter_mean_diff_estimand_vec", "(num_mean_diff_estimands * num_unique_entities)", (num_mean_diff_estimands * num_unique_entities));
                        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> iter_mean_diff_estimand_vec((num_mean_diff_estimands * num_unique_entities));
                        stan::math::initialize(iter_mean_diff_estimand_vec, DUMMY_VAR__);
                        stan::math::fill(iter_mean_diff_estimand_vec, DUMMY_VAR__);
                        stan::math::assign(iter_mean_diff_estimand_vec,csr_matrix_times_vector((num_mean_diff_estimands * num_unique_entities), (num_discretized_groups * num_unique_entities), vec_mean_diff, entity_mean_diff_estimand_ids, entity_mean_diff_estimand_csr_row_pos, iter_entity_discretized_mean_vec));
                        current_statement_begin__ = 1321;
                        stan::math::assign(iter_mean_diff_estimand, to_matrix(iter_mean_diff_estimand_vec, num_mean_diff_estimands, num_unique_entities));
                        }
                    }
                    }
                }
                current_statement_begin__ = 1326;
                stan::math::assign(iter_entity_estimand, append_row(append_row(iter_atom_estimand, append_row(iter_diff_estimand, append_row(iter_entity_discretized_mean, iter_entity_discretized_utility))), append_row(iter_mean_diff_estimand, iter_utility_diff_estimand)));
                current_statement_begin__ = 1340;
                stan::math::assign(iter_estimand, multiply(iter_entity_estimand, unique_entity_prop));
                current_statement_begin__ = 1342;
                if (as_bool(logical_gt(num_estimand_levels, 0))) {
                    {
                    current_statement_begin__ = 1343;
                    validate_non_negative_index("iter_level_entity_estimand_vec", "(num_all_estimands * sum(stan::model::rvalue(level_size, stan::model::cons_list(stan::model::index_multi(estimand_levels), stan::model::nil_index_list()), \"level_size\")))", (num_all_estimands * sum(stan::model::rvalue(level_size, stan::model::cons_list(stan::model::index_multi(estimand_levels), stan::model::nil_index_list()), "level_size"))));
                    Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> iter_level_entity_estimand_vec((num_all_estimands * sum(stan::model::rvalue(level_size, stan::model::cons_list(stan::model::index_multi(estimand_levels), stan::model::nil_index_list()), "level_size"))));
                    stan::math::initialize(iter_level_entity_estimand_vec, DUMMY_VAR__);
                    stan::math::fill(iter_level_entity_estimand_vec, DUMMY_VAR__);
                    stan::math::assign(iter_level_entity_estimand_vec,csr_matrix_times_vector((num_all_estimands * sum(stan::model::rvalue(level_size, stan::model::cons_list(stan::model::index_multi(estimand_levels), stan::model::nil_index_list()), "level_size"))), (num_all_estimands * num_unique_entities), level_estimands_csr_vec, entity_estimand_ids, entity_estimand_csr_row_pos, to_vector(iter_entity_estimand)));
                    current_statement_begin__ = 1353;
                    stan::math::assign(iter_level_entity_estimand, to_matrix(iter_level_entity_estimand_vec, num_all_estimands, sum(stan::model::rvalue(level_size, stan::model::cons_list(stan::model::index_multi(estimand_levels), stan::model::nil_index_list()), "level_size"))));
                    current_statement_begin__ = 1355;
                    if (as_bool(logical_eq(run_type, RUN_TYPE_PRIOR_PREDICT))) {
                        {
                        current_statement_begin__ = 1356;
                        int level_entity_pos(0);
                        (void) level_entity_pos;  // dummy to suppress unused var warning
                        stan::math::fill(level_entity_pos, std::numeric_limits<int>::min());
                        stan::math::assign(level_entity_pos,1);
                        current_statement_begin__ = 1358;
                        for (int est_level_index_index = 1; est_level_index_index <= num_estimand_levels; ++est_level_index_index) {
                            {
                            current_statement_begin__ = 1359;
                            int est_level_index(0);
                            (void) est_level_index;  // dummy to suppress unused var warning
                            stan::math::fill(est_level_index, std::numeric_limits<int>::min());
                            stan::math::assign(est_level_index,get_base1(estimand_levels, est_level_index_index, "estimand_levels", 1));
                            current_statement_begin__ = 1360;
                            int level_entity_end(0);
                            (void) level_entity_end;  // dummy to suppress unused var warning
                            stan::math::fill(level_entity_end, std::numeric_limits<int>::min());
                            stan::math::assign(level_entity_end,((level_entity_pos + get_base1(level_size, est_level_index, "level_size", 1)) - 1));
                            current_statement_begin__ = 1362;
                            validate_non_negative_index("level_entity_means", "num_all_estimands", num_all_estimands);
                            Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> level_entity_means(num_all_estimands);
                            stan::math::initialize(level_entity_means, DUMMY_VAR__);
                            stan::math::fill(level_entity_means, DUMMY_VAR__);
                            stan::math::assign(level_entity_means,multiply(stan::model::rvalue(iter_level_entity_estimand, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_min_max(level_entity_pos, level_entity_end), stan::model::nil_index_list())), "iter_level_entity_estimand"), rep_vector((1.0 / get_base1(level_size, est_level_index, "level_size", 1)), get_base1(level_size, est_level_index, "level_size", 1))));
                            current_statement_begin__ = 1364;
                            stan::model::assign(iter_level_entity_estimand_sd, 
                                        stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(est_level_index), stan::model::nil_index_list())), 
                                        stan::math::sqrt(multiply(square(subtract(stan::model::rvalue(iter_level_entity_estimand, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_min_max(level_entity_pos, level_entity_end), stan::model::nil_index_list())), "iter_level_entity_estimand"), rep_matrix(level_entity_means, get_base1(level_size, est_level_index, "level_size", 1)))), rep_vector((1.0 / (get_base1(level_size, est_level_index, "level_size", 1) - 1)), get_base1(level_size, est_level_index, "level_size", 1)))), 
                                        "assigning variable iter_level_entity_estimand_sd");
                            current_statement_begin__ = 1370;
                            stan::math::assign(level_entity_pos, (level_entity_end + 1));
                            }
                        }
                        }
                    }
                    current_statement_begin__ = 1374;
                    if (as_bool(logical_gt(num_between_entity_diff_levels, 0))) {
                        {
                        current_statement_begin__ = 1375;
                        validate_non_negative_index("iter_between_level_entity_diff_estimand_vec", "(num_atom_estimands * (sum(stan::model::rvalue(level_size, stan::model::cons_list(stan::model::index_multi(between_entity_diff_levels), stan::model::nil_index_list()), \"level_size\")) - num_between_entity_diff_levels))", (num_atom_estimands * (sum(stan::model::rvalue(level_size, stan::model::cons_list(stan::model::index_multi(between_entity_diff_levels), stan::model::nil_index_list()), "level_size")) - num_between_entity_diff_levels)));
                        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> iter_between_level_entity_diff_estimand_vec((num_atom_estimands * (sum(stan::model::rvalue(level_size, stan::model::cons_list(stan::model::index_multi(between_entity_diff_levels), stan::model::nil_index_list()), "level_size")) - num_between_entity_diff_levels)));
                        stan::math::initialize(iter_between_level_entity_diff_estimand_vec, DUMMY_VAR__);
                        stan::math::fill(iter_between_level_entity_diff_estimand_vec, DUMMY_VAR__);
                        stan::math::assign(iter_between_level_entity_diff_estimand_vec,csr_matrix_times_vector((num_atom_estimands * (sum(stan::model::rvalue(level_size, stan::model::cons_list(stan::model::index_multi(between_entity_diff_levels), stan::model::nil_index_list()), "level_size")) - num_between_entity_diff_levels)), (num_all_estimands * sum(stan::model::rvalue(level_size, stan::model::cons_list(stan::model::index_multi(estimand_levels), stan::model::nil_index_list()), "level_size"))), between_entity_diff_csr_vec, between_entity_diff_csr_ids, between_entity_diff_csr_row_pos, iter_level_entity_estimand_vec));
                        current_statement_begin__ = 1385;
                        stan::math::assign(iter_between_level_entity_diff_estimand, to_matrix(iter_between_level_entity_diff_estimand_vec, num_atom_estimands, (sum(stan::model::rvalue(level_size, stan::model::cons_list(stan::model::index_multi(between_entity_diff_levels), stan::model::nil_index_list()), "level_size")) - num_between_entity_diff_levels)));
                        }
                    }
                    }
                }
                }
            }
            current_statement_begin__ = 1390;
            if (as_bool(calculate_marginal_prob)) {
                {
                current_statement_begin__ = 1408;
                validate_non_negative_index("marginal_log_p_r", "total_num_bg_variable_types", total_num_bg_variable_types);
                Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> marginal_log_p_r(total_num_bg_variable_types);
                stan::math::initialize(marginal_log_p_r, DUMMY_VAR__);
                stan::math::fill(marginal_log_p_r, DUMMY_VAR__);
                stan::math::assign(marginal_log_p_r,csr_log_sum_exp2(total_num_bg_variable_types, (num_r_types * num_unique_entities), marginal_prob_csr_vec, entity_marginal_prob_ids, entity_marginal_prob_csr_row_pos, r_log_prob, pstream__));
                current_statement_begin__ = 1422;
                stan::math::assign(marginal_p_r, stan::math::exp(marginal_log_p_r));
                }
            }
            // validate, write generated quantities
            current_statement_begin__ = 1144;
            size_t log_lik_j_1_max__ = ((primitive_value(logical_eq(run_type, RUN_TYPE_FIT)) && primitive_value(logical_gt(log_lik_level, -(1)))) ? (logical_gt(log_lik_level, 0) ? get_base1(level_size, log_lik_level, "level_size", 1) : num_obs ) : 0 );
            for (size_t j_1__ = 0; j_1__ < log_lik_j_1_max__; ++j_1__) {
                vars__.push_back(log_lik(j_1__));
            }
            current_statement_begin__ = 1147;
            check_less_or_equal(function__, "total_abducted_log_prob", total_abducted_log_prob, 0);
            size_t total_abducted_log_prob_j_1_max__ = (num_abducted_estimands * num_unique_entities);
            for (size_t j_1__ = 0; j_1__ < total_abducted_log_prob_j_1_max__; ++j_1__) {
                vars__.push_back(total_abducted_log_prob(j_1__));
            }
            current_statement_begin__ = 1150;
            check_greater_or_equal(function__, "iter_atom_estimand", iter_atom_estimand, 0);
            check_less_or_equal(function__, "iter_atom_estimand", iter_atom_estimand, 1);
            size_t iter_atom_estimand_j_2_max__ = num_unique_entities;
            size_t iter_atom_estimand_j_1_max__ = num_atom_estimands;
            for (size_t j_2__ = 0; j_2__ < iter_atom_estimand_j_2_max__; ++j_2__) {
                for (size_t j_1__ = 0; j_1__ < iter_atom_estimand_j_1_max__; ++j_1__) {
                    vars__.push_back(iter_atom_estimand(j_1__, j_2__));
                }
            }
            current_statement_begin__ = 1152;
            check_greater_or_equal(function__, "iter_diff_estimand", iter_diff_estimand, -(1));
            check_less_or_equal(function__, "iter_diff_estimand", iter_diff_estimand, 1);
            size_t iter_diff_estimand_j_2_max__ = num_unique_entities;
            size_t iter_diff_estimand_j_1_max__ = num_diff_estimands;
            for (size_t j_2__ = 0; j_2__ < iter_diff_estimand_j_2_max__; ++j_2__) {
                for (size_t j_1__ = 0; j_1__ < iter_diff_estimand_j_1_max__; ++j_1__) {
                    vars__.push_back(iter_diff_estimand(j_1__, j_2__));
                }
            }
            current_statement_begin__ = 1154;
            size_t iter_entity_estimand_j_2_max__ = num_unique_entities;
            size_t iter_entity_estimand_j_1_max__ = num_all_estimands;
            for (size_t j_2__ = 0; j_2__ < iter_entity_estimand_j_2_max__; ++j_2__) {
                for (size_t j_1__ = 0; j_1__ < iter_entity_estimand_j_1_max__; ++j_1__) {
                    vars__.push_back(iter_entity_estimand(j_1__, j_2__));
                }
            }
            current_statement_begin__ = 1155;
            size_t iter_estimand_j_1_max__ = num_all_estimands;
            for (size_t j_1__ = 0; j_1__ < iter_estimand_j_1_max__; ++j_1__) {
                vars__.push_back(iter_estimand(j_1__));
            }
            current_statement_begin__ = 1156;
            size_t iter_level_entity_estimand_j_2_max__ = sum(stan::model::rvalue(level_size, stan::model::cons_list(stan::model::index_multi(estimand_levels), stan::model::nil_index_list()), "level_size"));
            size_t iter_level_entity_estimand_j_1_max__ = num_all_estimands;
            for (size_t j_2__ = 0; j_2__ < iter_level_entity_estimand_j_2_max__; ++j_2__) {
                for (size_t j_1__ = 0; j_1__ < iter_level_entity_estimand_j_1_max__; ++j_1__) {
                    vars__.push_back(iter_level_entity_estimand(j_1__, j_2__));
                }
            }
            current_statement_begin__ = 1157;
            size_t iter_level_entity_estimand_sd_j_2_max__ = (logical_eq(run_type, RUN_TYPE_PRIOR_PREDICT) ? num_estimand_levels : 0 );
            size_t iter_level_entity_estimand_sd_j_1_max__ = num_all_estimands;
            for (size_t j_2__ = 0; j_2__ < iter_level_entity_estimand_sd_j_2_max__; ++j_2__) {
                for (size_t j_1__ = 0; j_1__ < iter_level_entity_estimand_sd_j_1_max__; ++j_1__) {
                    vars__.push_back(iter_level_entity_estimand_sd(j_1__, j_2__));
                }
            }
            current_statement_begin__ = 1158;
            size_t iter_between_level_entity_diff_estimand_j_2_max__ = (sum(stan::model::rvalue(level_size, stan::model::cons_list(stan::model::index_multi(between_entity_diff_levels), stan::model::nil_index_list()), "level_size")) - num_between_entity_diff_levels);
            size_t iter_between_level_entity_diff_estimand_j_1_max__ = num_atom_estimands;
            for (size_t j_2__ = 0; j_2__ < iter_between_level_entity_diff_estimand_j_2_max__; ++j_2__) {
                for (size_t j_1__ = 0; j_1__ < iter_between_level_entity_diff_estimand_j_1_max__; ++j_1__) {
                    vars__.push_back(iter_between_level_entity_diff_estimand(j_1__, j_2__));
                }
            }
            current_statement_begin__ = 1162;
            size_t iter_entity_discretized_histogram_vec_j_1_max__ = ((num_discretized_groups * (num_cutpoints - 1)) * num_unique_entities);
            for (size_t j_1__ = 0; j_1__ < iter_entity_discretized_histogram_vec_j_1_max__; ++j_1__) {
                vars__.push_back(iter_entity_discretized_histogram_vec(j_1__));
            }
            current_statement_begin__ = 1163;
            size_t iter_entity_discretized_mean_j_2_max__ = num_unique_entities;
            size_t iter_entity_discretized_mean_j_1_max__ = num_discretized_groups;
            for (size_t j_2__ = 0; j_2__ < iter_entity_discretized_mean_j_2_max__; ++j_2__) {
                for (size_t j_1__ = 0; j_1__ < iter_entity_discretized_mean_j_1_max__; ++j_1__) {
                    vars__.push_back(iter_entity_discretized_mean(j_1__, j_2__));
                }
            }
            current_statement_begin__ = 1164;
            check_greater_or_equal(function__, "iter_entity_discretized_utility", iter_entity_discretized_utility, min(utility));
            check_less_or_equal(function__, "iter_entity_discretized_utility", iter_entity_discretized_utility, max(utility));
            size_t iter_entity_discretized_utility_j_2_max__ = num_unique_entities;
            size_t iter_entity_discretized_utility_j_1_max__ = (logical_gt(num_discrete_utility_values, 0) ? num_discretized_groups : 0 );
            for (size_t j_2__ = 0; j_2__ < iter_entity_discretized_utility_j_2_max__; ++j_2__) {
                for (size_t j_1__ = 0; j_1__ < iter_entity_discretized_utility_j_1_max__; ++j_1__) {
                    vars__.push_back(iter_entity_discretized_utility(j_1__, j_2__));
                }
            }
            current_statement_begin__ = 1165;
            size_t iter_mean_diff_estimand_j_2_max__ = num_unique_entities;
            size_t iter_mean_diff_estimand_j_1_max__ = num_mean_diff_estimands;
            for (size_t j_2__ = 0; j_2__ < iter_mean_diff_estimand_j_2_max__; ++j_2__) {
                for (size_t j_1__ = 0; j_1__ < iter_mean_diff_estimand_j_1_max__; ++j_1__) {
                    vars__.push_back(iter_mean_diff_estimand(j_1__, j_2__));
                }
            }
            current_statement_begin__ = 1166;
            size_t iter_utility_diff_estimand_j_2_max__ = num_unique_entities;
            size_t iter_utility_diff_estimand_j_1_max__ = num_mean_diff_estimands;
            for (size_t j_2__ = 0; j_2__ < iter_utility_diff_estimand_j_2_max__; ++j_2__) {
                for (size_t j_1__ = 0; j_1__ < iter_utility_diff_estimand_j_1_max__; ++j_1__) {
                    vars__.push_back(iter_utility_diff_estimand(j_1__, j_2__));
                }
            }
            current_statement_begin__ = 1168;
            check_greater_or_equal(function__, "marginal_p_r", marginal_p_r, 0);
            check_less_or_equal(function__, "marginal_p_r", marginal_p_r, 1);
            size_t marginal_p_r_j_1_max__ = (calculate_marginal_prob ? total_num_bg_variable_types : 0 );
            for (size_t j_1__ = 0; j_1__ < marginal_p_r_j_1_max__; ++j_1__) {
                vars__.push_back(marginal_p_r(j_1__));
            }
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }
    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng, params_r_vec, params_i_vec, vars_vec, include_tparams, include_gqs, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }
    static std::string model_name() {
        return "model_bounded";
    }
    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        size_t toplevel_discrete_beta_j_1_max__ = (num_discrete_r_types - 1);
        for (size_t j_1__ = 0; j_1__ < toplevel_discrete_beta_j_1_max__; ++j_1__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "toplevel_discrete_beta" << '.' << j_1__ + 1;
            param_names__.push_back(param_name_stream__.str());
        }
        size_t discrete_level_beta_raw_j_2_max__ = sum(level_size);
        size_t discrete_level_beta_raw_j_1_max__ = (num_discrete_r_types - 1);
        for (size_t j_2__ = 0; j_2__ < discrete_level_beta_raw_j_2_max__; ++j_2__) {
            for (size_t j_1__ = 0; j_1__ < discrete_level_beta_raw_j_1_max__; ++j_1__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "discrete_level_beta_raw" << '.' << j_1__ + 1 << '.' << j_2__ + 1;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        size_t discrete_level_beta_sigma_j_2_max__ = num_levels;
        size_t discrete_level_beta_sigma_j_1_max__ = (num_discrete_r_types - 1);
        for (size_t j_2__ = 0; j_2__ < discrete_level_beta_sigma_j_2_max__; ++j_2__) {
            for (size_t j_1__ = 0; j_1__ < discrete_level_beta_sigma_j_1_max__; ++j_1__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "discrete_level_beta_sigma" << '.' << j_1__ + 1 << '.' << j_2__ + 1;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        size_t toplevel_discretized_beta_j_2_max__ = num_discrete_r_types;
        size_t toplevel_discretized_beta_j_1_max__ = std::max(0, (num_discretized_r_types - 1));
        size_t toplevel_discretized_beta_k_0_max__ = num_discretized_variables;
        for (size_t j_2__ = 0; j_2__ < toplevel_discretized_beta_j_2_max__; ++j_2__) {
            for (size_t j_1__ = 0; j_1__ < toplevel_discretized_beta_j_1_max__; ++j_1__) {
                for (size_t k_0__ = 0; k_0__ < toplevel_discretized_beta_k_0_max__; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "toplevel_discretized_beta" << '.' << k_0__ + 1 << '.' << j_1__ + 1 << '.' << j_2__ + 1;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }
        size_t discretized_level_beta_raw_j_2_max__ = sum(level_size);
        size_t discretized_level_beta_raw_j_1_max__ = (std::max((num_discretized_r_types - 1), 0) * num_discrete_r_types);
        size_t discretized_level_beta_raw_k_0_max__ = num_discretized_variables;
        for (size_t j_2__ = 0; j_2__ < discretized_level_beta_raw_j_2_max__; ++j_2__) {
            for (size_t j_1__ = 0; j_1__ < discretized_level_beta_raw_j_1_max__; ++j_1__) {
                for (size_t k_0__ = 0; k_0__ < discretized_level_beta_raw_k_0_max__; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "discretized_level_beta_raw" << '.' << k_0__ + 1 << '.' << j_1__ + 1 << '.' << j_2__ + 1;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }
        size_t discretized_level_beta_sigma_j_2_max__ = num_levels;
        size_t discretized_level_beta_sigma_j_1_max__ = std::max((num_discretized_r_types - 1), 0);
        size_t discretized_level_beta_sigma_k_0_max__ = num_discretized_variables;
        for (size_t j_2__ = 0; j_2__ < discretized_level_beta_sigma_j_2_max__; ++j_2__) {
            for (size_t j_1__ = 0; j_1__ < discretized_level_beta_sigma_j_1_max__; ++j_1__) {
                for (size_t k_0__ = 0; k_0__ < discretized_level_beta_sigma_k_0_max__; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "discretized_level_beta_sigma" << '.' << k_0__ + 1 << '.' << j_1__ + 1 << '.' << j_2__ + 1;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }
        if (!include_gqs__ && !include_tparams__) return;
        if (include_tparams__) {
            size_t r_log_prob_j_1_max__ = (num_r_types * num_unique_entities);
            for (size_t j_1__ = 0; j_1__ < r_log_prob_j_1_max__; ++j_1__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "r_log_prob" << '.' << j_1__ + 1;
                param_names__.push_back(param_name_stream__.str());
            }
            size_t entity_candidates_group_logp_j_1_max__ = (logical_eq(run_type, RUN_TYPE_FIT) ? sum(num_unique_entity_candidate_groups) : 0 );
            for (size_t j_1__ = 0; j_1__ < entity_candidates_group_logp_j_1_max__; ++j_1__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "entity_candidates_group_logp" << '.' << j_1__ + 1;
                param_names__.push_back(param_name_stream__.str());
            }
            size_t discrete_beta_j_2_max__ = num_unique_entities;
            size_t discrete_beta_j_1_max__ = num_discrete_r_types;
            for (size_t j_2__ = 0; j_2__ < discrete_beta_j_2_max__; ++j_2__) {
                for (size_t j_1__ = 0; j_1__ < discrete_beta_j_1_max__; ++j_1__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "discrete_beta" << '.' << j_1__ + 1 << '.' << j_2__ + 1;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
            size_t discretized_beta_j_2_max__ = num_unique_entities;
            size_t discretized_beta_j_1_max__ = (num_discretized_r_types * num_discrete_r_types);
            size_t discretized_beta_k_0_max__ = num_discretized_variables;
            for (size_t j_2__ = 0; j_2__ < discretized_beta_j_2_max__; ++j_2__) {
                for (size_t j_1__ = 0; j_1__ < discretized_beta_j_1_max__; ++j_1__) {
                    for (size_t k_0__ = 0; k_0__ < discretized_beta_k_0_max__; ++k_0__) {
                        param_name_stream__.str(std::string());
                        param_name_stream__ << "discretized_beta" << '.' << k_0__ + 1 << '.' << j_1__ + 1 << '.' << j_2__ + 1;
                        param_names__.push_back(param_name_stream__.str());
                    }
                }
            }
        }
        if (!include_gqs__) return;
        size_t log_lik_j_1_max__ = ((primitive_value(logical_eq(run_type, RUN_TYPE_FIT)) && primitive_value(logical_gt(log_lik_level, -(1)))) ? (logical_gt(log_lik_level, 0) ? get_base1(level_size, log_lik_level, "level_size", 1) : num_obs ) : 0 );
        for (size_t j_1__ = 0; j_1__ < log_lik_j_1_max__; ++j_1__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << j_1__ + 1;
            param_names__.push_back(param_name_stream__.str());
        }
        size_t total_abducted_log_prob_j_1_max__ = (num_abducted_estimands * num_unique_entities);
        for (size_t j_1__ = 0; j_1__ < total_abducted_log_prob_j_1_max__; ++j_1__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "total_abducted_log_prob" << '.' << j_1__ + 1;
            param_names__.push_back(param_name_stream__.str());
        }
        size_t iter_atom_estimand_j_2_max__ = num_unique_entities;
        size_t iter_atom_estimand_j_1_max__ = num_atom_estimands;
        for (size_t j_2__ = 0; j_2__ < iter_atom_estimand_j_2_max__; ++j_2__) {
            for (size_t j_1__ = 0; j_1__ < iter_atom_estimand_j_1_max__; ++j_1__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "iter_atom_estimand" << '.' << j_1__ + 1 << '.' << j_2__ + 1;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        size_t iter_diff_estimand_j_2_max__ = num_unique_entities;
        size_t iter_diff_estimand_j_1_max__ = num_diff_estimands;
        for (size_t j_2__ = 0; j_2__ < iter_diff_estimand_j_2_max__; ++j_2__) {
            for (size_t j_1__ = 0; j_1__ < iter_diff_estimand_j_1_max__; ++j_1__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "iter_diff_estimand" << '.' << j_1__ + 1 << '.' << j_2__ + 1;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        size_t iter_entity_estimand_j_2_max__ = num_unique_entities;
        size_t iter_entity_estimand_j_1_max__ = num_all_estimands;
        for (size_t j_2__ = 0; j_2__ < iter_entity_estimand_j_2_max__; ++j_2__) {
            for (size_t j_1__ = 0; j_1__ < iter_entity_estimand_j_1_max__; ++j_1__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "iter_entity_estimand" << '.' << j_1__ + 1 << '.' << j_2__ + 1;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        size_t iter_estimand_j_1_max__ = num_all_estimands;
        for (size_t j_1__ = 0; j_1__ < iter_estimand_j_1_max__; ++j_1__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "iter_estimand" << '.' << j_1__ + 1;
            param_names__.push_back(param_name_stream__.str());
        }
        size_t iter_level_entity_estimand_j_2_max__ = sum(stan::model::rvalue(level_size, stan::model::cons_list(stan::model::index_multi(estimand_levels), stan::model::nil_index_list()), "level_size"));
        size_t iter_level_entity_estimand_j_1_max__ = num_all_estimands;
        for (size_t j_2__ = 0; j_2__ < iter_level_entity_estimand_j_2_max__; ++j_2__) {
            for (size_t j_1__ = 0; j_1__ < iter_level_entity_estimand_j_1_max__; ++j_1__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "iter_level_entity_estimand" << '.' << j_1__ + 1 << '.' << j_2__ + 1;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        size_t iter_level_entity_estimand_sd_j_2_max__ = (logical_eq(run_type, RUN_TYPE_PRIOR_PREDICT) ? num_estimand_levels : 0 );
        size_t iter_level_entity_estimand_sd_j_1_max__ = num_all_estimands;
        for (size_t j_2__ = 0; j_2__ < iter_level_entity_estimand_sd_j_2_max__; ++j_2__) {
            for (size_t j_1__ = 0; j_1__ < iter_level_entity_estimand_sd_j_1_max__; ++j_1__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "iter_level_entity_estimand_sd" << '.' << j_1__ + 1 << '.' << j_2__ + 1;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        size_t iter_between_level_entity_diff_estimand_j_2_max__ = (sum(stan::model::rvalue(level_size, stan::model::cons_list(stan::model::index_multi(between_entity_diff_levels), stan::model::nil_index_list()), "level_size")) - num_between_entity_diff_levels);
        size_t iter_between_level_entity_diff_estimand_j_1_max__ = num_atom_estimands;
        for (size_t j_2__ = 0; j_2__ < iter_between_level_entity_diff_estimand_j_2_max__; ++j_2__) {
            for (size_t j_1__ = 0; j_1__ < iter_between_level_entity_diff_estimand_j_1_max__; ++j_1__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "iter_between_level_entity_diff_estimand" << '.' << j_1__ + 1 << '.' << j_2__ + 1;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        size_t iter_entity_discretized_histogram_vec_j_1_max__ = ((num_discretized_groups * (num_cutpoints - 1)) * num_unique_entities);
        for (size_t j_1__ = 0; j_1__ < iter_entity_discretized_histogram_vec_j_1_max__; ++j_1__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "iter_entity_discretized_histogram_vec" << '.' << j_1__ + 1;
            param_names__.push_back(param_name_stream__.str());
        }
        size_t iter_entity_discretized_mean_j_2_max__ = num_unique_entities;
        size_t iter_entity_discretized_mean_j_1_max__ = num_discretized_groups;
        for (size_t j_2__ = 0; j_2__ < iter_entity_discretized_mean_j_2_max__; ++j_2__) {
            for (size_t j_1__ = 0; j_1__ < iter_entity_discretized_mean_j_1_max__; ++j_1__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "iter_entity_discretized_mean" << '.' << j_1__ + 1 << '.' << j_2__ + 1;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        size_t iter_entity_discretized_utility_j_2_max__ = num_unique_entities;
        size_t iter_entity_discretized_utility_j_1_max__ = (logical_gt(num_discrete_utility_values, 0) ? num_discretized_groups : 0 );
        for (size_t j_2__ = 0; j_2__ < iter_entity_discretized_utility_j_2_max__; ++j_2__) {
            for (size_t j_1__ = 0; j_1__ < iter_entity_discretized_utility_j_1_max__; ++j_1__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "iter_entity_discretized_utility" << '.' << j_1__ + 1 << '.' << j_2__ + 1;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        size_t iter_mean_diff_estimand_j_2_max__ = num_unique_entities;
        size_t iter_mean_diff_estimand_j_1_max__ = num_mean_diff_estimands;
        for (size_t j_2__ = 0; j_2__ < iter_mean_diff_estimand_j_2_max__; ++j_2__) {
            for (size_t j_1__ = 0; j_1__ < iter_mean_diff_estimand_j_1_max__; ++j_1__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "iter_mean_diff_estimand" << '.' << j_1__ + 1 << '.' << j_2__ + 1;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        size_t iter_utility_diff_estimand_j_2_max__ = num_unique_entities;
        size_t iter_utility_diff_estimand_j_1_max__ = num_mean_diff_estimands;
        for (size_t j_2__ = 0; j_2__ < iter_utility_diff_estimand_j_2_max__; ++j_2__) {
            for (size_t j_1__ = 0; j_1__ < iter_utility_diff_estimand_j_1_max__; ++j_1__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "iter_utility_diff_estimand" << '.' << j_1__ + 1 << '.' << j_2__ + 1;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        size_t marginal_p_r_j_1_max__ = (calculate_marginal_prob ? total_num_bg_variable_types : 0 );
        for (size_t j_1__ = 0; j_1__ < marginal_p_r_j_1_max__; ++j_1__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "marginal_p_r" << '.' << j_1__ + 1;
            param_names__.push_back(param_name_stream__.str());
        }
    }
    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        size_t toplevel_discrete_beta_j_1_max__ = (num_discrete_r_types - 1);
        for (size_t j_1__ = 0; j_1__ < toplevel_discrete_beta_j_1_max__; ++j_1__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "toplevel_discrete_beta" << '.' << j_1__ + 1;
            param_names__.push_back(param_name_stream__.str());
        }
        size_t discrete_level_beta_raw_j_2_max__ = sum(level_size);
        size_t discrete_level_beta_raw_j_1_max__ = (num_discrete_r_types - 1);
        for (size_t j_2__ = 0; j_2__ < discrete_level_beta_raw_j_2_max__; ++j_2__) {
            for (size_t j_1__ = 0; j_1__ < discrete_level_beta_raw_j_1_max__; ++j_1__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "discrete_level_beta_raw" << '.' << j_1__ + 1 << '.' << j_2__ + 1;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        size_t discrete_level_beta_sigma_j_2_max__ = num_levels;
        size_t discrete_level_beta_sigma_j_1_max__ = (num_discrete_r_types - 1);
        for (size_t j_2__ = 0; j_2__ < discrete_level_beta_sigma_j_2_max__; ++j_2__) {
            for (size_t j_1__ = 0; j_1__ < discrete_level_beta_sigma_j_1_max__; ++j_1__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "discrete_level_beta_sigma" << '.' << j_1__ + 1 << '.' << j_2__ + 1;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        size_t toplevel_discretized_beta_j_2_max__ = num_discrete_r_types;
        size_t toplevel_discretized_beta_j_1_max__ = std::max(0, (num_discretized_r_types - 1));
        size_t toplevel_discretized_beta_k_0_max__ = num_discretized_variables;
        for (size_t j_2__ = 0; j_2__ < toplevel_discretized_beta_j_2_max__; ++j_2__) {
            for (size_t j_1__ = 0; j_1__ < toplevel_discretized_beta_j_1_max__; ++j_1__) {
                for (size_t k_0__ = 0; k_0__ < toplevel_discretized_beta_k_0_max__; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "toplevel_discretized_beta" << '.' << k_0__ + 1 << '.' << j_1__ + 1 << '.' << j_2__ + 1;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }
        size_t discretized_level_beta_raw_j_2_max__ = sum(level_size);
        size_t discretized_level_beta_raw_j_1_max__ = (std::max((num_discretized_r_types - 1), 0) * num_discrete_r_types);
        size_t discretized_level_beta_raw_k_0_max__ = num_discretized_variables;
        for (size_t j_2__ = 0; j_2__ < discretized_level_beta_raw_j_2_max__; ++j_2__) {
            for (size_t j_1__ = 0; j_1__ < discretized_level_beta_raw_j_1_max__; ++j_1__) {
                for (size_t k_0__ = 0; k_0__ < discretized_level_beta_raw_k_0_max__; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "discretized_level_beta_raw" << '.' << k_0__ + 1 << '.' << j_1__ + 1 << '.' << j_2__ + 1;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }
        size_t discretized_level_beta_sigma_j_2_max__ = num_levels;
        size_t discretized_level_beta_sigma_j_1_max__ = std::max((num_discretized_r_types - 1), 0);
        size_t discretized_level_beta_sigma_k_0_max__ = num_discretized_variables;
        for (size_t j_2__ = 0; j_2__ < discretized_level_beta_sigma_j_2_max__; ++j_2__) {
            for (size_t j_1__ = 0; j_1__ < discretized_level_beta_sigma_j_1_max__; ++j_1__) {
                for (size_t k_0__ = 0; k_0__ < discretized_level_beta_sigma_k_0_max__; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "discretized_level_beta_sigma" << '.' << k_0__ + 1 << '.' << j_1__ + 1 << '.' << j_2__ + 1;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }
        if (!include_gqs__ && !include_tparams__) return;
        if (include_tparams__) {
            size_t r_log_prob_j_1_max__ = (num_r_types * num_unique_entities);
            for (size_t j_1__ = 0; j_1__ < r_log_prob_j_1_max__; ++j_1__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "r_log_prob" << '.' << j_1__ + 1;
                param_names__.push_back(param_name_stream__.str());
            }
            size_t entity_candidates_group_logp_j_1_max__ = (logical_eq(run_type, RUN_TYPE_FIT) ? sum(num_unique_entity_candidate_groups) : 0 );
            for (size_t j_1__ = 0; j_1__ < entity_candidates_group_logp_j_1_max__; ++j_1__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "entity_candidates_group_logp" << '.' << j_1__ + 1;
                param_names__.push_back(param_name_stream__.str());
            }
            size_t discrete_beta_j_2_max__ = num_unique_entities;
            size_t discrete_beta_j_1_max__ = num_discrete_r_types;
            for (size_t j_2__ = 0; j_2__ < discrete_beta_j_2_max__; ++j_2__) {
                for (size_t j_1__ = 0; j_1__ < discrete_beta_j_1_max__; ++j_1__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "discrete_beta" << '.' << j_1__ + 1 << '.' << j_2__ + 1;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
            size_t discretized_beta_j_2_max__ = num_unique_entities;
            size_t discretized_beta_j_1_max__ = (num_discretized_r_types * num_discrete_r_types);
            size_t discretized_beta_k_0_max__ = num_discretized_variables;
            for (size_t j_2__ = 0; j_2__ < discretized_beta_j_2_max__; ++j_2__) {
                for (size_t j_1__ = 0; j_1__ < discretized_beta_j_1_max__; ++j_1__) {
                    for (size_t k_0__ = 0; k_0__ < discretized_beta_k_0_max__; ++k_0__) {
                        param_name_stream__.str(std::string());
                        param_name_stream__ << "discretized_beta" << '.' << k_0__ + 1 << '.' << j_1__ + 1 << '.' << j_2__ + 1;
                        param_names__.push_back(param_name_stream__.str());
                    }
                }
            }
        }
        if (!include_gqs__) return;
        size_t log_lik_j_1_max__ = ((primitive_value(logical_eq(run_type, RUN_TYPE_FIT)) && primitive_value(logical_gt(log_lik_level, -(1)))) ? (logical_gt(log_lik_level, 0) ? get_base1(level_size, log_lik_level, "level_size", 1) : num_obs ) : 0 );
        for (size_t j_1__ = 0; j_1__ < log_lik_j_1_max__; ++j_1__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "log_lik" << '.' << j_1__ + 1;
            param_names__.push_back(param_name_stream__.str());
        }
        size_t total_abducted_log_prob_j_1_max__ = (num_abducted_estimands * num_unique_entities);
        for (size_t j_1__ = 0; j_1__ < total_abducted_log_prob_j_1_max__; ++j_1__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "total_abducted_log_prob" << '.' << j_1__ + 1;
            param_names__.push_back(param_name_stream__.str());
        }
        size_t iter_atom_estimand_j_2_max__ = num_unique_entities;
        size_t iter_atom_estimand_j_1_max__ = num_atom_estimands;
        for (size_t j_2__ = 0; j_2__ < iter_atom_estimand_j_2_max__; ++j_2__) {
            for (size_t j_1__ = 0; j_1__ < iter_atom_estimand_j_1_max__; ++j_1__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "iter_atom_estimand" << '.' << j_1__ + 1 << '.' << j_2__ + 1;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        size_t iter_diff_estimand_j_2_max__ = num_unique_entities;
        size_t iter_diff_estimand_j_1_max__ = num_diff_estimands;
        for (size_t j_2__ = 0; j_2__ < iter_diff_estimand_j_2_max__; ++j_2__) {
            for (size_t j_1__ = 0; j_1__ < iter_diff_estimand_j_1_max__; ++j_1__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "iter_diff_estimand" << '.' << j_1__ + 1 << '.' << j_2__ + 1;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        size_t iter_entity_estimand_j_2_max__ = num_unique_entities;
        size_t iter_entity_estimand_j_1_max__ = num_all_estimands;
        for (size_t j_2__ = 0; j_2__ < iter_entity_estimand_j_2_max__; ++j_2__) {
            for (size_t j_1__ = 0; j_1__ < iter_entity_estimand_j_1_max__; ++j_1__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "iter_entity_estimand" << '.' << j_1__ + 1 << '.' << j_2__ + 1;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        size_t iter_estimand_j_1_max__ = num_all_estimands;
        for (size_t j_1__ = 0; j_1__ < iter_estimand_j_1_max__; ++j_1__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "iter_estimand" << '.' << j_1__ + 1;
            param_names__.push_back(param_name_stream__.str());
        }
        size_t iter_level_entity_estimand_j_2_max__ = sum(stan::model::rvalue(level_size, stan::model::cons_list(stan::model::index_multi(estimand_levels), stan::model::nil_index_list()), "level_size"));
        size_t iter_level_entity_estimand_j_1_max__ = num_all_estimands;
        for (size_t j_2__ = 0; j_2__ < iter_level_entity_estimand_j_2_max__; ++j_2__) {
            for (size_t j_1__ = 0; j_1__ < iter_level_entity_estimand_j_1_max__; ++j_1__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "iter_level_entity_estimand" << '.' << j_1__ + 1 << '.' << j_2__ + 1;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        size_t iter_level_entity_estimand_sd_j_2_max__ = (logical_eq(run_type, RUN_TYPE_PRIOR_PREDICT) ? num_estimand_levels : 0 );
        size_t iter_level_entity_estimand_sd_j_1_max__ = num_all_estimands;
        for (size_t j_2__ = 0; j_2__ < iter_level_entity_estimand_sd_j_2_max__; ++j_2__) {
            for (size_t j_1__ = 0; j_1__ < iter_level_entity_estimand_sd_j_1_max__; ++j_1__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "iter_level_entity_estimand_sd" << '.' << j_1__ + 1 << '.' << j_2__ + 1;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        size_t iter_between_level_entity_diff_estimand_j_2_max__ = (sum(stan::model::rvalue(level_size, stan::model::cons_list(stan::model::index_multi(between_entity_diff_levels), stan::model::nil_index_list()), "level_size")) - num_between_entity_diff_levels);
        size_t iter_between_level_entity_diff_estimand_j_1_max__ = num_atom_estimands;
        for (size_t j_2__ = 0; j_2__ < iter_between_level_entity_diff_estimand_j_2_max__; ++j_2__) {
            for (size_t j_1__ = 0; j_1__ < iter_between_level_entity_diff_estimand_j_1_max__; ++j_1__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "iter_between_level_entity_diff_estimand" << '.' << j_1__ + 1 << '.' << j_2__ + 1;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        size_t iter_entity_discretized_histogram_vec_j_1_max__ = ((num_discretized_groups * (num_cutpoints - 1)) * num_unique_entities);
        for (size_t j_1__ = 0; j_1__ < iter_entity_discretized_histogram_vec_j_1_max__; ++j_1__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "iter_entity_discretized_histogram_vec" << '.' << j_1__ + 1;
            param_names__.push_back(param_name_stream__.str());
        }
        size_t iter_entity_discretized_mean_j_2_max__ = num_unique_entities;
        size_t iter_entity_discretized_mean_j_1_max__ = num_discretized_groups;
        for (size_t j_2__ = 0; j_2__ < iter_entity_discretized_mean_j_2_max__; ++j_2__) {
            for (size_t j_1__ = 0; j_1__ < iter_entity_discretized_mean_j_1_max__; ++j_1__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "iter_entity_discretized_mean" << '.' << j_1__ + 1 << '.' << j_2__ + 1;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        size_t iter_entity_discretized_utility_j_2_max__ = num_unique_entities;
        size_t iter_entity_discretized_utility_j_1_max__ = (logical_gt(num_discrete_utility_values, 0) ? num_discretized_groups : 0 );
        for (size_t j_2__ = 0; j_2__ < iter_entity_discretized_utility_j_2_max__; ++j_2__) {
            for (size_t j_1__ = 0; j_1__ < iter_entity_discretized_utility_j_1_max__; ++j_1__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "iter_entity_discretized_utility" << '.' << j_1__ + 1 << '.' << j_2__ + 1;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        size_t iter_mean_diff_estimand_j_2_max__ = num_unique_entities;
        size_t iter_mean_diff_estimand_j_1_max__ = num_mean_diff_estimands;
        for (size_t j_2__ = 0; j_2__ < iter_mean_diff_estimand_j_2_max__; ++j_2__) {
            for (size_t j_1__ = 0; j_1__ < iter_mean_diff_estimand_j_1_max__; ++j_1__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "iter_mean_diff_estimand" << '.' << j_1__ + 1 << '.' << j_2__ + 1;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        size_t iter_utility_diff_estimand_j_2_max__ = num_unique_entities;
        size_t iter_utility_diff_estimand_j_1_max__ = num_mean_diff_estimands;
        for (size_t j_2__ = 0; j_2__ < iter_utility_diff_estimand_j_2_max__; ++j_2__) {
            for (size_t j_1__ = 0; j_1__ < iter_utility_diff_estimand_j_1_max__; ++j_1__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "iter_utility_diff_estimand" << '.' << j_1__ + 1 << '.' << j_2__ + 1;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        size_t marginal_p_r_j_1_max__ = (calculate_marginal_prob ? total_num_bg_variable_types : 0 );
        for (size_t j_1__ = 0; j_1__ < marginal_p_r_j_1_max__; ++j_1__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "marginal_p_r" << '.' << j_1__ + 1;
            param_names__.push_back(param_name_stream__.str());
        }
    }
}; // model
}  // namespace
typedef model_bounded_namespace::model_bounded stan_model;
#endif

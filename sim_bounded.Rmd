---
title: "Bounded Counterfactual Estimation"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output:
  html_notebook:
    number_sections: yes
  bookdown::pdf_document2:
    number_sections: yes
    fig_caption: yes
    toc: yes
    toc_depth: 4
    keep_tex: yes
  word_document:
    fig_caption: yes
    toc: no
header-includes:
  - \usepackage[table,dvipsnames]{xcolor}
  - \usepackage{pxfonts}
  - \usepackage{bbm}
  - \usepackage{amsmath,amsfonts,amssymb}
  - \usepackage{mathtools}
  - \usepackage{subfig}
  - \usepackage{tikz}
  - \usepackage{booktabs}
bibliography: /home/karim/Documents/library.bib
urlcolor: blue
---

```{r setup, include=FALSE}
library(broom)
library(magrittr)
library(tidyverse)
library(rlang)
library(rstan)
library(parallel)
library(pbmcapply)

library(econometr)

options(mc.cores = max(1, parallel::detectCores()))
rstan_options(auto_write = TRUE)

source("util.R")
source("sim_bounded_util.R")
```

# Model

```{r}
scm <- define_response_type_combinations(
  define_response(
    "b",
    
    "branch assigned program" = ~ rep_along(r, 1),
    "branch assigned control" = ~ rep_along(r, 0),
  ),
  
  define_response(
    "w",
    
    "wedge assigned program" = ~ rep_along(r, 1),
    "wedge assigned control" = ~ rep_along(r, 0),
  ),
  
  define_response(
    "z",
    
    "village assigned treatment" = ~ rep_along(r, 1),
    "village assigned control" = ~ rep_along(r, 0),
  ),
  
  define_response( 
    "v",
    input = c("b", "w", "z"),
    
    "never offer village" = ~ rep_along(r, 0),
    "program complier" = ~ b,
    "wedge complier" = ~ w,
    "assigned treatment complier" = ~ z,
    "always offer village" = ~ rep_along(r, 1)
  ),
  
  define_response( 
    "d",
    input = c("v"),
    
    "never offer hh" = ~ rep_along(r, 0),
    "offer hh complier" = ~ v
  ),
  
  define_response( 
    "l",
    input = c("d"),
    
    "never borrow" = ~ rep_along(r, 0),
    "borrow if offered" = ~ d
  ),
  
  define_response( 
    "m",
    input = c("b", "w", "v", "l"),
    
    "never migrate" = ~ rep_along(r, 0),
    "program complier" = ~ b,
    "wedge complier" = ~ w,
    "village offer complier" = ~ v,
    "loan complier" = ~ l,
    "program defier" = ~ 1 - b,
    "wedge defier" = ~ 1 - w,
    "village offer defier" = ~ 1 - v,
    "loan defier" = ~ 1 - l,
    "no program or loan" = ~ (1 - b) + l,
    "no wedge or loan" = ~ (1 - w) + l,
    "no village offer or loan" = ~ (1 - v) + l,
    "always migrate" = ~ rep_along(r, 1),
  ),
  
  exogenous_variables = c("b", "w", "z"),
  exogenous_prob = expand_grid(b = 0:1, w = 0:1, z = 0:1) %>% 
    filter((b & (w | (1 - z))) | ((1 - z) & (1 - w))) %>% 
    mutate(
      ex_prob = ((1 - b) * 51 + b * 60) / 111,
      ex_prob = (1 - b) * ex_prob + b * (1/3) * ex_prob
    )
)
```

## Linear Programming Formulation

```{r}
# calc_bounds <- function(joint_dist, dir = c("min", "max"), cond, ...) {
#   obj_mask <- joint_dist %>% 
#     mutate(obj_indicator = as.integer({{ cond }})) %>% 
#     pull(obj_indicator)
#   
#   R <- calc_q2p_R_matrix(joint_dist) %$% 
#     do.call(rbind, mask)
#   
#   constr <- tribble(
#     ~ rows,               ~ dir,  ~ rhs,
#     
#     t(rep(1, ncol(R))),   "=",    1,
#     R,                    "=",    calc_p(joint_dist) %>% pull(p_cond_z),
#   )
# 
#   lp_partial <- partial(lpSolve::lp, 
#                         objective.in = obj_mask,
#                         const.mat = do.call(rbind, constr$rows),
#                         const.dir = unlist(map2(constr$rows, constr$dir, ~ rep(.y, NROW(.x)))),
#                         const.rhs = unlist(constr$rhs),
#                         ...)
#   
#   dir <- rlang::arg_match(dir)
#   
#   lp_partial(dir)$objval
# }

calc_q2p_R_matrix <- . %>% 
  select(latent_type_index, obs_prob_index, prob_r_z) %>% 
  arrange(obs_prob_index) %>% 
  group_by(obs_prob_index) %>% 
  summarize(types = list(latent_type_index),
            mask = list(magrittr::inset(rep(0, nrow(r_types)), latent_type_index, prob_r_z))) %>%  
  ungroup()

calc_p <- function(joint_dist) {
  joint_dist %>% 
    group_by(obs_prob_index) %>% 
    summarize(p = sum(prob * coalesce(prob_r_z, 0)))
}

calc_bounds <- function(joint_dist, dir = c("min", "max"), ..., cond) {
  calc_q2p_R_matrix <- . %>% 
    select(latent_type_index, obs_prob_index, prob_r_z) %>% 
    arrange(obs_prob_index) %>% 
    group_by(obs_prob_index) %>% 
    summarize(types = list(latent_type_index),
              mask = list(magrittr::inset(rep(0, nrow(r_types)), latent_type_index, prob_r_z))) %>%  
    ungroup()
  
  calc_p <- function(joint_dist) {
    joint_dist %>% 
      group_by(obs_prob_index) %>% 
      summarize(p = sum(prob * coalesce(prob_r_z, 0)))
  }
  
  joint_dist %<>% 
    unnest(outcomes) %>% 
    set_obs_outcomes(...) %>% 
    mutate(objective = ({{ cond }}) * coalesce(prob_r_z, 0))
  
  R <- calc_q2p_R_matrix(joint_dist) %$% 
    do.call(rbind, mask)
  
  constr <- tribble(
    ~ rows,               ~ dir,  ~ rhs,
    
    t(rep(1, ncol(R))),   "=",    1,
    R,                    "=",    calc_p(joint_dist) %>% pull(p),
  )

  lp_partial <- partial(lpSolve::lp, 
                        objective.in = joint_dist %>% group_by(latent_type_index) %>% summarize(objective = sum(objective)) %>% ungroup() %>% pull(objective),
                        const.mat = do.call(rbind, constr$rows),
                        const.dir = unlist(map2(constr$rows, constr$dir, ~ rep(.y, NROW(.x)))),
                        const.rhs = unlist(constr$rhs))
  
  dir <- rlang::arg_match(dir)
  
  lp_partial(dir)$objval
}

calc_joint_prob_bounds <- function(joint_dist) {
  R <- joint_dist %>% 
    unnest(outcomes) %>% 
    calc_q2p_R_matrix() %$% 
    do.call(rbind, mask)
  
  constr <- tribble(
    ~ rows,               ~ dir,  ~ rhs,
    
    t(rep(1, ncol(R))),   "=",    1,
    R,                    "=",    joint_dist %>% unnest(outcomes) %>% calc_p() %>% pull(p),
  )

  joint_dist %>% 
    mutate(objective = map(latent_type_index, ~ magrittr::inset(rep(0, nrow(r_types)), .x, 1)),
           min_prob = map(objective,
                          ~ lpSolve::lp(
                            direction = "min",
                            objective.in = .x,
                            const.mat = do.call(rbind, constr$rows),
                            const.dir = unlist(map2(constr$rows, constr$dir, ~ rep(.y, NROW(.x)))),
                            const.rhs = unlist(constr$rhs))),
           max_prob = map(objective, lpSolve::lp,
                          direction = "max",
                          const.mat = do.call(rbind, constr$rows),
                          const.dir = unlist(map2(constr$rows, constr$dir, ~ rep(.y, NROW(.x)))),
                          const.rhs = unlist(constr$rhs))) %>% 
    mutate_at(vars(min_prob, max_prob), ~ map_dbl(.x, "objval")) %>% 
    select(-objective)
}

```

# Simulation 

```{r}
sim_estimator <- build_estimator(

  r_types = scm,
  cores = 6,
  
  build_diff_estimand(
    build_atom_estimand("v", z = 1), # Non-compliance village treatment
    build_atom_estimand("v", b = 0)  # Compliance village treatment
  ),

  build_diff_estimand(
    build_atom_estimand("m", z = 1),
    build_atom_estimand("m", b = 0)
  ),

  build_diff_estimand(
    build_atom_estimand("m", d = 1),
    build_atom_estimand("m", d = 0)
  ),

  build_diff_estimand(
    build_atom_estimand("m", d = 1, cond = d == 1),
    build_atom_estimand("m", d = 0, cond = d == 1)
  ),

  build_diff_estimand(
    build_atom_estimand("m", d = 1, cond = d == 0),
    build_atom_estimand("m", d = 0, cond = d == 0)
  ),

  build_diff_estimand(
    build_atom_estimand("m", d = 0, cond = d == 1),
    build_atom_estimand("m", d = 0, cond = d == 0)
  ),

  build_diff_estimand(
    build_atom_estimand("m", v = 1, cond = v == 1),
    build_atom_estimand("m", v = 0, cond = v == 1)
  ),

  build_diff_estimand(
    build_atom_estimand("m", v = 1, cond = v == 0),
    build_atom_estimand("m", v = 0, cond = v == 0)
  ),

  build_diff_estimand(
    build_atom_estimand("m", v = 1, cond = v == 0 & z == 1),
    build_atom_estimand("m", v = 0, cond = v == 0 & z == 1)
  ),

  build_diff_estimand(
    build_atom_estimand("m", v = 1, cond = v == 1 & z == 0),
    build_atom_estimand("m", v = 0, cond = v == 1 & z == 0)
  ),

  build_atom_estimand("l", v = 1, cond = v == 1),
  build_atom_estimand("l", v = 1, cond = v == 0),
  build_atom_estimand("l", v = 1, cond = v == 1 & z == 0),
  build_atom_estimand("l", v = 1, cond = v == 0 & z == 1),

  build_diff_estimand(
    build_atom_estimand("v", z = 1),
    build_atom_estimand("v", z = 0)
  ),

  build_diff_estimand(
    build_atom_estimand("m", l = 1),
    build_atom_estimand("m", l = 0)
  ),

  build_diff_estimand(
    build_atom_estimand("m", l = 1, cond = l == 1),
    build_atom_estimand("m", l = 0, cond = l == 1)
  ),

  build_diff_estimand(
    build_atom_estimand("d", z = 1),
    build_atom_estimand("d", z = 0)
  ),

  build_diff_estimand(
    build_atom_estimand("d", v = 1),
    build_atom_estimand("d", v = 0)
  ),

  build_diff_estimand(
    build_atom_estimand("d", v = 1, cond = v == 1),
    build_atom_estimand("d", v = 0, cond = v == 1)
  ),

  build_diff_estimand(
    build_atom_estimand("m", d = 1),
    build_atom_estimand("m", d = 0)
  ),

  build_diff_estimand(
    build_atom_estimand("m", d = 1, cond = d == 1),
    build_atom_estimand("m", d = 0, cond = d == 1)
  ),
)
```

```{r simple-run, eval=FALSE}
sim_scm <- create_scm_simulation(scm, 4000)

sim_sampler <- sim_scm %>% create_sampler(estimators = sim_estimator)

sim_results <- sim_sampler %>% 
  sampling(
    chains = 4,
    refresh = 250,
    iter = 1000,
    save_warmup = FALSE,
    pars = "iter_estimand",
  )

sim_est_results <- get_estimation_results(sim_results)

pop_est_results <- get_known_estimands(sim_scm, sim_estimator)
```

```{r, eval=FALSE}
prior_predict_results <- sim_sampler %>% 
  sampling(
    chains = 4,
    refresh = 250,
    iter = 1000,
    save_warmup = FALSE,
    pars = c("iter_estimand", "marginal_p_r"),
    run_type = "prior-predict"
  )
```

```{r test-run, eval=FALSE}
num_runs <- 30

test_parallel_map <- function(.x, .f, ..., cores = 12) {
  pbmclapply(.x, as_mapper(.f), ..., ignore.interactive = TRUE, mc.silent = TRUE, mc.cores = cores)
}

test_run_data <- tibble(
  run_index = seq(num_runs),
  sim_scm = test_parallel_map(run_index, ~ create_scm_simulation(scm, sample_size = 4000)),
  # sim_sampler = test_parallel_map(sim_scm, create_sampler, estimators = sim_estimator),
  
  pop_est = test_parallel_map(sim_scm, get_known_estimands, estimators = sim_estimator, cores = 1),
  
  sim_est_results = test_parallel_map(sim_scm, create_sampler, estimators = sim_estimator) %>% 
    test_parallel_map(~ sampling(., pars = "iter_estimand", chains = 4, iter = 1000, save_warmup = FALSE) %>% 
                        get_estimation_results() %>% 
                        select(-iter_data),
                      cores = 3),
)

save(test_run_data, file = file.path("stan_analysis_data", "bounded_test_run.RData"))
```

```{r}
load(file.path("stan_analysis_data", "bounded_test_run.RData"))
```

```{r, fig.width=15}
test_run_data$est_joint_prob[[1]] %>% 
  calc_joint_prob_bounds() %>% 
  # unnest(prob_est) %>% 
  ggplot() +
  geom_vline(aes(xintercept = prob)) +
  geom_vline(aes(xintercept = min_prob), linetype = "dashed") +
  geom_vline(aes(xintercept = max_prob), linetype = "dashed") +
  geom_histogram(aes(iter_est), binwidth = 0.0025, alpha = 0.75, data = . %>% unnest(prob_est)) +
  facet_wrap(vars(latent_type_index))
```

```{r, fig.width=12, fig.height=24}
test_run_data %>% 
  transmute(run_index, combined = map2(sim_est_results, pop_est, inner_join, by = c("estimand_id", "estimand_name"))) %>% 
  unnest(combined) %>% 
  mutate_at(vars(starts_with("per_")), ~ . - prob) %>% 
  mutate(out_bounds = factor(as.integer(per_0.95 < 0 | per_0.05 > 0), levels = 0:1, labels = c("in", "out"))) %>% 
  ggplot(aes(x = run_index)) +
  geom_pointrange(aes(y = per_0.5, ymin = per_0.05, ymax = per_0.95, color = out_bounds), fatten = 0.5, show.legend = FALSE) +
  geom_hline(yintercept = 0, linetype = "dotted") +
  scale_color_manual("", values = lst("in" = "black", "out" = "red")) +
  labs(x = "", y = "") +
  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank(), panel.grid.major.x = element_blank(), panel.grid.minor.x = element_blank()) +
  facet_wrap(vars(estimand_name), scales = "free_y", ncol = 4, 
             labeller = as_labeller(function(estimand_name) latex2exp::TeX(str_replace_all(estimand_name, "([\\[\\]])", "\\\\\\1")), default = label_parsed))
```


```{r, eval= FALSE}
test_run_data %>% 
  unnest(fit_est) %>% 
  unnest(r_prob) %>% 
  ggplot(aes(est_r_prob)) +
  geom_density() +
  # geom_vline(aes(xintercept = r_prob), data = test_run_data %>% unnest(pop_est)) +
  # ggridges::geom_density_ridges() +
  facet_wrap(vars(run_index))
```


```{r, fig.width=14, fig.height=10}
ci <- lst(0.8, 0.9, 0.95)

est_terms <- c("m_d0", "m_d1", 
               "m_l0", "m_l1",
               "l_d1_cond_d1cfz1", "l_d1_cond_d0cfz1")

test_run_data %>% 
  mutate(estimates = map(fit,
                         ~ map_dfr(ci,
                                   ~ tidy(.y, pars = est_terms, estimate.method = "median", conf.int = TRUE, conf.level = .x),
                                   .x,
                                   .id = "ci") %>%
                           mutate(ci = as.numeric(ci)))) %>%
  unnest(estimates) %>%
  mutate(
    true_upper_bound = case_when(term == "m_d0" ~ m_d0_max,
                                 term == "m_d1" ~ m_d1_max,
                                 term == "l_d1_cond_d0cfz1" ~ l_d1_cond_d0.z1_max,
                                 term == "l_d1_cond_d1cfz1" ~ l_d1_cond_d1.z1_max),
    true_lower_bound = case_when(term == "m_d0" ~ m_d0_min,
                                 term == "m_d1" ~ m_d1_min,
                                 term == "l_d1_cond_d0cfz1" ~ l_d1_cond_d0.z1_min,
                                 term == "l_d1_cond_d1cfz1" ~ l_d1_cond_d1.z1_min),
    
    fs_estimand = case_when(term == "m_d0" ~ mean_m_d0, 
                            term == "m_d1" ~ mean_m_d1,
                            # term == "ace_d" ~ mean_ace_d,
                            term == "m_l0" ~ mean_m_l0,
                            term == "m_l1" ~ mean_m_l1,
                            term == "l_d1_cond_d0cfz1" ~ mean_l_d1_cond_d0.z1,
                            term == "l_d1_cond_d1cfz1" ~ mean_l_d1_cond_d1.z1),
                            # term == "ace_l" ~ mean_ace_l,
                            # term == "m_l0_z1" ~ mean_m_l0_z1,
                            # term == "m_l1_z1" ~ mean_m_l1_z1,
                            # term == "m_l0_z1_cond_l1" ~ mean_m_l0_z1_cond_l1,
                            # term == "m_l1_z1_cond_l1" ~ mean_m_l1_z1_cond_l1,
                            # term == "m_l0_cond_l1_z1" ~ mean_m_l0_cond_l1_z1,
                            # term == "m_l1_cond_l1_z1" ~ mean_m_l1_cond_l1_z1,
                            # term == "m_d0_cond_d1" ~ mean_m_d0_cond_d1,
                            # term == "m_d1_cond_d1" ~ mean_m_d1_cond_d1,
                            # term == "m_d0_cond_d1_z1" ~ mean_m_d0_cond_d1_z1,
                            # term == "m_d1_cond_d1_z1" ~ mean_m_d1_cond_d1_z1),
    pop_estimand = case_when(term == "m_d0" ~ m_d0,
                             term == "m_d1" ~ m_d1,
                             # term == "ace_d" ~ ace_d,
                             term == "m_l0" ~ m_l0,
                             term == "m_l1" ~ m_l1,
                             term == "l_d1_cond_d0cfz1" ~ l_d1_cond_d0.z1,
                             term == "l_d1_cond_d1cfz1" ~ l_d1_cond_d1.z1)
  ) %>% 
                                  # term == "ace_l" ~ ace_l,
                                  # term == "m_l0_z1" ~ m_l0_z1,
                                  # term == "m_l1_z1" ~ m_l1_z1,
                                  # term == "m_l0_z1_cond_l1" ~ m_l0_z1_cond_l1,
                                  # term == "m_l1_z1_cond_l1" ~ m_l1_z1_cond_l1,
                                  # term == "m_l0_cond_l1_z1" ~ m_l0_cond_l1_z1,
                                  # term == "m_l1_cond_l1_z1" ~ m_l1_cond_l1_z1,
                                  # term == "m_d0_cond_d1" ~ m_d0_cond_d1,
                                  # term == "m_d1_cond_d1" ~ m_d1_cond_d1,
                                  # term == "m_d0_cond_d1_z1" ~ m_d0_cond_d1_z1,
                                  # term == "m_d1_cond_d1_z1" ~ m_d1_cond_d1_z1)) %>% 
  filter(ci == 0.9) %>% 
  group_by(term) %>% 
  mutate(sort_index = rank(pop_estimand)) %>% 
  ungroup() %>% 
  ggplot(aes(x = sort_index)) +
  geom_point(aes(y = fs_estimand, color = "Finite Sample Mean")) +
  geom_pointrange(aes(y = estimate, ymin = conf.low, ymax = conf.high), fatten = 0.75, alpha = 0.5) +
  geom_line(aes(y = pop_estimand, color = "Population Mean")) +
  geom_line(aes(y = true_upper_bound, color = "Population Mean"), linetype = "dashed") +
  geom_line(aes(y = true_lower_bound, color = "Population Mean"), linetype = "dashed") +
  scale_color_discrete("") +
  labs(x = "", y = "") +
  facet_wrap(vars(term), scales = "free_y") +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank())
```

# Application

```{r}
load(file = file.path("data", "cleaned_hh.RData"))
load(file = file.path("data", "rct_2017_branch_village_hh.RData"))
load(file = file.path("data", "rct_metadata.RData"))

bangladesh_deflators <- read_csv(file.path("data", "bangladesh_deflator.csv")) %>% 
  gather(year, deflator) %>% 
  tidyr::extract(year, "year", "YR(\\d+)]", convert = TRUE) %>% 
  mutate(base_year = 2008) %>% 
  left_join(., ., c("base_year" = "year"), suffix = c("", "_base_year")) %>% 
  mutate(deflator = (deflator / deflator_base_year) * 100)
```

## NLS 2017-2018

```{r}
nls_analysis_data_2017 <- prep_nls_data_2017(hh_data, rct_metadata, origin_price_data, study_village_cuts_admin_data, bangladesh_deflators,
                                             include_new_eligible = TRUE) %>% 
  filter(treatment_rct %in% c("incentivized", "pure-control"))

# nls_2017_r_d_types <- lst(
#   "offer-complier" = ~ .x,
# )

nls_2017_stan_data <- transmute(nls_analysis_data_2017,
  z = treatment_rct == "incentivized",
  d = z, # Assume perfect offer compliance 
  l = coalesce(loan_disbursed, FALSE),
  m = mig_mem_midline,
  
  type_d_candidates = get_r_type_candidates(z, response = d, r_types = r_d_types) %>% pull(candidates), 
  type_l_candidates = get_r_type_candidates(d, response = l, r_types = r_l_types) %>% pull(candidates), 
  type_m_candidates = get_r_type_candidates(d, l, response = m, r_types = r_m_types) %>% pull(candidates),
  
  r_candidates = pmap(list(type_d_candidates, type_l_candidates, type_m_candidates), get_type_candidates, r_types = r_types)
) %>% 
  mutate_at(vars(ends_with("candidates")), lst(count = ~ map_int(., NROW))) %>% 
  rename_at(vars(ends_with("_count")), ~ str_replace(., "(.+)_count", "num_\\1")) %>% {
    list_modify(
      map_at(., vars(matches("^type_[dlm]_candidates$"), r_candidates), unlist),
      
      num_obs = nrow(.),
      num_r_d_types = length(r_d_types),
      num_r_l_types = length(r_l_types),
      num_r_m_types = length(r_m_types), 
      
      r_prob_alpha = if_else(!fct_match(r_types$r_d, "offer-complier"), 0, 1),
      r_map = r_types %>% 
        mutate_at(vars(r_d, r_l, r_m), list(index = ~ as.integer(.))) %>% 
        arrange(latent_type_index) %>% 
        select(r_d_index, r_l_index, r_m_index),
      
      num_levels = 0,
      level_size = array(dim = 0), #nls_analysis_data_2017 %>% count(district) %>% arrange(district) %>% nrow() %>% as.array(),
      level_entity_size = array(dim = 0), # nls_analysis_data_2017 %>% count(district) %>%  arrange(district) %>% pull(n),
      parent_level_entity = array(dim = 0), # as.integer(nls_analysis_data_2017$district),
    
    cond_prob_d1_prob_r_z = r_types %>% 
      mutate(outcomes = map(outcomes, filter, d == 1), 
             cond_prob_r_z = map_dbl(outcomes, ~ sum(.$prob_r_z))) %>% 
      pull(cond_prob_r_z),
    
    cond_prob_l1_prob_r_z = r_types %>% 
      mutate(outcomes = map(outcomes, filter, l == 1), 
             cond_prob_r_z = map_dbl(outcomes, ~ sum(.$prob_r_z))) %>% 
      pull(cond_prob_r_z),
    
    cond_prob_d1_z1 = r_types %>% 
      mutate(outcomes = map(outcomes, filter, d == 1, z == 1), 
             cond_prob = map_lgl(outcomes, ~ NROW(.) > 0)) %>% 
      pull(cond_prob),
    
    cond_prob_l1_z1 = r_types %>% 
      mutate(outcomes = map(outcomes, filter, l == 1, z == 1), 
             cond_prob = map_lgl(outcomes, ~ NROW(.) > 0)) %>% 
      pull(cond_prob),
    
    cond_prob_d0_z1 = r_types %>% 
      mutate(outcomes = map(outcomes, filter, d == 0, z == 1), 
             cond_prob = map_lgl(outcomes, ~ NROW(.) > 0)) %>% 
      pull(cond_prob),
    
    cond_prob_l0_z1 = r_types %>% 
      mutate(outcomes = map(outcomes, filter, l == 0, z == 1), 
             cond_prob = map_lgl(outcomes, ~ NROW(.) > 0)) %>% 
      pull(cond_prob),
    )
  } %>% 
  map_if(is.factor, as.integer)

bounded_model <- stan_model(file.path("stan_models", "bounded.stan"))

nls_2017_bounded_fit <- sampling(
  bounded_model,
  data = nls_2017_stan_data,
  chains = 4,
  iter = 4000,
  save_warmup = FALSE, 
  control = lst(max_treedepth = 15),
  include = FALSE,
  pars = c("r_prob", "included_r_prob")
  # 
  # init = function() lst(r_prob = c(MCMCpack::rdirichlet(1, nls_2017_stan_data$r_prob_alpha)),
  #                       include_r_prob = if_else(nls_2017_stan_data$r_prob_alpha > 0, r_prob, 0))
)
```

